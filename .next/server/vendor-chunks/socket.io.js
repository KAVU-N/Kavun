"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socket.io";
exports.ids = ["vendor-chunks/socket.io"];
exports.modules = {

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ \nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    let m;\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === \"%%\") {\n            return;\n        }\n        index++;\n        if (match === \"%c\") {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem(\"debug\", namespaces);\n        } else {\n            exports.storage.removeItem(\"debug\");\n        }\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem(\"debug\");\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsR0FFdEI7O0NBRUM7QUFFREEsa0JBQWtCLEdBQUdDO0FBQ3JCRCxZQUFZLEdBQUdFO0FBQ2ZGLFlBQVksR0FBR0c7QUFDZkgsaUJBQWlCLEdBQUdJO0FBQ3BCSixlQUFlLEdBQUdNO0FBQ2xCTixlQUFlLEdBQUcsQ0FBQztJQUNsQixJQUFJUSxTQUFTO0lBRWIsT0FBTztRQUNOLElBQUksQ0FBQ0EsUUFBUTtZQUNaQSxTQUFTO1lBQ1RDLFFBQVFDLElBQUksQ0FBQztRQUNkO0lBQ0Q7QUFDRDtBQUVBOztDQUVDLEdBRURWLGNBQWMsR0FBRztJQUNoQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNBO0FBRUQ7Ozs7OztDQU1DLEdBRUQsc0NBQXNDO0FBQ3RDLFNBQVNJO0lBQ1IsNEVBQTRFO0lBQzVFLDBFQUEwRTtJQUMxRSxhQUFhO0lBQ2IsSUFBSSxLQUFnSCxFQUFFLEVBRXJIO0lBRUQsb0RBQW9EO0lBQ3BELElBQUksT0FBT1ksY0FBYyxlQUFlQSxVQUFVQyxTQUFTLElB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RDtRQUMzRCxPQUFPNEM7SUFDUixFQUFFLE9BQU9MLE9BQU87SUFDZixVQUFVO0lBQ1YsMENBQTBDO0lBQzNDO0FBQ0Q7QUFFQWQsT0FBTy9CLE9BQU8sR0FBR21ELG1CQUFPQSxDQUFDLG1GQUFZbkQ7QUFFckMsTUFBTSxFQUFDb0QsVUFBVSxFQUFDLEdBQUdyQixPQUFPL0IsT0FBTztBQUVuQzs7Q0FFQyxHQUVEb0QsV0FBV0MsQ0FBQyxHQUFHLFNBQVVDLENBQUM7SUFDekIsSUFBSTtRQUNILE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0Y7SUFDdkIsRUFBRSxPQUFPVCxPQUFPO1FBQ2YsT0FBTyxpQ0FBaUNBLE1BQU1ZLE9BQU87SUFDdEQ7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21lZGNvZGVzX2FwcC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzPzgwNTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGxldCBtO1xuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIChtID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykpICYmIHBhcnNlSW50KG1bMV0sIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJsb2NhbHN0b3JhZ2UiLCJkZXN0cm95Iiwid2FybmVkIiwiY29uc29sZSIsIndhcm4iLCJjb2xvcnMiLCJ3aW5kb3ciLCJwcm9jZXNzIiwidHlwZSIsIl9fbndqcyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwibWF0Y2giLCJtIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIldlYmtpdEFwcGVhcmFuY2UiLCJmaXJlYnVnIiwiZXhjZXB0aW9uIiwidGFibGUiLCJwYXJzZUludCIsImFyZ3MiLCJuYW1lc3BhY2UiLCJtb2R1bGUiLCJodW1hbml6ZSIsImRpZmYiLCJjIiwiY29sb3IiLCJzcGxpY2UiLCJpbmRleCIsImxhc3RDIiwicmVwbGFjZSIsImxvZyIsImRlYnVnIiwibmFtZXNwYWNlcyIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiZXJyb3IiLCJyIiwiZ2V0SXRlbSIsImVudiIsIkRFQlVHIiwibG9jYWxTdG9yYWdlIiwicmVxdWlyZSIsImZvcm1hdHRlcnMiLCJqIiwidiIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ \nfunction setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== \"string\") {\n                // Anything else let's inspect with %O\n                args.unshift(\"%O\");\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === \"%%\") {\n                    return \"%\";\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === \"function\") {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, \"enabled\", {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === \"function\") {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === \"undefined\" ? \":\" : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n        const len = split.length;\n        for(i = 0; i < len; i++){\n            if (!split[i]) {\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, \".*?\");\n            if (namespaces[0] === \"-\") {\n                createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\"));\n            } else {\n                createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n            }\n        }\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map((namespace)=>\"-\" + namespace)\n        ].join(\",\");\n        createDebug.enable(\"\");\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        if (name[name.length - 1] === \"*\") {\n            return true;\n        }\n        let i;\n        let len;\n        for(i = 0, len = createDebug.skips.length; i < len; i++){\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for(i = 0, len = createDebug.names.length; i < len; i++){\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/ function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUNBOzs7Q0FHQztBQUVELFNBQVNBLE1BQU1DLEdBQUc7SUFDakJDLFlBQVlDLEtBQUssR0FBR0Q7SUFDcEJBLFlBQVlFLE9BQU8sR0FBR0Y7SUFDdEJBLFlBQVlHLE1BQU0sR0FBR0E7SUFDckJILFlBQVlJLE9BQU8sR0FBR0E7SUFDdEJKLFlBQVlLLE1BQU0sR0FBR0E7SUFDckJMLFlBQVlNLE9BQU8sR0FBR0E7SUFDdEJOLFlBQVlPLFFBQVEsR0FBR0MsbUJBQU9BLENBQUM7SUFDL0JSLFlBQVlTLE9BQU8sR0FBR0E7SUFFdEJDLE9BQU9DLElBQUksQ0FBQ1osS0FBS2EsT0FBTyxDQUFDQyxDQUFBQTtRQUN4QmIsV0FBVyxDQUFDYSxJQUFJLEdBQUdkLEdBQUcsQ0FBQ2MsSUFBSTtJQUM1QjtJQUVBOztDQUVBLEdBRUFiLFlBQVljLEtBQUssR0FBRyxFQUFFO0lBQ3RCZCxZQUFZZSxLQUFLLEdBQUcsRUFBRTtJQUV0Qjs7OztDQUlBLEdBQ0FmLFlBQVlnQixVQUFVLEdBQUcsQ0FBQztJQUUxQjs7Ozs7Q0FLQSxHQUNBLFNBQVNDLFlBQVlDLFNBQVM7UUFDN0IsSUFBSUMsT0FBTztRQUVYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixVQUFVRyxNQUFNLEVBQUVELElBQUs7WUFDMUNELE9BQU8sQ0FBRUEsUUFBUSxLQUFLQSxPQUFRRCxVQUFVSSxVQUFVLENBQUNGO1lBQ25ERCxRQUFRLEdBQUcsMkJBQTJCO1FBQ3ZDO1FBRUEsT0FBT25CLFlBQVl1QixNQUFNLENBQUNDLEtBQUtDLEdBQUcsQ0FBQ04sUUFBUW5CLFlBQVl1QixNQUFNLENBQUNGLE1BQU0sQ0FBQztJQUN0RTtJQUNBckIsWUFBWWlCLFdBQVcsR0FBR0E7SUFFMUI7Ozs7OztDQU1BLEdBQ0EsU0FBU2pCLFlBQVlrQixTQUFTO1FBQzdCLElBQUlRO1FB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QU1sRSxZQUFZZSxLQUFLLENBQUNNLE1BQU0sRUFBRUQsSUFBSThDLEtBQUs5QyxJQUFLO1lBQ3pELElBQUlwQixZQUFZZSxLQUFLLENBQUNLLEVBQUUsQ0FBQ3NELElBQUksQ0FBQ0QsT0FBTztnQkFDcEMsT0FBTztZQUNSO1FBQ0Q7UUFFQSxJQUFLckQsSUFBSSxHQUFHOEMsTUFBTWxFLFlBQVljLEtBQUssQ0FBQ08sTUFBTSxFQUFFRCxJQUFJOEMsS0FBSzlDLElBQUs7WUFDekQsSUFBSXBCLFlBQVljLEtBQUssQ0FBQ00sRUFBRSxDQUFDc0QsSUFBSSxDQUFDRCxPQUFPO2dCQUNwQyxPQUFPO1lBQ1I7UUFDRDtRQUVBLE9BQU87SUFDUjtJQUVBOzs7Ozs7Q0FNQSxHQUNBLFNBQVNGLFlBQVlJLE1BQU07UUFDMUIsT0FBT0EsT0FBT0MsUUFBUSxHQUNwQkMsU0FBUyxDQUFDLEdBQUdGLE9BQU9DLFFBQVEsR0FBR3ZELE1BQU0sR0FBRyxHQUN4Q21CLE9BQU8sQ0FBQyxXQUFXO0lBQ3RCO0lBRUE7Ozs7OztDQU1BLEdBQ0EsU0FBU3JDLE9BQU95QyxHQUFHO1FBQ2xCLElBQUlBLGVBQWVrQyxPQUFPO1lBQ3pCLE9BQU9sQyxJQUFJbUMsS0FBSyxJQUFJbkMsSUFBSW9DLE9BQU87UUFDaEM7UUFDQSxPQUFPcEM7SUFDUjtJQUVBOzs7Q0FHQSxHQUNBLFNBQVNuQztRQUNSd0UsUUFBUUMsSUFBSSxDQUFDO0lBQ2Q7SUFFQWxGLFlBQVlLLE1BQU0sQ0FBQ0wsWUFBWW1GLElBQUk7SUFFbkMsT0FBT25GO0FBQ1I7QUFFQW9GLE9BQU9DLE9BQU8sR0FBR3ZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkY29kZXNfYXBwLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcz82Y2YyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iXSwibmFtZXMiOlsic2V0dXAiLCJlbnYiLCJjcmVhdGVEZWJ1ZyIsImRlYnVnIiwiZGVmYXVsdCIsImNvZXJjZSIsImRpc2FibGUiLCJlbmFibGUiLCJlbmFibGVkIiwiaHVtYW5pemUiLCJyZXF1aXJlIiwiZGVzdHJveSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwibmFtZXMiLCJza2lwcyIsImZvcm1hdHRlcnMiLCJzZWxlY3RDb2xvciIsIm5hbWVzcGFjZSIsImhhc2giLCJpIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImNvbG9ycyIsIk1hdGgiLCJhYnMiLCJwcmV2VGltZSIsImVuYWJsZU92ZXJyaWRlIiwibmFtZXNwYWNlc0NhY2hlIiwiZW5hYmxlZENhY2hlIiwiYXJncyIsInNlbGYiLCJjdXJyIiwiTnVtYmVyIiwiRGF0ZSIsIm1zIiwiZGlmZiIsInByZXYiLCJ1bnNoaWZ0IiwiaW5kZXgiLCJyZXBsYWNlIiwibWF0Y2giLCJmb3JtYXQiLCJmb3JtYXR0ZXIiLCJ2YWwiLCJjYWxsIiwic3BsaWNlIiwiZm9ybWF0QXJncyIsImxvZ0ZuIiwibG9nIiwiYXBwbHkiLCJ1c2VDb2xvcnMiLCJjb2xvciIsImV4dGVuZCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImdldCIsIm5hbWVzcGFjZXMiLCJzZXQiLCJ2IiwiaW5pdCIsImRlbGltaXRlciIsIm5ld0RlYnVnIiwic2F2ZSIsInNwbGl0IiwibGVuIiwicHVzaCIsIlJlZ0V4cCIsInNsaWNlIiwibWFwIiwidG9OYW1lc3BhY2UiLCJqb2luIiwibmFtZSIsInRlc3QiLCJyZWdleHAiLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsIkVycm9yIiwic3RhY2siLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iLCJsb2FkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */ \nif (typeof process === \"undefined\" || process.type === \"renderer\" || false === true || process.__nwjs) {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDO0FBRUQsSUFBSSxPQUFPQSxZQUFZLGVBQWVBLFFBQVFDLElBQUksS0FBSyxjQUFjRCxLQUFlLEtBQUssUUFBUUEsUUFBUUcsTUFBTSxFQUFFO0lBQ2hIQyw0SEFBeUI7QUFDMUIsT0FBTztJQUNOQSxzSEFBeUI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWRjb2Rlc19hcHAvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanM/YjAwMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERldGVjdCBFbGVjdHJvbiByZW5kZXJlciAvIG53anMgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZSB8fCBwcm9jZXNzLl9fbndqcykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwidHlwZSIsImJyb3dzZXIiLCJfX253anMiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */ \nconst tty = __webpack_require__(/*! tty */ \"tty\");\nconst util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n */ exports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(()=>{}, \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\ntry {\n    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n    // eslint-disable-next-line import/no-extraneous-dependencies\n    const supportsColor = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\n    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n        exports.colors = [\n            20,\n            21,\n            26,\n            27,\n            32,\n            33,\n            38,\n            39,\n            40,\n            41,\n            42,\n            43,\n            44,\n            45,\n            56,\n            57,\n            62,\n            63,\n            68,\n            69,\n            74,\n            75,\n            76,\n            77,\n            78,\n            79,\n            80,\n            81,\n            92,\n            93,\n            98,\n            99,\n            112,\n            113,\n            128,\n            129,\n            134,\n            135,\n            148,\n            149,\n            160,\n            161,\n            162,\n            163,\n            164,\n            165,\n            166,\n            167,\n            168,\n            169,\n            170,\n            171,\n            172,\n            173,\n            178,\n            179,\n            184,\n            185,\n            196,\n            197,\n            198,\n            199,\n            200,\n            201,\n            202,\n            203,\n            204,\n            205,\n            206,\n            207,\n            208,\n            209,\n            214,\n            215,\n            220,\n            221\n        ];\n    }\n} catch (error) {\n// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{\n    return /^debug_/i.test(key);\n}).reduce((obj, key)=>{\n    // Camel-case\n    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{\n        return k.toUpperCase();\n    });\n    // Coerce string value into JS value\n    let val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) {\n        val = true;\n    } else if (/^(no|off|false|disabled)$/i.test(val)) {\n        val = false;\n    } else if (val === \"null\") {\n        val = null;\n    } else {\n        val = Number(val);\n    }\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n}\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    const { namespace: name, useColors } = this;\n    if (useColors) {\n        const c = this.color;\n        const colorCode = \"\\x1b[3\" + (c < 8 ? c : \"8;5;\" + c);\n        const prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(colorCode + \"m+\" + module.exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = getDate() + name + \" \" + args[0];\n    }\n}\nfunction getDate() {\n    if (exports.inspectOpts.hideDate) {\n        return \"\";\n    }\n    return new Date().toISOString() + \" \";\n}\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */ function log(...args) {\n    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (namespaces) {\n        process.env.DEBUG = namespaces;\n    } else {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    const keys = Object.keys(exports.inspectOpts);\n    for(let i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map((str)=>str.trim()).join(\" \");\n};\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */ formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQztBQUVELE1BQU1BLE1BQU1DLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBRXJCOztDQUVDLEdBRURFLFlBQVksR0FBR0M7QUFDZkQsV0FBVyxHQUFHRTtBQUNkRixrQkFBa0IsR0FBR0c7QUFDckJILFlBQVksR0FBR0k7QUFDZkosWUFBWSxHQUFHSztBQUNmTCxpQkFBaUIsR0FBR007QUFDcEJOLGVBQWUsR0FBR0QsS0FBS1MsU0FBUyxDQUMvQixLQUFPLEdBQ1A7QUFHRDs7Q0FFQyxHQUVEUixjQUFjLEdBQUc7SUFBQztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7Q0FBRTtBQUVuQyxJQUFJO0lBQ0gsMkdBQTJHO0lBQzNHLDZEQUE2RDtJQUM3RCxNQUFNVSxnQkFBZ0JaLG1CQUFPQSxDQUFDO0lBRTlCLElBQUlZLGlCQUFpQixDQUFDQSxjQUFjQyxNQUFNLElBQUlELGFBQVksRUFBR0UsS0FBSyxJQUFJLEdBQUc7UUFDeEVaLGNBQWMsR0FBRztZQUNoQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNB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QUFXLEdBQUcsQ0FBQztJQUVyQixNQUFNRSxPQUFPRCxPQUFPQyxJQUFJLENBQUNoQixRQUFRYyxXQUFXO0lBQzVDLElBQUssSUFBSTRDLElBQUksR0FBR0EsSUFBSTFDLEtBQUsyQyxNQUFNLEVBQUVELElBQUs7UUFDckNELE1BQU0zQyxXQUFXLENBQUNFLElBQUksQ0FBQzBDLEVBQUUsQ0FBQyxHQUFHMUQsUUFBUWMsV0FBVyxDQUFDRSxJQUFJLENBQUMwQyxFQUFFLENBQUM7SUFDMUQ7QUFDRDtBQUVBWixPQUFPOUMsT0FBTyxHQUFHRixtQkFBT0EsQ0FBQyxtRkFBWUU7QUFFckMsTUFBTSxFQUFDNEQsVUFBVSxFQUFDLEdBQUdkLE9BQU85QyxPQUFPO0FBRW5DOztDQUVDLEdBRUQ0RCxXQUFXQyxDQUFDLEdBQUcsU0FBVUMsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXLEVBQ3JDNkIsS0FBSyxDQUFDLE1BQ05xQixHQUFHLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLElBQUksSUFDbkJ0QixJQUFJLENBQUM7QUFDUjtBQUVBOztDQUVDLEdBRURnQixXQUFXTyxDQUFDLEdBQUcsU0FBVUwsQ0FBQztJQUN6QixJQUFJLENBQUNoRCxXQUFXLENBQUNMLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVM7SUFDeEMsT0FBT1AsS0FBS2dFLE9BQU8sQ0FBQ0QsR0FBRyxJQUFJLENBQUNoRCxXQUFXO0FBQ3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkY29kZXNfYXBwLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanM/MTUyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5kZXN0cm95ID0gdXRpbC5kZXByZWNhdGUoXG5cdCgpID0+IHt9LFxuXHQnSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLidcbik7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuXHQvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5cdGNvbnN0IHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuXG5cdGlmIChzdXBwb3J0c0NvbG9yICYmIChzdXBwb3J0c0NvbG9yLnN0ZGVyciB8fCBzdXBwb3J0c0NvbG9yKS5sZXZlbCA+PSAyKSB7XG5cdFx0ZXhwb3J0cy5jb2xvcnMgPSBbXG5cdFx0XHQyMCxcblx0XHRcdDIxLFxuXHRcdFx0MjYsXG5cdFx0XHQyNyxcblx0XHRcdDMyLFxuXHRcdFx0MzMsXG5cdFx0XHQzOCxcblx0XHRcdDM5LFxuXHRcdFx0NDAsXG5cdFx0XHQ0MSxcblx0XHRcdDQyLFxuXHRcdFx0NDMsXG5cdFx0XHQ0NCxcblx0XHRcdDQ1LFxuXHRcdFx0NTYsXG5cdFx0XHQ1Nyxcblx0XHRcdDYyLFxuXHRcdFx0NjMsXG5cdFx0XHQ2OCxcblx0XHRcdDY5LFxuXHRcdFx0NzQsXG5cdFx0XHQ3NSxcblx0XHRcdDc2LFxuXHRcdFx0NzcsXG5cdFx0XHQ3OCxcblx0XHRcdDc5LFxuXHRcdFx0ODAsXG5cdFx0XHQ4MSxcblx0XHRcdDkyLFxuXHRcdFx0OTMsXG5cdFx0XHQ5OCxcblx0XHRcdDk5LFxuXHRcdFx0MTEyLFxuXHRcdFx0MTEzLFxuXHRcdFx0MTI4LFxuXHRcdFx0MTI5LFxuXHRcdFx0MTM0LFxuXHRcdFx0MTM1LFxuXHRcdFx0MTQ4LFxuXHRcdFx0MTQ5LFxuXHRcdFx0MTYwLFxuXHRcdFx0MTYxLFxuXHRcdFx0MTYyLFxuXHRcdFx0MTYzLFxuXHRcdFx0MTY0LFxuXHRcdFx0MTY1LFxuXHRcdFx0MTY2LFxuXHRcdFx0MTY3LFxuXHRcdFx0MTY4LFxuXHRcdFx0MTY5LFxuXHRcdFx0MTcwLFxuXHRcdFx0MTcxLFxuXHRcdFx0MTcyLFxuXHRcdFx0MTczLFxuXHRcdFx0MTc4LFxuXHRcdFx0MTc5LFxuXHRcdFx0MTg0LFxuXHRcdFx0MTg1LFxuXHRcdFx0MTk2LFxuXHRcdFx0MTk3LFxuXHRcdFx0MTk4LFxuXHRcdFx0MTk5LFxuXHRcdFx0MjAwLFxuXHRcdFx0MjAxLFxuXHRcdFx0MjAyLFxuXHRcdFx0MjAzLFxuXHRcdFx0MjA0LFxuXHRcdFx0MjA1LFxuXHRcdFx0MjA2LFxuXHRcdFx0MjA3LFxuXHRcdFx0MjA4LFxuXHRcdFx0MjA5LFxuXHRcdFx0MjE0LFxuXHRcdFx0MjE1LFxuXHRcdFx0MjIwLFxuXHRcdFx0MjIxXG5cdFx0XTtcblx0fVxufSBjYXRjaCAoZXJyb3IpIHtcblx0Ly8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxufVxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihrZXkgPT4ge1xuXHRyZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG5cdC8vIENhbWVsLWNhc2Vcblx0Y29uc3QgcHJvcCA9IGtleVxuXHRcdC5zdWJzdHJpbmcoNilcblx0XHQudG9Mb3dlckNhc2UoKVxuXHRcdC5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgaykgPT4ge1xuXHRcdFx0cmV0dXJuIGsudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblxuXHQvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcblx0bGV0IHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG5cdGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSB0cnVlO1xuXHR9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gZmFsc2U7XG5cdH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcblx0XHR2YWwgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IE51bWJlcih2YWwpO1xuXHR9XG5cblx0b2JqW3Byb3BdID0gdmFsO1xuXHRyZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzID9cblx0XHRCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKSA6XG5cdFx0dHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGNvbnN0IHtuYW1lc3BhY2U6IG5hbWUsIHVzZUNvbG9yc30gPSB0aGlzO1xuXG5cdGlmICh1c2VDb2xvcnMpIHtcblx0XHRjb25zdCBjID0gdGhpcy5jb2xvcjtcblx0XHRjb25zdCBjb2xvckNvZGUgPSAnXFx1MDAxQlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcblx0XHRjb25zdCBwcmVmaXggPSBgICAke2NvbG9yQ29kZX07MW0ke25hbWV9IFxcdTAwMUJbMG1gO1xuXG5cdFx0YXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuXHRcdGFyZ3MucHVzaChjb2xvckNvZGUgKyAnbSsnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFCWzBtJyk7XG5cdH0gZWxzZSB7XG5cdFx0YXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG5cdGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXRXaXRoT3B0aW9ucygpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdHJldHVybiBwcm9jZXNzLnN0ZGVyci53cml0ZSh1dGlsLmZvcm1hdFdpdGhPcHRpb25zKGV4cG9ydHMuaW5zcGVjdE9wdHMsIC4uLmFyZ3MpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0cHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuXHRcdC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG5cdFx0ZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcblx0cmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcblx0ZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG5cdFx0LnNwbGl0KCdcXG4nKVxuXHRcdC5tYXAoc3RyID0+IHN0ci50cmltKCkpXG5cdFx0LmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVPIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcbiJdLCJuYW1lcyI6WyJ0dHkiLCJyZXF1aXJlIiwidXRpbCIsImV4cG9ydHMiLCJpbml0IiwibG9nIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwiZGVzdHJveSIsImRlcHJlY2F0ZSIsImNvbG9ycyIsInN1cHBvcnRzQ29sb3IiLCJzdGRlcnIiLCJsZXZlbCIsImVycm9yIiwiaW5zcGVjdE9wdHMiLCJPYmplY3QiLCJrZXlzIiwicHJvY2VzcyIsImVudiIsImZpbHRlciIsImtleSIsInRlc3QiLCJyZWR1Y2UiLCJvYmoiLCJwcm9wIiwic3Vic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwiXyIsImsiLCJ0b1VwcGVyQ2FzZSIsInZhbCIsIk51bWJlciIsIkJvb2xlYW4iLCJpc2F0dHkiLCJmZCIsImFyZ3MiLCJuYW1lc3BhY2UiLCJuYW1lIiwiYyIsImNvbG9yIiwiY29sb3JDb2RlIiwicHJlZml4Iiwic3BsaXQiLCJqb2luIiwicHVzaCIsIm1vZHVsZSIsImh1bWFuaXplIiwiZGlmZiIsImdldERhdGUiLCJoaWRlRGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIndyaXRlIiwiZm9ybWF0V2l0aE9wdGlvbnMiLCJuYW1lc3BhY2VzIiwiREVCVUciLCJkZWJ1ZyIsImkiLCJsZW5ndGgiLCJmb3JtYXR0ZXJzIiwibyIsInYiLCJpbnNwZWN0IiwibWFwIiwic3RyIiwidHJpbSIsIk8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/broadcast-operator.js":
/*!***********************************************************!*\
  !*** ./node_modules/socket.io/dist/broadcast-operator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\nconst socket_types_1 = __webpack_require__(/*! ./socket-types */ \"(rsc)/./node_modules/socket.io/dist/socket-types.js\");\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nclass BroadcastOperator {\n    constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}){\n        this.adapter = adapter;\n        this.rooms = rooms;\n        this.exceptRooms = exceptRooms;\n        this.flags = flags;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        const rooms = new Set(this.rooms);\n        if (Array.isArray(room)) {\n            room.forEach((r)=>rooms.add(r));\n        } else {\n            rooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        const exceptRooms = new Set(this.exceptRooms);\n        if (Array.isArray(room)) {\n            room.forEach((r)=>exceptRooms.add(r));\n        } else {\n            exceptRooms.add(room);\n        }\n        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     */ compress(compress) {\n        const flags = Object.assign({}, this.flags, {\n            compress\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new BroadcastOperator instance\n     */ get volatile() {\n        const flags = Object.assign({}, this.flags, {\n            volatile: true\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        const flags = Object.assign({}, this.flags, {\n            local: true\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        const flags = Object.assign({}, this.flags, {\n            timeout\n        });\n        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients\n     * io.emit(\"foo\", \"bar\");\n     *\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an acknowledgement expected from all connected clients\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */ emit(ev, ...args) {\n        if (socket_types_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        // set up packet object\n        const data = [\n            ev,\n            ...args\n        ];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data\n        };\n        const withAck = typeof data[data.length - 1] === \"function\";\n        if (!withAck) {\n            this.adapter.broadcast(packet, {\n                rooms: this.rooms,\n                except: this.exceptRooms,\n                flags: this.flags\n            });\n            return true;\n        }\n        const ack = data.pop();\n        let timedOut = false;\n        let responses = [];\n        const timer = setTimeout(()=>{\n            timedOut = true;\n            ack.apply(this, [\n                new Error(\"operation has timed out\"),\n                this.flags.expectSingleResponse ? null : responses\n            ]);\n        }, this.flags.timeout);\n        let expectedServerCount = -1;\n        let actualServerCount = 0;\n        let expectedClientCount = 0;\n        const checkCompleteness = ()=>{\n            if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {\n                clearTimeout(timer);\n                ack.apply(this, [\n                    null,\n                    this.flags.expectSingleResponse ? responses[0] : responses\n                ]);\n            }\n        };\n        this.adapter.broadcastWithAck(packet, {\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, (clientCount)=>{\n            // each Socket.IO server in the cluster sends the number of clients that were notified\n            expectedClientCount += clientCount;\n            actualServerCount++;\n            checkCompleteness();\n        }, (clientResponse)=>{\n            // each client sends an acknowledgement\n            responses.push(clientResponse);\n            checkCompleteness();\n        });\n        this.adapter.serverCount().then((serverCount)=>{\n            expectedServerCount = serverCount;\n            checkCompleteness();\n        });\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement from all clients.\n     *\n     * @example\n     * try {\n     *   const responses = await io.timeout(1000).emitWithAck(\"some-event\");\n     *   console.log(responses); // one response per client\n     * } catch (e) {\n     *   // some clients did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when all clients have acknowledged the event\n     */ emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject)=>{\n            args.push((err, responses)=>{\n                if (err) {\n                    err.responses = responses;\n                    return reject(err);\n                } else {\n                    return resolve(responses);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link fetchSockets} instead.\n     */ allSockets() {\n        if (!this.adapter) {\n            throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n        }\n        return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */ fetchSockets() {\n        return this.adapter.fetchSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }).then((sockets)=>{\n            return sockets.map((socket)=>{\n                if (socket.server) {\n                    return socket; // local instance\n                } else {\n                    return new RemoteSocket(this.adapter, socket);\n                }\n            });\n        });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsJoin(room) {\n        this.adapter.addSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, Array.isArray(room) ? room : [\n            room\n        ]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsLeave(room) {\n        this.adapter.delSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, Array.isArray(room) ? room : [\n            room\n        ]);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(close = false) {\n        this.adapter.disconnectSockets({\n            rooms: this.rooms,\n            except: this.exceptRooms,\n            flags: this.flags\n        }, close);\n    }\n}\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */ class RemoteSocket {\n    constructor(adapter, details){\n        this.id = details.id;\n        this.handshake = details.handshake;\n        this.rooms = new Set(details.rooms);\n        this.data = details.data;\n        this.operator = new BroadcastOperator(adapter, new Set([\n            this.id\n        ]), new Set(), {\n            expectSingleResponse: true\n        });\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * const sockets = await io.fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   if (someCondition) {\n     *     socket.timeout(1000).emit(\"some-event\", (err) => {\n     *       if (err) {\n     *         // the client did not acknowledge the event in the given delay\n     *       }\n     *     });\n     *   }\n     * }\n     *\n     * // note: if possible, using a room instead of looping over all sockets is preferable\n     * io.timeout(1000).to(someConditionRoom).emit(\"some-event\", (err, responses) => {\n     *   // ...\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        return this.operator.timeout(timeout);\n    }\n    emit(ev, ...args) {\n        return this.operator.emit(ev, ...args);\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     */ join(room) {\n        return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     */ leave(room) {\n        return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     */ disconnect(close = false) {\n        this.operator.disconnectSockets(close);\n        return this;\n    }\n}\nexports.RemoteSocket = RemoteSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvYnJvYWRjYXN0LW9wZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUN4RCxNQUFNSSxpQkFBaUJDLG1CQUFPQSxDQUFDLDJFQUFnQjtBQUMvQyxNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDLGtGQUFrQjtBQUNyRCxNQUFNRjtJQUNGSSxZQUFZQyxPQUFPLEVBQUVDLFFBQVEsSUFBSUMsS0FBSyxFQUFFQyxjQUFjLElBQUlELEtBQUssRUFBRUUsUUFBUSxDQUFDLENBQUMsQ0FBRTtRQUN6RSxJQUFJLENBQUNKLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNFLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0RDLEdBQUdDLElBQUksRUFBRTtRQUNMLE1BQU1MLFFBQVEsSUFBSUMsSUFBSSxJQUFJLENBQUNELEtBQUs7UUFDaEMsSUFBSU0sTUFBTUMsT0FBTyxDQUFDRixPQUFPO1lBQ3JCQSxLQUFLRyxPQUFPLENBQUMsQ0FBQ0MsSUFBTVQsTUFBTVUsR0FBRyxDQUFDRDtRQUNsQyxPQUNLO1lBQ0RULE1BQU1VLEdBQUcsQ0FBQ0w7UUFDZDtRQUNBLE9BQU8sSUFBSVgsa0JBQWtCLElBQUksQ0FBQ0ssT0FBTyxFQUFFQyxPQUFPLElBQUksQ0FBQ0UsV0FBVyxFQUFFLElBQUksQ0FBQ0MsS0FBSztJQUNsRjtJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNEUSxHQUFHTixJQUFJLEVBQUU7UUFDTCxPQUFPLElBQUksQ0FBQ0QsRUFBRSxDQUFDQztJQUNuQjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7S0FlQyxHQUNETyxPQUFPUCxJQUFJLEVBQUU7UUFD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UUFDZCxPQUFPLElBQUksQ0FBQ29ELFFBQVEsQ0FBQ3RELElBQUksQ0FBQ0MsT0FBT0M7SUFDckM7SUFDQTs7OztLQUlDLEdBQ0RxRCxLQUFLcEUsSUFBSSxFQUFFO1FBQ1AsT0FBTyxJQUFJLENBQUNtRSxRQUFRLENBQUNULFdBQVcsQ0FBQzFEO0lBQ3JDO0lBQ0E7Ozs7S0FJQyxHQUNEcUUsTUFBTXJFLElBQUksRUFBRTtRQUNSLE9BQU8sSUFBSSxDQUFDbUUsUUFBUSxDQUFDUCxZQUFZLENBQUM1RDtJQUN0QztJQUNBOzs7OztLQUtDLEdBQ0RzRSxXQUFXUCxRQUFRLEtBQUssRUFBRTtRQUN0QixJQUFJLENBQUNJLFFBQVEsQ0FBQ0wsaUJBQWlCLENBQUNDO1FBQ2hDLE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFDQTdFLG9CQUFvQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL21lZGNvZGVzX2FwcC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9icm9hZGNhc3Qtb3BlcmF0b3IuanM/YmE5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVtb3RlU29ja2V0ID0gZXhwb3J0cy5Ccm9hZGNhc3RPcGVyYXRvciA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF90eXBlc18xID0gcmVxdWlyZShcIi4vc29ja2V0LXR5cGVzXCIpO1xuY29uc3Qgc29ja2V0X2lvX3BhcnNlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIik7XG5jbGFzcyBCcm9hZGNhc3RPcGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoYWRhcHRlciwgcm9vbXMgPSBuZXcgU2V0KCksIGV4Y2VwdFJvb21zID0gbmV3IFNldCgpLCBmbGFncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgICAgIHRoaXMucm9vbXMgPSByb29tcztcbiAgICAgICAgdGhpcy5leGNlcHRSb29tcyA9IGV4Y2VwdFJvb21zO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIGluIHRoZSDigJxyb29tLTEwMeKAnSByb29tXG4gICAgICogaW8udG8oXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhcnJheSBvZiByb29tcyAoYSBjbGllbnQgd2lsbCBiZSBub3RpZmllZCBhdCBtb3N0IG9uY2UpXG4gICAgICogaW8udG8oW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggbXVsdGlwbGUgY2hhaW5lZCBjYWxsc1xuICAgICAqIGlvLnRvKFwicm9vbS0xMDFcIikudG8oXCJyb29tLTEwMlwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIHRvKHJvb20pIHtcbiAgICAgICAgY29uc3Qgcm9vbXMgPSBuZXcgU2V0KHRoaXMucm9vbXMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyb29tKSkge1xuICAgICAgICAgICAgcm9vbS5mb3JFYWNoKChyKSA9PiByb29tcy5hZGQocikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm9vbXMuYWRkKHJvb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCByb29tcywgdGhpcy5leGNlcHRSb29tcywgdGhpcy5mbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuIFNpbWlsYXIgdG8gYHRvKClgLCBidXQgbWlnaHQgZmVlbCBjbGVhcmVyIGluIHNvbWUgY2FzZXM6XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGRpc2Nvbm5lY3QgYWxsIGNsaWVudHMgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tXG4gICAgICogaW8uaW4oXCJyb29tLTEwMVwiKS5kaXNjb25uZWN0U29ja2V0cygpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGVzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUgXCJmb29cIiBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMsIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGFyZSBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiBpby5leGNlcHQoXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIGlvLmV4Y2VwdChbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogaW8uZXhjZXB0KFwicm9vbS0xMDFcIikuZXhjZXB0KFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBleGNlcHQocm9vbSkge1xuICAgICAgICBjb25zdCBleGNlcHRSb29tcyA9IG5ldyBTZXQodGhpcy5leGNlcHRSb29tcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvb20pKSB7XG4gICAgICAgICAgICByb29tLmZvckVhY2goKHIpID0+IGV4Y2VwdFJvb21zLmFkZChyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGNlcHRSb29tcy5hZGQocm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHRoaXMucm9vbXMsIGV4Y2VwdFJvb21zLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8uY29tcHJlc3MoZmFsc2UpLmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wcmVzcyAtIGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gICAgICogQHJldHVybiBhIG5ldyBCcm9hZGNhc3RPcGVyYXRvciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXByZXNzKGNvbXByZXNzKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncywgeyBjb21wcmVzcyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHRoaXMucm9vbXMsIHRoaXMuZXhjZXB0Um9vbXMsIGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSBtYXkgYmUgbG9zdCBpZiB0aGUgY2xpZW50IGlzIG5vdCByZWFkeSB0b1xuICAgICAqIHJlY2VpdmUgbWVzc2FnZXMgKGJlY2F1c2Ugb2YgbmV0d29yayBzbG93bmVzcyBvciBvdGhlciBpc3N1ZXMsIG9yIGJlY2F1c2UgdGhleeKAmXJlIGNvbm5lY3RlZCB0aHJvdWdoIGxvbmcgcG9sbGluZ1xuICAgICAqIGFuZCBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgcmVxdWVzdC1yZXNwb25zZSBjeWNsZSkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLnZvbGF0aWxlLmVtaXQoXCJoZWxsb1wiKTsgLy8gdGhlIGNsaWVudHMgbWF5IG9yIG1heSBub3QgcmVjZWl2ZSBpdFxuICAgICAqXG4gICAgICogQHJldHVybiBhIG5ldyBCcm9hZGNhc3RPcGVyYXRvciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldCB2b2xhdGlsZSgpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzLCB7IHZvbGF0aWxlOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgdGhpcy5leGNlcHRSb29tcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIHdpbGwgb25seSBiZSBicm9hZGNhc3QgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgb24gdGhpcyBub2RlXG4gICAgICogaW8ubG9jYWwuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBnZXQgbG9jYWwoKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncywgeyBsb2NhbDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHRoaXMucm9vbXMsIHRoaXMuZXhjZXB0Um9vbXMsIGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgbmV4dCBvcGVyYXRpb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8udGltZW91dCgxMDAwKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBjbGllbnRzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBjbGllbnRcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0XG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncywgeyB0aW1lb3V0IH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgdGhpcy5leGNlcHRSb29tcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyB0byBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHNcbiAgICAgKiBpby5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgaW4gdGhlIOKAnHJvb20tMTAx4oCdIHJvb21cbiAgICAgKiBpby50byhcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFja25vd2xlZGdlbWVudCBleHBlY3RlZCBmcm9tIGFsbCBjb25uZWN0ZWQgY2xpZW50c1xuICAgICAqIGlvLnRpbWVvdXQoMTAwMCkuZW1pdChcInNvbWUtZXZlbnRcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgY2xpZW50cyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgY2xpZW50XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyB0cnVlXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoc29ja2V0X3R5cGVzXzEuUkVTRVJWRURfRVZFTlRTLmhhcyhldikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke1N0cmluZyhldil9XCIgaXMgYSByZXNlcnZlZCBldmVudCBuYW1lYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHVwIHBhY2tldCBvYmplY3RcbiAgICAgICAgY29uc3QgZGF0YSA9IFtldiwgLi4uYXJnc107XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5ULFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgd2l0aEFjayA9IHR5cGVvZiBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgaWYgKCF3aXRoQWNrKSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuYnJvYWRjYXN0KHBhY2tldCwge1xuICAgICAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgICAgICBmbGFnczogdGhpcy5mbGFncyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNrID0gZGF0YS5wb3AoKTtcbiAgICAgICAgbGV0IHRpbWVkT3V0ID0gZmFsc2U7XG4gICAgICAgIGxldCByZXNwb25zZXMgPSBbXTtcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGFjay5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKFwib3BlcmF0aW9uIGhhcyB0aW1lZCBvdXRcIiksXG4gICAgICAgICAgICAgICAgdGhpcy5mbGFncy5leHBlY3RTaW5nbGVSZXNwb25zZSA/IG51bGwgOiByZXNwb25zZXMsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSwgdGhpcy5mbGFncy50aW1lb3V0KTtcbiAgICAgICAgbGV0IGV4cGVjdGVkU2VydmVyQ291bnQgPSAtMTtcbiAgICAgICAgbGV0IGFjdHVhbFNlcnZlckNvdW50ID0gMDtcbiAgICAgICAgbGV0IGV4cGVjdGVkQ2xpZW50Q291bnQgPSAwO1xuICAgICAgICBjb25zdCBjaGVja0NvbXBsZXRlbmVzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGltZWRPdXQgJiZcbiAgICAgICAgICAgICAgICBleHBlY3RlZFNlcnZlckNvdW50ID09PSBhY3R1YWxTZXJ2ZXJDb3VudCAmJlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlcy5sZW5ndGggPT09IGV4cGVjdGVkQ2xpZW50Q291bnQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIGFjay5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhZ3MuZXhwZWN0U2luZ2xlUmVzcG9uc2UgPyByZXNwb25zZXNbMF0gOiByZXNwb25zZXMsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRhcHRlci5icm9hZGNhc3RXaXRoQWNrKHBhY2tldCwge1xuICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgICAgICBmbGFnczogdGhpcy5mbGFncyxcbiAgICAgICAgfSwgKGNsaWVudENvdW50KSA9PiB7XG4gICAgICAgICAgICAvLyBlYWNoIFNvY2tldC5JTyBzZXJ2ZXIgaW4gdGhlIGNsdXN0ZXIgc2VuZHMgdGhlIG51bWJlciBvZiBjbGllbnRzIHRoYXQgd2VyZSBub3RpZmllZFxuICAgICAgICAgICAgZXhwZWN0ZWRDbGllbnRDb3VudCArPSBjbGllbnRDb3VudDtcbiAgICAgICAgICAgIGFjdHVhbFNlcnZlckNvdW50Kys7XG4gICAgICAgICAgICBjaGVja0NvbXBsZXRlbmVzcygpO1xuICAgICAgICB9LCAoY2xpZW50UmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIC8vIGVhY2ggY2xpZW50IHNlbmRzIGFuIGFja25vd2xlZGdlbWVudFxuICAgICAgICAgICAgcmVzcG9uc2VzLnB1c2goY2xpZW50UmVzcG9uc2UpO1xuICAgICAgICAgICAgY2hlY2tDb21wbGV0ZW5lc3MoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRhcHRlci5zZXJ2ZXJDb3VudCgpLnRoZW4oKHNlcnZlckNvdW50KSA9PiB7XG4gICAgICAgICAgICBleHBlY3RlZFNlcnZlckNvdW50ID0gc2VydmVyQ291bnQ7XG4gICAgICAgICAgICBjaGVja0NvbXBsZXRlbmVzcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFuZCB3YWl0cyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gYWxsIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHRyeSB7XG4gICAgICogICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBpby50aW1lb3V0KDEwMDApLmVtaXRXaXRoQWNrKFwic29tZS1ldmVudFwiKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgY2xpZW50XG4gICAgICogfSBjYXRjaCAoZSkge1xuICAgICAqICAgLy8gc29tZSBjbGllbnRzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiBhbGwgY2xpZW50cyBoYXZlIGFja25vd2xlZGdlZCB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBlbWl0V2l0aEFjayhldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYXJncy5wdXNoKChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnJlc3BvbnNlcyA9IHJlc3BvbnNlcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UsIHBsZWFzZSB1c2Uge0BsaW5rIFNlcnZlciNzZXJ2ZXJTaWRlRW1pdH0gb3JcbiAgICAgKiB7QGxpbmsgZmV0Y2hTb2NrZXRzfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFsbFNvY2tldHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5hZGFwdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhZGFwdGVyIGZvciB0aGlzIG5hbWVzcGFjZSwgYXJlIHlvdSB0cnlpbmcgdG8gZ2V0IHRoZSBsaXN0IG9mIGNsaWVudHMgb2YgYSBkeW5hbWljIG5hbWVzcGFjZT9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5zb2NrZXRzKHRoaXMucm9vbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzLiBUaGlzIG1ldGhvZCB3b3JrcyBhY3Jvc3MgYSBjbHVzdGVyIG9mIHNldmVyYWwgU29ja2V0LklPIHNlcnZlcnMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcmV0dXJuIGFsbCBTb2NrZXQgaW5zdGFuY2VzXG4gICAgICogY29uc3Qgc29ja2V0cyA9IGF3YWl0IGlvLmZldGNoU29ja2V0cygpO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJuIGFsbCBTb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBpby5pbihcInJvb20xXCIpLmZldGNoU29ja2V0cygpO1xuICAgICAqXG4gICAgICogZm9yIChjb25zdCBzb2NrZXQgb2Ygc29ja2V0cykge1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmlkKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5oYW5kc2hha2UpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LnJvb21zKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5kYXRhKTtcbiAgICAgKlxuICAgICAqICAgc29ja2V0LmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gICAgICogICBzb2NrZXQubGVhdmUoXCJyb29tMlwiKTtcbiAgICAgKiAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICogfVxuICAgICAqL1xuICAgIGZldGNoU29ja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlclxuICAgICAgICAgICAgLmZldGNoU29ja2V0cyh7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHNvY2tldHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzb2NrZXRzLm1hcCgoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNvY2tldC5zZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldDsgLy8gbG9jYWwgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVtb3RlU29ja2V0KHRoaXMuYWRhcHRlciwgc29ja2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIHNwZWNpZmllZCByb29tcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBpby5zb2NrZXRzSm9pbihcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gam9pbiB0aGUgXCJyb29tMlwiIGFuZCBcInJvb20zXCIgcm9vbXNcbiAgICAgKiBpby5pbihcInJvb20xXCIpLnNvY2tldHNKb2luKFtcInJvb20yXCIsIFwicm9vbTNcIl0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICovXG4gICAgc29ja2V0c0pvaW4ocm9vbSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIuYWRkU29ja2V0cyh7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICB9LCBBcnJheS5pc0FycmF5KHJvb20pID8gcm9vbSA6IFtyb29tXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBzcGVjaWZpZWQgcm9vbXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBpby5zb2NrZXRzTGVhdmUoXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGxlYXZlIHRoZSBcInJvb20yXCIgYW5kIFwicm9vbTNcIiByb29tc1xuICAgICAqIGlvLmluKFwicm9vbTFcIikuc29ja2V0c0xlYXZlKFtcInJvb20yXCIsIFwicm9vbTNcIl0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb20gLSBhIHJvb20sIG9yIGFuIGFycmF5IG9mIHJvb21zXG4gICAgICovXG4gICAgc29ja2V0c0xlYXZlKHJvb20pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmRlbFNvY2tldHMoe1xuICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgICAgICBmbGFnczogdGhpcy5mbGFncyxcbiAgICAgICAgfSwgQXJyYXkuaXNBcnJheShyb29tKSA/IHJvb20gOiBbcm9vbV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0LlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdCAodGhlIGNvbm5lY3Rpb25zIG1pZ2h0IGJlIGtlcHQgYWxpdmUgZm9yIG90aGVyIG5hbWVzcGFjZXMpXG4gICAgICogaW8uZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGRpc2Nvbm5lY3QgYW5kIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25zXG4gICAgICogaW8uaW4oXCJyb29tMVwiKS5kaXNjb25uZWN0U29ja2V0cyh0cnVlKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmRpc2Nvbm5lY3RTb2NrZXRzKHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICAgICAgZmxhZ3M6IHRoaXMuZmxhZ3MsXG4gICAgICAgIH0sIGNsb3NlKTtcbiAgICB9XG59XG5leHBvcnRzLkJyb2FkY2FzdE9wZXJhdG9yID0gQnJvYWRjYXN0T3BlcmF0b3I7XG4vKipcbiAqIEV4cG9zZSBvZiBzdWJzZXQgb2YgdGhlIGF0dHJpYnV0ZXMgYW5kIG1ldGhvZHMgb2YgdGhlIFNvY2tldCBjbGFzc1xuICovXG5jbGFzcyBSZW1vdGVTb2NrZXQge1xuICAgIGNvbnN0cnVjdG9yKGFkYXB0ZXIsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGRldGFpbHMuaWQ7XG4gICAgICAgIHRoaXMuaGFuZHNoYWtlID0gZGV0YWlscy5oYW5kc2hha2U7XG4gICAgICAgIHRoaXMucm9vbXMgPSBuZXcgU2V0KGRldGFpbHMucm9vbXMpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkZXRhaWxzLmRhdGE7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBuZXcgQnJvYWRjYXN0T3BlcmF0b3IoYWRhcHRlciwgbmV3IFNldChbdGhpcy5pZF0pLCBuZXcgU2V0KCksIHtcbiAgICAgICAgICAgIGV4cGVjdFNpbmdsZVJlc3BvbnNlOiB0cnVlLCAvLyBzbyB0aGF0IHJlbW90ZVNvY2tldC5lbWl0KCkgd2l0aCBhY2tub3dsZWRnZW1lbnQgYmVoYXZlcyBsaWtlIHNvY2tldC5lbWl0KClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIG5leHQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgaW8uZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiBmb3IgKGNvbnN0IHNvY2tldCBvZiBzb2NrZXRzKSB7XG4gICAgICogICBpZiAoc29tZUNvbmRpdGlvbikge1xuICAgICAqICAgICBzb2NrZXQudGltZW91dCgxMDAwKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyKSA9PiB7XG4gICAgICogICAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgICAgLy8gdGhlIGNsaWVudCBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH0pO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIG5vdGU6IGlmIHBvc3NpYmxlLCB1c2luZyBhIHJvb20gaW5zdGVhZCBvZiBsb29waW5nIG92ZXIgYWxsIHNvY2tldHMgaXMgcHJlZmVyYWJsZVxuICAgICAqIGlvLnRpbWVvdXQoMTAwMCkudG8oc29tZUNvbmRpdGlvblJvb20pLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICAgLy8gLi4uXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dFxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvci50aW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKb2lucyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcm9vbSAtIHJvb20gb3IgYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBqb2luKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3Iuc29ja2V0c0pvaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm9vbVxuICAgICAqL1xuICAgIGxlYXZlKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3Iuc29ja2V0c0xlYXZlKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGlzIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvc2UgLSBpZiBgdHJ1ZWAsIGNsb3NlcyB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjbG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IuZGlzY29ubmVjdFNvY2tldHMoY2xvc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlJlbW90ZVNvY2tldCA9IFJlbW90ZVNvY2tldDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJlbW90ZVNvY2tldCIsIkJyb2FkY2FzdE9wZXJhdG9yIiwic29ja2V0X3R5cGVzXzEiLCJyZXF1aXJlIiwic29ja2V0X2lvX3BhcnNlcl8xIiwiY29uc3RydWN0b3IiLCJhZGFwdGVyIiwicm9vbXMiLCJTZXQiLCJleGNlcHRSb29tcyIsImZsYWdzIiwidG8iLCJyb29tIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsInIiLCJhZGQiLCJpbiIsImV4Y2VwdCIsImNvbXByZXNzIiwiYXNzaWduIiwidm9sYXRpbGUiLCJsb2NhbCIsInRpbWVvdXQiLCJlbWl0IiwiZXYiLCJhcmdzIiwiUkVTRVJWRURfRVZFTlRTIiwiaGFzIiwiRXJyb3IiLCJTdHJpbmciLCJkYXRhIiwicGFja2V0IiwidHlwZSIsIlBhY2tldFR5cGUiLCJFVkVOVCIsIndpdGhBY2siLCJsZW5ndGgiLCJicm9hZGNhc3QiLCJhY2siLCJwb3AiLCJ0aW1lZE91dCIsInJlc3BvbnNlcyIsInRpbWVyIiwic2V0VGltZW91dCIsImFwcGx5IiwiZXhwZWN0U2luZ2xlUmVzcG9uc2UiLCJleHBlY3RlZFNlcnZlckNvdW50IiwiYWN0dWFsU2VydmVyQ291bnQiLCJleHBlY3RlZENsaWVudENvdW50IiwiY2hlY2tDb21wbGV0ZW5lc3MiLCJjbGVhclRpbWVvdXQiLCJicm9hZGNhc3RXaXRoQWNrIiwiY2xpZW50Q291bnQiLCJjbGllbnRSZXNwb25zZSIsInB1c2giLCJzZXJ2ZXJDb3VudCIsInRoZW4iLCJlbWl0V2l0aEFjayIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZXJyIiwiYWxsU29ja2V0cyIsInNvY2tldHMiLCJmZXRjaFNvY2tldHMiLCJtYXAiLCJzb2NrZXQiLCJzZXJ2ZXIiLCJzb2NrZXRzSm9pbiIsImFkZFNvY2tldHMiLCJzb2NrZXRzTGVhdmUiLCJkZWxTb2NrZXRzIiwiZGlzY29ubmVjdFNvY2tldHMiLCJjbG9zZSIsImRldGFpbHMiLCJpZCIsImhhbmRzaGFrZSIsIm9wZXJhdG9yIiwiam9pbiIsImxlYXZlIiwiZGlzY29ubmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Client = void 0;\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nconst debugModule = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst debug = debugModule(\"socket.io:client\");\nclass Client {\n    /**\n     * Client constructor.\n     *\n     * @param server instance\n     * @param conn\n     * @package\n     */ constructor(server, conn){\n        this.sockets = new Map();\n        this.nsps = new Map();\n        this.server = server;\n        this.conn = conn;\n        this.encoder = server.encoder;\n        this.decoder = new server._parser.Decoder();\n        this.id = conn.id;\n        this.setup();\n    }\n    /**\n     * @return the reference to the request that originated the Engine.IO connection\n     *\n     * @public\n     */ get request() {\n        return this.conn.request;\n    }\n    /**\n     * Sets up event listeners.\n     *\n     * @private\n     */ setup() {\n        this.onclose = this.onclose.bind(this);\n        this.ondata = this.ondata.bind(this);\n        this.onerror = this.onerror.bind(this);\n        this.ondecoded = this.ondecoded.bind(this);\n        // @ts-ignore\n        this.decoder.on(\"decoded\", this.ondecoded);\n        this.conn.on(\"data\", this.ondata);\n        this.conn.on(\"error\", this.onerror);\n        this.conn.on(\"close\", this.onclose);\n        this.connectTimeout = setTimeout(()=>{\n            if (this.nsps.size === 0) {\n                debug(\"no namespace joined yet, close the client\");\n                this.close();\n            } else {\n                debug(\"the client has already joined a namespace, nothing to do\");\n            }\n        }, this.server._connectTimeout);\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param {String} name - the namespace\n     * @param {Object} auth - the auth parameters\n     * @private\n     */ connect(name, auth = {}) {\n        if (this.server._nsps.has(name)) {\n            debug(\"connecting to namespace %s\", name);\n            return this.doConnect(name, auth);\n        }\n        this.server._checkNamespace(name, auth, (dynamicNspName)=>{\n            if (dynamicNspName) {\n                this.doConnect(name, auth);\n            } else {\n                debug(\"creation of namespace %s was denied\", name);\n                this._packet({\n                    type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n                    nsp: name,\n                    data: {\n                        message: \"Invalid namespace\"\n                    }\n                });\n            }\n        });\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param name - the namespace\n     * @param {Object} auth - the auth parameters\n     *\n     * @private\n     */ doConnect(name, auth) {\n        const nsp = this.server.of(name);\n        nsp._add(this, auth, (socket)=>{\n            this.sockets.set(socket.id, socket);\n            this.nsps.set(nsp.name, socket);\n            if (this.connectTimeout) {\n                clearTimeout(this.connectTimeout);\n                this.connectTimeout = undefined;\n            }\n        });\n    }\n    /**\n     * Disconnects from all namespaces and closes transport.\n     *\n     * @private\n     */ _disconnect() {\n        for (const socket of this.sockets.values()){\n            socket.disconnect();\n        }\n        this.sockets.clear();\n        this.close();\n    }\n    /**\n     * Removes a socket. Called by each `Socket`.\n     *\n     * @private\n     */ _remove(socket) {\n        if (this.sockets.has(socket.id)) {\n            const nsp = this.sockets.get(socket.id).nsp.name;\n            this.sockets.delete(socket.id);\n            this.nsps.delete(nsp);\n        } else {\n            debug(\"ignoring remove for %s\", socket.id);\n        }\n    }\n    /**\n     * Closes the underlying connection.\n     *\n     * @private\n     */ close() {\n        if (\"open\" === this.conn.readyState) {\n            debug(\"forcing transport close\");\n            this.conn.close();\n            this.onclose(\"forced server close\");\n        }\n    }\n    /**\n     * Writes a packet to the transport.\n     *\n     * @param {Object} packet object\n     * @param {Object} opts\n     * @private\n     */ _packet(packet, opts = {}) {\n        if (this.conn.readyState !== \"open\") {\n            debug(\"ignoring packet write %j\", packet);\n            return;\n        }\n        const encodedPackets = opts.preEncoded ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()\n         : this.encoder.encode(packet);\n        this.writeToEngine(encodedPackets, opts);\n    }\n    writeToEngine(encodedPackets, opts) {\n        if (opts.volatile && !this.conn.transport.writable) {\n            debug(\"volatile packet is discarded since the transport is not currently writable\");\n            return;\n        }\n        const packets = Array.isArray(encodedPackets) ? encodedPackets : [\n            encodedPackets\n        ];\n        for (const encodedPacket of packets){\n            this.conn.write(encodedPacket, opts);\n        }\n    }\n    /**\n     * Called with incoming transport data.\n     *\n     * @private\n     */ ondata(data) {\n        // try/catch is needed for protocol violations (GH-1880)\n        try {\n            this.decoder.add(data);\n        } catch (e) {\n            debug(\"invalid packet format\");\n            this.onerror(e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */ ondecoded(packet) {\n        let namespace;\n        let authPayload;\n        if (this.conn.protocol === 3) {\n            const parsed = url.parse(packet.nsp, true);\n            namespace = parsed.pathname;\n            authPayload = parsed.query;\n        } else {\n            namespace = packet.nsp;\n            authPayload = packet.data;\n        }\n        const socket = this.nsps.get(namespace);\n        if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {\n            this.connect(namespace, authPayload);\n        } else if (socket && packet.type !== socket_io_parser_1.PacketType.CONNECT && packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {\n            process.nextTick(function() {\n                socket._onpacket(packet);\n            });\n        } else {\n            debug(\"invalid state (packet type: %s)\", packet.type);\n            this.close();\n        }\n    }\n    /**\n     * Handles an error.\n     *\n     * @param {Object} err object\n     * @private\n     */ onerror(err) {\n        for (const socket of this.sockets.values()){\n            socket._onerror(err);\n        }\n        this.conn.close();\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */ onclose(reason, description) {\n        debug(\"client close with reason %s\", reason);\n        // ignore a potential subsequent `close` event\n        this.destroy();\n        // `nsps` and `sockets` are cleaned up seamlessly\n        for (const socket of this.sockets.values()){\n            socket._onclose(reason, description);\n        }\n        this.sockets.clear();\n        this.decoder.destroy(); // clean up decoder\n    }\n    /**\n     * Cleans up event listeners.\n     * @private\n     */ destroy() {\n        this.conn.removeListener(\"data\", this.ondata);\n        this.conn.removeListener(\"error\", this.onerror);\n        this.conn.removeListener(\"close\", this.onclose);\n        // @ts-ignore\n        this.decoder.removeListener(\"decoded\", this.ondecoded);\n        if (this.connectTimeout) {\n            clearTimeout(this.connectTimeout);\n            this.connectTimeout = undefined;\n        }\n    }\n}\nexports.Client = Client;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxxQkFBcUJDLG1CQUFPQSxDQUFDLGtGQUFrQjtBQUNyRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw2RUFBTztBQUNuQyxNQUFNRSxNQUFNRixtQkFBT0EsQ0FBQyxnQkFBSztBQUN6QixNQUFNRyxRQUFRRixZQUFZO0FBQzFCLE1BQU1IO0lBQ0Y7Ozs7OztLQU1DLEdBQ0RNLFlBQVlDLE1BQU0sRUFBRUMsSUFBSSxDQUFFO1FBQ3RCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlDO1FBQ25CLElBQUksQ0FBQ0MsSUFBSSxHQUFHLElBQUlEO1FBQ2hCLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0ksT0FBTyxHQUFHTCxPQUFPSyxPQUFPO1FBQzdCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlOLE9BQU9PLE9BQU8sQ0FBQ0MsT0FBTztRQUN6QyxJQUFJLENBQUNDLEVBQUUsR0FBR1IsS0FBS1EsRUFBRTtRQUNqQixJQUFJLENBQUNDLEtBQUs7SUFDZDtJQUNBOzs7O0tBSUMsR0FDRCxJQUFJQyxVQUFVO1FBQ1YsT0FBTyxJQUFJLENBQUNWLElBQUksQ0FBQ1UsT0FBTztJQUM1QjtJQUNBOzs7O0tBSUMsR0FDREQsUUFBUTtRQUNKLElBQUksQ0FBQ0UsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNyQyxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLElBQUk7UUFDbkMsSUFBSSxDQUFDRSxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUNGLElBQUksQ0FB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bkI7SUFDQTs7Ozs7O0tBTUMsR0FDRFQsUUFBUXFFLE1BQU0sRUFBRUMsV0FBVyxFQUFFO1FBQ3pCcEYsTUFBTSwrQkFBK0JtRjtRQUNyQyw4Q0FBOEM7UUFDOUMsSUFBSSxDQUFDRSxPQUFPO1FBQ1osaURBQWlEO1FBQ2pELEtBQUssTUFBTTNDLFVBQVUsSUFBSSxDQUFDdEMsT0FBTyxDQUFDMkMsTUFBTSxHQUFJO1lBQ3hDTCxPQUFPNEMsUUFBUSxDQUFDSCxRQUFRQztRQUM1QjtRQUNBLElBQUksQ0FBQ2hGLE9BQU8sQ0FBQzZDLEtBQUs7UUFDbEIsSUFBSSxDQUFDekMsT0FBTyxDQUFDNkUsT0FBTyxJQUFJLG1CQUFtQjtJQUMvQztJQUNBOzs7S0FHQyxHQUNEQSxVQUFVO1FBQ04sSUFBSSxDQUFDbEYsSUFBSSxDQUFDb0YsY0FBYyxDQUFDLFFBQVEsSUFBSSxDQUFDdkUsTUFBTTtRQUM1QyxJQUFJLENBQUNiLElBQUksQ0FBQ29GLGNBQWMsQ0FBQyxTQUFTLElBQUksQ0FBQ3RFLE9BQU87UUFDOUMsSUFBSSxDQUFDZCxJQUFJLENBQUNvRixjQUFjLENBQUMsU0FBUyxJQUFJLENBQUN6RSxPQUFPO1FBQzlDLGFBQWE7UUFDYixJQUFJLENBQUNOLE9BQU8sQ0FBQytFLGNBQWMsQ0FBQyxXQUFXLElBQUksQ0FBQ3JFLFNBQVM7UUFDckQsSUFBSSxJQUFJLENBQUNFLGNBQWMsRUFBRTtZQUNyQndCLGFBQWEsSUFBSSxDQUFDeEIsY0FBYztZQUNoQyxJQUFJLENBQUNBLGNBQWMsR0FBR3lCO1FBQzFCO0lBQ0o7QUFDSjtBQUNBcEQsY0FBYyxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL21lZGNvZGVzX2FwcC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9jbGllbnQuanM/NjE3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50ID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0X2lvX3BhcnNlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIik7XG5jb25zdCBkZWJ1Z01vZHVsZSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwic29ja2V0LmlvOmNsaWVudFwiKTtcbmNsYXNzIENsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ2xpZW50IGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlcnZlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBjb25uXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIsIGNvbm4pIHtcbiAgICAgICAgdGhpcy5zb2NrZXRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5zcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICB0aGlzLmNvbm4gPSBjb25uO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBzZXJ2ZXIuZW5jb2RlcjtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IHNlcnZlci5fcGFyc2VyLkRlY29kZXIoKTtcbiAgICAgICAgdGhpcy5pZCA9IGNvbm4uaWQ7XG4gICAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB0aGUgcmVmZXJlbmNlIHRvIHRoZSByZXF1ZXN0IHRoYXQgb3JpZ2luYXRlZCB0aGUgRW5naW5lLklPIGNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubi5yZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0dXAoKSB7XG4gICAgICAgIHRoaXMub25jbG9zZSA9IHRoaXMub25jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uZGF0YSA9IHRoaXMub25kYXRhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uZGVjb2RlZCA9IHRoaXMub25kZWNvZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5kZWNvZGVyLm9uKFwiZGVjb2RlZFwiLCB0aGlzLm9uZGVjb2RlZCk7XG4gICAgICAgIHRoaXMuY29ubi5vbihcImRhdGFcIiwgdGhpcy5vbmRhdGEpO1xuICAgICAgICB0aGlzLmNvbm4ub24oXCJlcnJvclwiLCB0aGlzLm9uZXJyb3IpO1xuICAgICAgICB0aGlzLmNvbm4ub24oXCJjbG9zZVwiLCB0aGlzLm9uY2xvc2UpO1xuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5uc3BzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIm5vIG5hbWVzcGFjZSBqb2luZWQgeWV0LCBjbG9zZSB0aGUgY2xpZW50XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwidGhlIGNsaWVudCBoYXMgYWxyZWFkeSBqb2luZWQgYSBuYW1lc3BhY2UsIG5vdGhpbmcgdG8gZG9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuc2VydmVyLl9jb25uZWN0VGltZW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIGEgY2xpZW50IHRvIGEgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0aGUgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF1dGggLSB0aGUgYXV0aCBwYXJhbWV0ZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25uZWN0KG5hbWUsIGF1dGggPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZXIuX25zcHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3RpbmcgdG8gbmFtZXNwYWNlICVzXCIsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9Db25uZWN0KG5hbWUsIGF1dGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VydmVyLl9jaGVja05hbWVzcGFjZShuYW1lLCBhdXRoLCAoZHluYW1pY05zcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChkeW5hbWljTnNwTmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9Db25uZWN0KG5hbWUsIGF1dGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjcmVhdGlvbiBvZiBuYW1lc3BhY2UgJXMgd2FzIGRlbmllZFwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWNrZXQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICBuc3A6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBuYW1lc3BhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIGEgY2xpZW50IHRvIGEgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF1dGggLSB0aGUgYXV0aCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRvQ29ubmVjdChuYW1lLCBhdXRoKSB7XG4gICAgICAgIGNvbnN0IG5zcCA9IHRoaXMuc2VydmVyLm9mKG5hbWUpO1xuICAgICAgICBuc3AuX2FkZCh0aGlzLCBhdXRoLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldHMuc2V0KHNvY2tldC5pZCwgc29ja2V0KTtcbiAgICAgICAgICAgIHRoaXMubnNwcy5zZXQobnNwLm5hbWUsIHNvY2tldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgZnJvbSBhbGwgbmFtZXNwYWNlcyBhbmQgY2xvc2VzIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Rpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvY2tldHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc29ja2V0LiBDYWxsZWQgYnkgZWFjaCBgU29ja2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZShzb2NrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0cy5oYXMoc29ja2V0LmlkKSkge1xuICAgICAgICAgICAgY29uc3QgbnNwID0gdGhpcy5zb2NrZXRzLmdldChzb2NrZXQuaWQpLm5zcC5uYW1lO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXRzLmRlbGV0ZShzb2NrZXQuaWQpO1xuICAgICAgICAgICAgdGhpcy5uc3BzLmRlbGV0ZShuc3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJpZ25vcmluZyByZW1vdmUgZm9yICVzXCIsIHNvY2tldC5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAoXCJvcGVuXCIgPT09IHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImZvcmNpbmcgdHJhbnNwb3J0IGNsb3NlXCIpO1xuICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLm9uY2xvc2UoXCJmb3JjZWQgc2VydmVyIGNsb3NlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldCB0byB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhY2tldChwYWNrZXQsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5jb25uLnJlYWR5U3RhdGUgIT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImlnbm9yaW5nIHBhY2tldCB3cml0ZSAlalwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gb3B0cy5wcmVFbmNvZGVkXG4gICAgICAgICAgICA/IHBhY2tldCAvLyBwcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGUgYWRhcHRlciBpbmNvcnJlY3RseSB1c2VkIHNvY2tldC5wYWNrZXQoKSBpbnN0ZWFkIG9mIHdyaXRlVG9FbmdpbmUoKVxuICAgICAgICAgICAgOiB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCk7XG4gICAgICAgIHRoaXMud3JpdGVUb0VuZ2luZShlbmNvZGVkUGFja2V0cywgb3B0cyk7XG4gICAgfVxuICAgIHdyaXRlVG9FbmdpbmUoZW5jb2RlZFBhY2tldHMsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMudm9sYXRpbGUgJiYgIXRoaXMuY29ubi50cmFuc3BvcnQud3JpdGFibGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidm9sYXRpbGUgcGFja2V0IGlzIGRpc2NhcmRlZCBzaW5jZSB0aGUgdHJhbnNwb3J0IGlzIG5vdCBjdXJyZW50bHkgd3JpdGFibGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2V0cyA9IEFycmF5LmlzQXJyYXkoZW5jb2RlZFBhY2tldHMpXG4gICAgICAgICAgICA/IGVuY29kZWRQYWNrZXRzXG4gICAgICAgICAgICA6IFtlbmNvZGVkUGFja2V0c107XG4gICAgICAgIGZvciAoY29uc3QgZW5jb2RlZFBhY2tldCBvZiBwYWNrZXRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm4ud3JpdGUoZW5jb2RlZFBhY2tldCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggaW5jb21pbmcgdHJhbnNwb3J0IGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZGF0YShkYXRhKSB7XG4gICAgICAgIC8vIHRyeS9jYXRjaCBpcyBuZWVkZWQgZm9yIHByb3RvY29sIHZpb2xhdGlvbnMgKEdILTE4ODApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImludmFsaWQgcGFja2V0IGZvcm1hdFwiKTtcbiAgICAgICAgICAgIHRoaXMub25lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kZWNvZGVkKHBhY2tldCkge1xuICAgICAgICBsZXQgbmFtZXNwYWNlO1xuICAgICAgICBsZXQgYXV0aFBheWxvYWQ7XG4gICAgICAgIGlmICh0aGlzLmNvbm4ucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHVybC5wYXJzZShwYWNrZXQubnNwLCB0cnVlKTtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgIGF1dGhQYXlsb2FkID0gcGFyc2VkLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gcGFja2V0Lm5zcDtcbiAgICAgICAgICAgIGF1dGhQYXlsb2FkID0gcGFja2V0LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3BzLmdldChuYW1lc3BhY2UpO1xuICAgICAgICBpZiAoIXNvY2tldCAmJiBwYWNrZXQudHlwZSA9PT0gc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KG5hbWVzcGFjZSwgYXV0aFBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvY2tldCAmJlxuICAgICAgICAgICAgcGFja2V0LnR5cGUgIT09IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1QgJiZcbiAgICAgICAgICAgIHBhY2tldC50eXBlICE9PSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUX0VSUk9SKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuX29ucGFja2V0KHBhY2tldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaW52YWxpZCBzdGF0ZSAocGFja2V0IHR5cGU6ICVzKVwiLCBwYWNrZXQudHlwZSk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlcnIgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmVycm9yKGVycikge1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHNvY2tldC5fb25lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVhc29uXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgZGVidWcoXCJjbGllbnQgY2xvc2Ugd2l0aCByZWFzb24gJXNcIiwgcmVhc29uKTtcbiAgICAgICAgLy8gaWdub3JlIGEgcG90ZW50aWFsIHN1YnNlcXVlbnQgYGNsb3NlYCBldmVudFxuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gYG5zcHNgIGFuZCBgc29ja2V0c2AgYXJlIGNsZWFuZWQgdXAgc2VhbWxlc3NseVxuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHNvY2tldC5fb25jbG9zZShyZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvY2tldHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTsgLy8gY2xlYW4gdXAgZGVjb2RlclxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb25uLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCB0aGlzLm9uZGF0YSk7XG4gICAgICAgIHRoaXMuY29ubi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMub25lcnJvcik7XG4gICAgICAgIHRoaXMuY29ubi5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIHRoaXMub25jbG9zZSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5kZWNvZGVyLnJlbW92ZUxpc3RlbmVyKFwiZGVjb2RlZFwiLCB0aGlzLm9uZGVjb2RlZCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDbGllbnQiLCJzb2NrZXRfaW9fcGFyc2VyXzEiLCJyZXF1aXJlIiwiZGVidWdNb2R1bGUiLCJ1cmwiLCJkZWJ1ZyIsImNvbnN0cnVjdG9yIiwic2VydmVyIiwiY29ubiIsInNvY2tldHMiLCJNYXAiLCJuc3BzIiwiZW5jb2RlciIsImRlY29kZXIiLCJfcGFyc2VyIiwiRGVjb2RlciIsImlkIiwic2V0dXAiLCJyZXF1ZXN0Iiwib25jbG9zZSIsImJpbmQiLCJvbmRhdGEiLCJvbmVycm9yIiwib25kZWNvZGVkIiwib24iLCJjb25uZWN0VGltZW91dCIsInNldFRpbWVvdXQiLCJzaXplIiwiY2xvc2UiLCJfY29ubmVjdFRpbWVvdXQiLCJjb25uZWN0IiwibmFtZSIsImF1dGgiLCJfbnNwcyIsImhhcyIsImRvQ29ubmVjdCIsIl9jaGVja05hbWVzcGFjZSIsImR5bmFtaWNOc3BOYW1lIiwiX3BhY2tldCIsInR5cGUiLCJQYWNrZXRUeXBlIiwiQ09OTkVDVF9FUlJPUiIsIm5zcCIsImRhdGEiLCJtZXNzYWdlIiwib2YiLCJfYWRkIiwic29ja2V0Iiwic2V0IiwiY2xlYXJUaW1lb3V0IiwidW5kZWZpbmVkIiwiX2Rpc2Nvbm5lY3QiLCJ2YWx1ZXMiLCJkaXNjb25uZWN0IiwiY2xlYXIiLCJfcmVtb3ZlIiwiZ2V0IiwiZGVsZXRlIiwicmVhZHlTdGF0ZSIsInBhY2tldCIsIm9wdHMiLCJlbmNvZGVkUGFja2V0cyIsInByZUVuY29kZWQiLCJlbmNvZGUiLCJ3cml0ZVRvRW5naW5lIiwidm9sYXRpbGUiLCJ0cmFuc3BvcnQiLCJ3cml0YWJsZSIsInBhY2tldHMiLCJBcnJheSIsImlzQXJyYXkiLCJlbmNvZGVkUGFja2V0Iiwid3JpdGUiLCJhZGQiLCJlIiwibmFtZXNwYWNlIiwiYXV0aFBheWxvYWQiLCJwcm90b2NvbCIsInBhcnNlZCIsInBhcnNlIiwicGF0aG5hbWUiLCJxdWVyeSIsIkNPTk5FQ1QiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJfb25wYWNrZXQiLCJlcnIiLCJfb25lcnJvciIsInJlYXNvbiIsImRlc2NyaXB0aW9uIiwiZGVzdHJveSIsIl9vbmNsb3NlIiwicmVtb3ZlTGlzdGVuZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/socket.io/dist/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Namespace = exports.Socket = exports.Server = void 0;\nconst http = __webpack_require__(/*! http */ \"http\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst accepts = __webpack_require__(/*! accepts */ \"(rsc)/./node_modules/accepts/index.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst engine_io_1 = __webpack_require__(/*! engine.io */ \"(rsc)/./node_modules/engine.io/build/engine.io.js\");\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/socket.io/dist/client.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst namespace_1 = __webpack_require__(/*! ./namespace */ \"(rsc)/./node_modules/socket.io/dist/namespace.js\");\nObject.defineProperty(exports, \"Namespace\", ({\n    enumerable: true,\n    get: function() {\n        return namespace_1.Namespace;\n    }\n}));\nconst parent_namespace_1 = __webpack_require__(/*! ./parent-namespace */ \"(rsc)/./node_modules/socket.io/dist/parent-namespace.js\");\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst parser = __importStar(__webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/socket.io/dist/socket.js\");\nObject.defineProperty(exports, \"Socket\", ({\n    enumerable: true,\n    get: function() {\n        return socket_1.Socket;\n    }\n}));\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst uws_1 = __webpack_require__(/*! ./uws */ \"(rsc)/./node_modules/socket.io/dist/uws.js\");\nconst cors_1 = __importDefault(__webpack_require__(/*! cors */ \"(rsc)/./node_modules/cors/lib/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:server\");\nconst clientVersion = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/socket.io/package.json\").version);\nconst dotMapRegex = /\\.map/;\n/**\n * Represents a Socket.IO server.\n *\n * @example\n * import { Server } from \"socket.io\";\n *\n * const io = new Server();\n *\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n *\n * io.listen(3000);\n */ class Server extends typed_events_1.StrictEventEmitter {\n    constructor(srv, opts = {}){\n        super();\n        /**\n         * @private\n         */ this._nsps = new Map();\n        this.parentNsps = new Map();\n        /**\n         * A subset of the {@link parentNsps} map, only containing {@link ParentNamespace} which are based on a regular\n         * expression.\n         *\n         * @private\n         */ this.parentNamespacesFromRegExp = new Map();\n        if (\"object\" === typeof srv && srv instanceof Object && !srv.listen) {\n            opts = srv;\n            srv = undefined;\n        }\n        this.path(opts.path || \"/socket.io\");\n        this.connectTimeout(opts.connectTimeout || 45000);\n        this.serveClient(false !== opts.serveClient);\n        this._parser = opts.parser || parser;\n        this.encoder = new this._parser.Encoder();\n        this.opts = opts;\n        if (opts.connectionStateRecovery) {\n            opts.connectionStateRecovery = Object.assign({\n                maxDisconnectionDuration: 2 * 60 * 1000,\n                skipMiddlewares: true\n            }, opts.connectionStateRecovery);\n            this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);\n        } else {\n            this.adapter(opts.adapter || socket_io_adapter_1.Adapter);\n        }\n        opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;\n        this.sockets = this.of(\"/\");\n        if (srv || typeof srv == \"number\") this.attach(srv);\n        if (this.opts.cors) {\n            this._corsMiddleware = (0, cors_1.default)(this.opts.cors);\n        }\n    }\n    get _opts() {\n        return this.opts;\n    }\n    serveClient(v) {\n        if (!arguments.length) return this._serveClient;\n        this._serveClient = v;\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming namespace not already created on the server.\n     *\n     * @param name - name of incoming namespace\n     * @param auth - the auth parameters\n     * @param fn - callback\n     *\n     * @private\n     */ _checkNamespace(name, auth, fn) {\n        if (this.parentNsps.size === 0) return fn(false);\n        const keysIterator = this.parentNsps.keys();\n        const run = ()=>{\n            const nextFn = keysIterator.next();\n            if (nextFn.done) {\n                return fn(false);\n            }\n            nextFn.value(name, auth, (err, allow)=>{\n                if (err || !allow) {\n                    return run();\n                }\n                if (this._nsps.has(name)) {\n                    // the namespace was created in the meantime\n                    debug(\"dynamic namespace %s already exists\", name);\n                    return fn(this._nsps.get(name));\n                }\n                const namespace = this.parentNsps.get(nextFn.value).createChild(name);\n                debug(\"dynamic namespace %s was created\", name);\n                fn(namespace);\n            });\n        };\n        run();\n    }\n    path(v) {\n        if (!arguments.length) return this._path;\n        this._path = v.replace(/\\/$/, \"\");\n        const escapedPath = this._path.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n        this.clientPathRegex = new RegExp(\"^\" + escapedPath + \"/socket\\\\.io(\\\\.msgpack|\\\\.esm)?(\\\\.min)?\\\\.js(\\\\.map)?(?:\\\\?|$)\");\n        return this;\n    }\n    connectTimeout(v) {\n        if (v === undefined) return this._connectTimeout;\n        this._connectTimeout = v;\n        return this;\n    }\n    adapter(v) {\n        if (!arguments.length) return this._adapter;\n        this._adapter = v;\n        for (const nsp of this._nsps.values()){\n            nsp._initAdapter();\n        }\n        return this;\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     */ listen(srv, opts = {}) {\n        return this.attach(srv, opts);\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     */ attach(srv, opts = {}) {\n        if (\"function\" == typeof srv) {\n            const msg = \"You are trying to attach socket.io to an express \" + \"request handler function. Please pass a http.Server instance.\";\n            throw new Error(msg);\n        }\n        // handle a port as a string\n        if (Number(srv) == srv) {\n            srv = Number(srv);\n        }\n        if (\"number\" == typeof srv) {\n            debug(\"creating http server and binding to %d\", srv);\n            const port = srv;\n            srv = http.createServer((req, res)=>{\n                res.writeHead(404);\n                res.end();\n            });\n            srv.listen(port);\n        }\n        // merge the options passed to the Socket.IO server\n        Object.assign(opts, this.opts);\n        // set engine.io path to `/socket.io`\n        opts.path = opts.path || this._path;\n        this.initEngine(srv, opts);\n        return this;\n    }\n    attachApp(app /*: TemplatedApp */ , opts = {}) {\n        // merge the options passed to the Socket.IO server\n        Object.assign(opts, this.opts);\n        // set engine.io path to `/socket.io`\n        opts.path = opts.path || this._path;\n        // initialize engine\n        debug(\"creating uWebSockets.js-based engine with opts %j\", opts);\n        const engine = new engine_io_1.uServer(opts);\n        engine.attach(app, opts);\n        // bind to engine events\n        this.bind(engine);\n        if (this._serveClient) {\n            // attach static file serving\n            app.get(`${this._path}/*`, (res, req)=>{\n                if (!this.clientPathRegex.test(req.getUrl())) {\n                    req.setYield(true);\n                    return;\n                }\n                const filename = req.getUrl().replace(this._path, \"\").replace(/\\?.*$/, \"\").replace(/^\\//, \"\");\n                const isMap = dotMapRegex.test(filename);\n                const type = isMap ? \"map\" : \"source\";\n                // Per the standard, ETags must be quoted:\n                // https://tools.ietf.org/html/rfc7232#section-2.3\n                const expectedEtag = '\"' + clientVersion + '\"';\n                const weakEtag = \"W/\" + expectedEtag;\n                const etag = req.getHeader(\"if-none-match\");\n                if (etag) {\n                    if (expectedEtag === etag || weakEtag === etag) {\n                        debug(\"serve client %s 304\", type);\n                        res.writeStatus(\"304 Not Modified\");\n                        res.end();\n                        return;\n                    }\n                }\n                debug(\"serve client %s\", type);\n                res.writeHeader(\"cache-control\", \"public, max-age=0\");\n                res.writeHeader(\"content-type\", \"application/\" + (isMap ? \"json\" : \"javascript\") + \"; charset=utf-8\");\n                res.writeHeader(\"etag\", expectedEtag);\n                const filepath = path.join(__dirname, \"../client-dist/\", filename);\n                (0, uws_1.serveFile)(res, filepath);\n            });\n        }\n        (0, uws_1.patchAdapter)(app);\n    }\n    /**\n     * Initialize engine\n     *\n     * @param srv - the server to attach to\n     * @param opts - options passed to engine.io\n     * @private\n     */ initEngine(srv, opts) {\n        // initialize engine\n        debug(\"creating engine.io instance with opts %j\", opts);\n        this.eio = (0, engine_io_1.attach)(srv, opts);\n        // attach static file serving\n        if (this._serveClient) this.attachServe(srv);\n        // Export http server\n        this.httpServer = srv;\n        // bind to engine events\n        this.bind(this.eio);\n    }\n    /**\n     * Attaches the static file serving.\n     *\n     * @param srv http server\n     * @private\n     */ attachServe(srv) {\n        debug(\"attaching client serving req handler\");\n        const evs = srv.listeners(\"request\").slice(0);\n        srv.removeAllListeners(\"request\");\n        srv.on(\"request\", (req, res)=>{\n            if (this.clientPathRegex.test(req.url)) {\n                if (this._corsMiddleware) {\n                    this._corsMiddleware(req, res, ()=>{\n                        this.serve(req, res);\n                    });\n                } else {\n                    this.serve(req, res);\n                }\n            } else {\n                for(let i = 0; i < evs.length; i++){\n                    evs[i].call(srv, req, res);\n                }\n            }\n        });\n    }\n    /**\n     * Handles a request serving of client source and map\n     *\n     * @param req\n     * @param res\n     * @private\n     */ serve(req, res) {\n        const filename = req.url.replace(this._path, \"\").replace(/\\?.*$/, \"\");\n        const isMap = dotMapRegex.test(filename);\n        const type = isMap ? \"map\" : \"source\";\n        // Per the standard, ETags must be quoted:\n        // https://tools.ietf.org/html/rfc7232#section-2.3\n        const expectedEtag = '\"' + clientVersion + '\"';\n        const weakEtag = \"W/\" + expectedEtag;\n        const etag = req.headers[\"if-none-match\"];\n        if (etag) {\n            if (expectedEtag === etag || weakEtag === etag) {\n                debug(\"serve client %s 304\", type);\n                res.writeHead(304);\n                res.end();\n                return;\n            }\n        }\n        debug(\"serve client %s\", type);\n        res.setHeader(\"Cache-Control\", \"public, max-age=0\");\n        res.setHeader(\"Content-Type\", \"application/\" + (isMap ? \"json\" : \"javascript\") + \"; charset=utf-8\");\n        res.setHeader(\"ETag\", expectedEtag);\n        Server.sendFile(filename, req, res);\n    }\n    /**\n     * @param filename\n     * @param req\n     * @param res\n     * @private\n     */ static sendFile(filename, req, res) {\n        const readStream = (0, fs_1.createReadStream)(path.join(__dirname, \"../client-dist/\", filename));\n        const encoding = accepts(req).encodings([\n            \"br\",\n            \"gzip\",\n            \"deflate\"\n        ]);\n        const onError = (err)=>{\n            if (err) {\n                res.end();\n            }\n        };\n        switch(encoding){\n            case \"br\":\n                res.writeHead(200, {\n                    \"content-encoding\": \"br\"\n                });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);\n                break;\n            case \"gzip\":\n                res.writeHead(200, {\n                    \"content-encoding\": \"gzip\"\n                });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);\n                break;\n            case \"deflate\":\n                res.writeHead(200, {\n                    \"content-encoding\": \"deflate\"\n                });\n                (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);\n                break;\n            default:\n                res.writeHead(200);\n                (0, stream_1.pipeline)(readStream, res, onError);\n        }\n    }\n    /**\n     * Binds socket.io to an engine.io instance.\n     *\n     * @param engine engine.io (or compatible) server\n     * @return self\n     */ bind(engine) {\n        // TODO apply strict types to the engine: \"connection\" event, `close()` and a method to serve static content\n        //  this would allow to provide any custom engine, like one based on Deno or Bun built-in HTTP server\n        this.engine = engine;\n        this.engine.on(\"connection\", this.onconnection.bind(this));\n        return this;\n    }\n    /**\n     * Called with each incoming transport connection.\n     *\n     * @param {engine.Socket} conn\n     * @return self\n     * @private\n     */ onconnection(conn) {\n        debug(\"incoming connection with id %s\", conn.id);\n        const client = new client_1.Client(this, conn);\n        if (conn.protocol === 3) {\n            // @ts-ignore\n            client.connect(\"/\");\n        }\n        return this;\n    }\n    /**\n     * Looks up a namespace.\n     *\n     * @example\n     * // with a simple string\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // with a regex\n     * const dynamicNsp = io.of(/^\\/dynamic-\\d+$/).on(\"connection\", (socket) => {\n     *   const namespace = socket.nsp; // newNamespace.name === \"/dynamic-101\"\n     *\n     *   // broadcast to all clients in the given sub-namespace\n     *   namespace.emit(\"hello\");\n     * });\n     *\n     * @param name - nsp name\n     * @param fn optional, nsp `connection` ev handler\n     */ of(name, fn) {\n        if (typeof name === \"function\" || name instanceof RegExp) {\n            const parentNsp = new parent_namespace_1.ParentNamespace(this);\n            debug(\"initializing parent namespace %s\", parentNsp.name);\n            if (typeof name === \"function\") {\n                this.parentNsps.set(name, parentNsp);\n            } else {\n                this.parentNsps.set((nsp, conn, next)=>next(null, name.test(nsp)), parentNsp);\n                this.parentNamespacesFromRegExp.set(name, parentNsp);\n            }\n            if (fn) {\n                // @ts-ignore\n                parentNsp.on(\"connect\", fn);\n            }\n            return parentNsp;\n        }\n        if (String(name)[0] !== \"/\") name = \"/\" + name;\n        let nsp = this._nsps.get(name);\n        if (!nsp) {\n            for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp){\n                if (regex.test(name)) {\n                    debug(\"attaching namespace %s to parent namespace %s\", name, regex);\n                    return parentNamespace.createChild(name);\n                }\n            }\n            debug(\"initializing namespace %s\", name);\n            nsp = new namespace_1.Namespace(this, name);\n            this._nsps.set(name, nsp);\n            if (name !== \"/\") {\n                // @ts-ignore\n                this.sockets.emitReserved(\"new_namespace\", nsp);\n            }\n        }\n        if (fn) nsp.on(\"connect\", fn);\n        return nsp;\n    }\n    /**\n     * Closes server connection\n     *\n     * @param [fn] optional, called as `fn([err])` on error OR all conns closed\n     */ async close(fn) {\n        await Promise.allSettled([\n            ...this._nsps.values()\n        ].map(async (nsp)=>{\n            nsp.sockets.forEach((socket)=>{\n                socket._onclose(\"server shutting down\");\n            });\n            await nsp.adapter.close();\n        }));\n        this.engine.close();\n        // restore the Adapter prototype, when the Socket.IO server was attached to a uWebSockets.js server\n        (0, uws_1.restoreAdapter)();\n        if (this.httpServer) {\n            this.httpServer.close(fn);\n        } else {\n            fn && fn();\n        }\n    }\n    /**\n     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.\n     *\n     * @example\n     * io.use((socket, next) => {\n     *   // ...\n     *   next();\n     * });\n     *\n     * @param fn - the middleware function\n     */ use(fn) {\n        this.sockets.use(fn);\n        return this;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * io.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * io.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        return this.sockets.to(room);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * // disconnect all clients in the \"room-101\" room\n     * io.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return this.sockets.in(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * io.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * io.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * io.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        return this.sockets.except(room);\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.send(\"hello\");\n     *\n     * // this is equivalent to\n     * io.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */ send(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.sockets.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients. Alias of {@link send}.\n     *\n     * @return self\n     */ write(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.sockets.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a message to the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * io.serverSideEmit(\"hello\", \"world\");\n     *\n     * io.on(\"hello\", (arg1) => {\n     *   console.log(arg1); // prints \"world\"\n     * });\n     *\n     * // acknowledgements (without binary content) are supported too:\n     * io.serverSideEmit(\"ping\", (err, responses) => {\n     *  if (err) {\n     *     // some servers did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per server (except the current one)\n     *   }\n     * });\n     *\n     * io.on(\"ping\", (cb) => {\n     *   cb(\"pong\");\n     * });\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     */ serverSideEmit(ev, ...args) {\n        return this.sockets.serverSideEmit(ev, ...args);\n    }\n    /**\n     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * try {\n     *   const responses = await io.serverSideEmitWithAck(\"ping\");\n     *   console.log(responses); // one response per server (except the current one)\n     * } catch (e) {\n     *   // some servers did not acknowledge the event in the given delay\n     * }\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments\n     *\n     * @return a Promise that will be fulfilled when all servers have acknowledged the event\n     */ serverSideEmitWithAck(ev, ...args) {\n        return this.sockets.serverSideEmitWithAck(ev, ...args);\n    }\n    /**\n     * Gets a list of socket ids.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or\n     * {@link Server#fetchSockets} instead.\n     */ allSockets() {\n        return this.sockets.allSockets();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ compress(compress) {\n        return this.sockets.compress(compress);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get volatile() {\n        return this.sockets.volatile;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * // the foo event will be broadcast to all connected clients on this node\n     * io.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        return this.sockets.local;\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        return this.sockets.timeout(timeout);\n    }\n    /**\n     * Returns the matching socket instances.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // return all Socket instances\n     * const sockets = await io.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await io.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */ fetchSockets() {\n        return this.sockets.fetchSockets();\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     *\n     * // make all socket instances join the \"room1\" room\n     * io.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsJoin(room) {\n        return this.sockets.socketsJoin(room);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances leave the \"room1\" room\n     * io.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * io.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsLeave(room) {\n        return this.sockets.socketsLeave(room);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * io.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * io.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(close = false) {\n        return this.sockets.disconnectSockets(close);\n    }\n}\nexports.Server = Server;\n/**\n * Expose main namespace (/).\n */ const emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function(key) {\n    return typeof events_1.EventEmitter.prototype[key] === \"function\";\n});\nemitterMethods.forEach(function(fn) {\n    Server.prototype[fn] = function() {\n        return this.sockets[fn].apply(this.sockets, arguments);\n    };\n});\nmodule.exports = (srv, opts)=>new Server(srv, opts);\nmodule.exports.Server = Server;\nmodule.exports.Namespace = namespace_1.Namespace;\nmodule.exports.Socket = socket_1.Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZLElB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Ozs7Ozs7Ozs7S0FjQyxHQUNEQyxZQUFZaEIsSUFBSSxFQUFFO1FBQ2QsT0FBTyxJQUFJLENBQUNsSCxPQUFPLENBQUNrSSxXQUFXLENBQUNoQjtJQUNwQztJQUNBOzs7Ozs7Ozs7Ozs7O0tBYUMsR0FDRGlCLGFBQWFqQixJQUFJLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQ2xILE9BQU8sQ0FBQ21JLFlBQVksQ0FBQ2pCO0lBQ3JDO0lBQ0E7Ozs7Ozs7Ozs7Ozs7S0FhQyxHQUNEa0Isa0JBQWtCNUIsUUFBUSxLQUFLLEVBQUU7UUFDN0IsT0FBTyxJQUFJLENBQUN4RyxPQUFPLENBQUNvSSxpQkFBaUIsQ0FBQzVCO0lBQzFDO0FBQ0o7QUFDQTFKLGNBQWMsR0FBR0c7QUFDakI7O0NBRUMsR0FDRCxNQUFNb0wsaUJBQWlCaE4sT0FBTzBGLElBQUksQ0FBQ3BELFNBQVMySyxZQUFZLENBQUM1TCxTQUFTLEVBQUU2TCxNQUFNLENBQUMsU0FBVUMsR0FBRztJQUNwRixPQUFPLE9BQU83SyxTQUFTMkssWUFBWSxDQUFDNUwsU0FBUyxDQUFDOEwsSUFBSSxLQUFLO0FBQzNEO0FBQ0FILGVBQWV6QixPQUFPLENBQUMsU0FBVWhHLEVBQUU7SUFDL0IzRCxPQUFPUCxTQUFTLENBQUNrRSxHQUFHLEdBQUc7UUFDbkIsT0FBTyxJQUFJLENBQUNaLE9BQU8sQ0FBQ1ksR0FBRyxDQUFDNkgsS0FBSyxDQUFDLElBQUksQ0FBQ3pJLE9BQU8sRUFBRU07SUFDaEQ7QUFDSjtBQUNBb0ksT0FBTzVMLE9BQU8sR0FBRyxDQUFDOEIsS0FBS0MsT0FBUyxJQUFJNUIsT0FBTzJCLEtBQUtDO0FBQ2hENkoscUJBQXFCLEdBQUd6TDtBQUN4QnlMLHdCQUF3QixHQUFHOUssWUFBWWIsU0FBUztBQUNoRDJMLHFCQUFxQixHQUFHekssU0FBU2pCLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWRjb2Rlc19hcHAvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvaW5kZXguanM/MzVhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OYW1lc3BhY2UgPSBleHBvcnRzLlNvY2tldCA9IGV4cG9ydHMuU2VydmVyID0gdm9pZCAwO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHpsaWJfMSA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgYWNjZXB0cyA9IHJlcXVpcmUoXCJhY2NlcHRzXCIpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgZW5naW5lX2lvXzEgPSByZXF1aXJlKFwiZW5naW5lLmlvXCIpO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBuYW1lc3BhY2VfMSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVzcGFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmFtZXNwYWNlXzEuTmFtZXNwYWNlOyB9IH0pO1xuY29uc3QgcGFyZW50X25hbWVzcGFjZV8xID0gcmVxdWlyZShcIi4vcGFyZW50LW5hbWVzcGFjZVwiKTtcbmNvbnN0IHNvY2tldF9pb19hZGFwdGVyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLWFkYXB0ZXJcIik7XG5jb25zdCBwYXJzZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIikpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3Qgc29ja2V0XzEgPSByZXF1aXJlKFwiLi9zb2NrZXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvY2tldF8xLlNvY2tldDsgfSB9KTtcbmNvbnN0IHR5cGVkX2V2ZW50c18xID0gcmVxdWlyZShcIi4vdHlwZWQtZXZlbnRzXCIpO1xuY29uc3QgdXdzXzEgPSByZXF1aXJlKFwiLi91d3NcIik7XG5jb25zdCBjb3JzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNvcnNcIikpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pbzpzZXJ2ZXJcIik7XG5jb25zdCBjbGllbnRWZXJzaW9uID0gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKS52ZXJzaW9uO1xuY29uc3QgZG90TWFwUmVnZXggPSAvXFwubWFwLztcbi8qKlxuICogUmVwcmVzZW50cyBhIFNvY2tldC5JTyBzZXJ2ZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IFNlcnZlciB9IGZyb20gXCJzb2NrZXQuaW9cIjtcbiAqXG4gKiBjb25zdCBpbyA9IG5ldyBTZXJ2ZXIoKTtcbiAqXG4gKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhgc29ja2V0ICR7c29ja2V0LmlkfSBjb25uZWN0ZWRgKTtcbiAqXG4gKiAgIC8vIHNlbmQgYW4gZXZlbnQgdG8gdGhlIGNsaWVudFxuICogICBzb2NrZXQuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAqXG4gKiAgIHNvY2tldC5vbihcImZvb2JhclwiLCAoKSA9PiB7XG4gKiAgICAgLy8gYW4gZXZlbnQgd2FzIHJlY2VpdmVkIGZyb20gdGhlIGNsaWVudFxuICogICB9KTtcbiAqXG4gKiAgIC8vIHVwb24gZGlzY29ubmVjdGlvblxuICogICBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsIChyZWFzb24pID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhgc29ja2V0ICR7c29ja2V0LmlkfSBkaXNjb25uZWN0ZWQgZHVlIHRvICR7cmVhc29ufWApO1xuICogICB9KTtcbiAqIH0pO1xuICpcbiAqIGlvLmxpc3RlbigzMDAwKTtcbiAqL1xuY2xhc3MgU2VydmVyIGV4dGVuZHMgdHlwZWRfZXZlbnRzXzEuU3RyaWN0RXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzcnYsIG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25zcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGFyZW50TnNwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3Vic2V0IG9mIHRoZSB7QGxpbmsgcGFyZW50TnNwc30gbWFwLCBvbmx5IGNvbnRhaW5pbmcge0BsaW5rIFBhcmVudE5hbWVzcGFjZX0gd2hpY2ggYXJlIGJhc2VkIG9uIGEgcmVndWxhclxuICAgICAgICAgKiBleHByZXNzaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJlbnROYW1lc3BhY2VzRnJvbVJlZ0V4cCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBzcnYgJiZcbiAgICAgICAgICAgIHNydiBpbnN0YW5jZW9mIE9iamVjdCAmJlxuICAgICAgICAgICAgIXNydi5saXN0ZW4pIHtcbiAgICAgICAgICAgIG9wdHMgPSBzcnY7XG4gICAgICAgICAgICBzcnYgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRoKG9wdHMucGF0aCB8fCBcIi9zb2NrZXQuaW9cIik7XG4gICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQob3B0cy5jb25uZWN0VGltZW91dCB8fCA0NTAwMCk7XG4gICAgICAgIHRoaXMuc2VydmVDbGllbnQoZmFsc2UgIT09IG9wdHMuc2VydmVDbGllbnQpO1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSBvcHRzLnBhcnNlciB8fCBwYXJzZXI7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG5ldyB0aGlzLl9wYXJzZXIuRW5jb2RlcigpO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICBpZiAob3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSkge1xuICAgICAgICAgICAgb3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIG1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbjogMiAqIDYwICogMTAwMCxcbiAgICAgICAgICAgICAgICBza2lwTWlkZGxld2FyZXM6IHRydWUsXG4gICAgICAgICAgICB9LCBvcHRzLmNvbm5lY3Rpb25TdGF0ZVJlY292ZXJ5KTtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlcihvcHRzLmFkYXB0ZXIgfHwgc29ja2V0X2lvX2FkYXB0ZXJfMS5TZXNzaW9uQXdhcmVBZGFwdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlcihvcHRzLmFkYXB0ZXIgfHwgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzLmNsZWFudXBFbXB0eUNoaWxkTmFtZXNwYWNlcyA9ICEhb3B0cy5jbGVhbnVwRW1wdHlDaGlsZE5hbWVzcGFjZXM7XG4gICAgICAgIHRoaXMuc29ja2V0cyA9IHRoaXMub2YoXCIvXCIpO1xuICAgICAgICBpZiAoc3J2IHx8IHR5cGVvZiBzcnYgPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoKHNydik7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29ycykge1xuICAgICAgICAgICAgdGhpcy5fY29yc01pZGRsZXdhcmUgPSAoMCwgY29yc18xLmRlZmF1bHQpKHRoaXMub3B0cy5jb3JzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgX29wdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdHM7XG4gICAgfVxuICAgIHNlcnZlQ2xpZW50KHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlQ2xpZW50O1xuICAgICAgICB0aGlzLl9zZXJ2ZUNsaWVudCA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgbWlkZGxld2FyZSBmb3IgYW4gaW5jb21pbmcgbmFtZXNwYWNlIG5vdCBhbHJlYWR5IGNyZWF0ZWQgb24gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gbmFtZSBvZiBpbmNvbWluZyBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0gYXV0aCAtIHRoZSBhdXRoIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gZm4gLSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tOYW1lc3BhY2UobmFtZSwgYXV0aCwgZm4pIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50TnNwcy5zaXplID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZuKGZhbHNlKTtcbiAgICAgICAgY29uc3Qga2V5c0l0ZXJhdG9yID0gdGhpcy5wYXJlbnROc3BzLmtleXMoKTtcbiAgICAgICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dEZuID0ga2V5c0l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Rm4uZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0Rm4udmFsdWUobmFtZSwgYXV0aCwgKGVyciwgYWxsb3cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIHx8ICFhbGxvdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uc3BzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmFtZXNwYWNlIHdhcyBjcmVhdGVkIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImR5bmFtaWMgbmFtZXNwYWNlICVzIGFscmVhZHkgZXhpc3RzXCIsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4odGhpcy5fbnNwcy5nZXQobmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLnBhcmVudE5zcHMuZ2V0KG5leHRGbi52YWx1ZSkuY3JlYXRlQ2hpbGQobmFtZSk7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJkeW5hbWljIG5hbWVzcGFjZSAlcyB3YXMgY3JlYXRlZFwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBmbihuYW1lc3BhY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJ1bigpO1xuICAgIH1cbiAgICBwYXRoKHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgICAgIHRoaXMuX3BhdGggPSB2LnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgICAgICAgY29uc3QgZXNjYXBlZFBhdGggPSB0aGlzLl9wYXRoLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIik7XG4gICAgICAgIHRoaXMuY2xpZW50UGF0aFJlZ2V4ID0gbmV3IFJlZ0V4cChcIl5cIiArXG4gICAgICAgICAgICBlc2NhcGVkUGF0aCArXG4gICAgICAgICAgICBcIi9zb2NrZXRcXFxcLmlvKFxcXFwubXNncGFja3xcXFxcLmVzbSk/KFxcXFwubWluKT9cXFxcLmpzKFxcXFwubWFwKT8oPzpcXFxcP3wkKVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbm5lY3RUaW1lb3V0KHYpIHtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0VGltZW91dDtcbiAgICAgICAgdGhpcy5fY29ubmVjdFRpbWVvdXQgPSB2O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRhcHRlcih2KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGFwdGVyO1xuICAgICAgICB0aGlzLl9hZGFwdGVyID0gdjtcbiAgICAgICAgZm9yIChjb25zdCBuc3Agb2YgdGhpcy5fbnNwcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbnNwLl9pbml0QWRhcHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBzb2NrZXQuaW8gdG8gYSBzZXJ2ZXIgb3IgcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcnYgLSBzZXJ2ZXIgb3IgcG9ydFxuICAgICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBwYXNzZWQgdG8gZW5naW5lLmlvXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgbGlzdGVuKHNydiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dGFjaChzcnYsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBzb2NrZXQuaW8gdG8gYSBzZXJ2ZXIgb3IgcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcnYgLSBzZXJ2ZXIgb3IgcG9ydFxuICAgICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBwYXNzZWQgdG8gZW5naW5lLmlvXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgYXR0YWNoKHNydiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHNydikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gXCJZb3UgYXJlIHRyeWluZyB0byBhdHRhY2ggc29ja2V0LmlvIHRvIGFuIGV4cHJlc3MgXCIgK1xuICAgICAgICAgICAgICAgIFwicmVxdWVzdCBoYW5kbGVyIGZ1bmN0aW9uLiBQbGVhc2UgcGFzcyBhIGh0dHAuU2VydmVyIGluc3RhbmNlLlwiO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGEgcG9ydCBhcyBhIHN0cmluZ1xuICAgICAgICBpZiAoTnVtYmVyKHNydikgPT0gc3J2KSB7XG4gICAgICAgICAgICBzcnYgPSBOdW1iZXIoc3J2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2Ygc3J2KSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNyZWF0aW5nIGh0dHAgc2VydmVyIGFuZCBiaW5kaW5nIHRvICVkXCIsIHNydik7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gc3J2O1xuICAgICAgICAgICAgc3J2ID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCg0MDQpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3J2Lmxpc3Rlbihwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIFNvY2tldC5JTyBzZXJ2ZXJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCB0aGlzLm9wdHMpO1xuICAgICAgICAvLyBzZXQgZW5naW5lLmlvIHBhdGggdG8gYC9zb2NrZXQuaW9gXG4gICAgICAgIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCB0aGlzLl9wYXRoO1xuICAgICAgICB0aGlzLmluaXRFbmdpbmUoc3J2LCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGF0dGFjaEFwcChhcHAgLyo6IFRlbXBsYXRlZEFwcCAqLywgb3B0cyA9IHt9KSB7XG4gICAgICAgIC8vIG1lcmdlIHRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgU29ja2V0LklPIHNlcnZlclxuICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIHRoaXMub3B0cyk7XG4gICAgICAgIC8vIHNldCBlbmdpbmUuaW8gcGF0aCB0byBgL3NvY2tldC5pb2BcbiAgICAgICAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8IHRoaXMuX3BhdGg7XG4gICAgICAgIC8vIGluaXRpYWxpemUgZW5naW5lXG4gICAgICAgIGRlYnVnKFwiY3JlYXRpbmcgdVdlYlNvY2tldHMuanMtYmFzZWQgZW5naW5lIHdpdGggb3B0cyAlalwiLCBvcHRzKTtcbiAgICAgICAgY29uc3QgZW5naW5lID0gbmV3IGVuZ2luZV9pb18xLnVTZXJ2ZXIob3B0cyk7XG4gICAgICAgIGVuZ2luZS5hdHRhY2goYXBwLCBvcHRzKTtcbiAgICAgICAgLy8gYmluZCB0byBlbmdpbmUgZXZlbnRzXG4gICAgICAgIHRoaXMuYmluZChlbmdpbmUpO1xuICAgICAgICBpZiAodGhpcy5fc2VydmVDbGllbnQpIHtcbiAgICAgICAgICAgIC8vIGF0dGFjaCBzdGF0aWMgZmlsZSBzZXJ2aW5nXG4gICAgICAgICAgICBhcHAuZ2V0KGAke3RoaXMuX3BhdGh9LypgLCAocmVzLCByZXEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2xpZW50UGF0aFJlZ2V4LnRlc3QocmVxLmdldFVybCgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXEuc2V0WWllbGQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSByZXFcbiAgICAgICAgICAgICAgICAgICAgLmdldFVybCgpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHRoaXMuX3BhdGgsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzTWFwID0gZG90TWFwUmVnZXgudGVzdChmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGlzTWFwID8gXCJtYXBcIiA6IFwic291cmNlXCI7XG4gICAgICAgICAgICAgICAgLy8gUGVyIHRoZSBzdGFuZGFyZCwgRVRhZ3MgbXVzdCBiZSBxdW90ZWQ6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzIjc2VjdGlvbi0yLjNcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZEV0YWcgPSAnXCInICsgY2xpZW50VmVyc2lvbiArICdcIic7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2Vha0V0YWcgPSBcIlcvXCIgKyBleHBlY3RlZEV0YWc7XG4gICAgICAgICAgICAgICAgY29uc3QgZXRhZyA9IHJlcS5nZXRIZWFkZXIoXCJpZi1ub25lLW1hdGNoXCIpO1xuICAgICAgICAgICAgICAgIGlmIChldGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZEV0YWcgPT09IGV0YWcgfHwgd2Vha0V0YWcgPT09IGV0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwic2VydmUgY2xpZW50ICVzIDMwNFwiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjMwNCBOb3QgTW9kaWZpZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzZXJ2ZSBjbGllbnQgJXNcIiwgdHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZGVyKFwiY2FjaGUtY29udHJvbFwiLCBcInB1YmxpYywgbWF4LWFnZT0wXCIpO1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWRlcihcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL1wiICsgKGlzTWFwID8gXCJqc29uXCIgOiBcImphdmFzY3JpcHRcIikgKyBcIjsgY2hhcnNldD11dGYtOFwiKTtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkZXIoXCJldGFnXCIsIGV4cGVjdGVkRXRhZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXBhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uL2NsaWVudC1kaXN0L1wiLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgKDAsIHV3c18xLnNlcnZlRmlsZSkocmVzLCBmaWxlcGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgdXdzXzEucGF0Y2hBZGFwdGVyKShhcHApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGVuZ2luZVxuICAgICAqXG4gICAgICogQHBhcmFtIHNydiAtIHRoZSBzZXJ2ZXIgdG8gYXR0YWNoIHRvXG4gICAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIHBhc3NlZCB0byBlbmdpbmUuaW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRFbmdpbmUoc3J2LCBvcHRzKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemUgZW5naW5lXG4gICAgICAgIGRlYnVnKFwiY3JlYXRpbmcgZW5naW5lLmlvIGluc3RhbmNlIHdpdGggb3B0cyAlalwiLCBvcHRzKTtcbiAgICAgICAgdGhpcy5laW8gPSAoMCwgZW5naW5lX2lvXzEuYXR0YWNoKShzcnYsIG9wdHMpO1xuICAgICAgICAvLyBhdHRhY2ggc3RhdGljIGZpbGUgc2VydmluZ1xuICAgICAgICBpZiAodGhpcy5fc2VydmVDbGllbnQpXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNlcnZlKHNydik7XG4gICAgICAgIC8vIEV4cG9ydCBodHRwIHNlcnZlclxuICAgICAgICB0aGlzLmh0dHBTZXJ2ZXIgPSBzcnY7XG4gICAgICAgIC8vIGJpbmQgdG8gZW5naW5lIGV2ZW50c1xuICAgICAgICB0aGlzLmJpbmQodGhpcy5laW8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgc3RhdGljIGZpbGUgc2VydmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcnYgaHR0cCBzZXJ2ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGF0dGFjaFNlcnZlKHNydikge1xuICAgICAgICBkZWJ1ZyhcImF0dGFjaGluZyBjbGllbnQgc2VydmluZyByZXEgaGFuZGxlclwiKTtcbiAgICAgICAgY29uc3QgZXZzID0gc3J2Lmxpc3RlbmVycyhcInJlcXVlc3RcIikuc2xpY2UoMCk7XG4gICAgICAgIHNydi5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJyZXF1ZXN0XCIpO1xuICAgICAgICBzcnYub24oXCJyZXF1ZXN0XCIsIChyZXEsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50UGF0aFJlZ2V4LnRlc3QocmVxLnVybCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29yc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29yc01pZGRsZXdhcmUocmVxLCByZXMsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmUocmVxLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmUocmVxLCByZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2c1tpXS5jYWxsKHNydiwgcmVxLCByZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSByZXF1ZXN0IHNlcnZpbmcgb2YgY2xpZW50IHNvdXJjZSBhbmQgbWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICogQHBhcmFtIHJlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2VydmUocmVxLCByZXMpIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSByZXEudXJsLnJlcGxhY2UodGhpcy5fcGF0aCwgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIik7XG4gICAgICAgIGNvbnN0IGlzTWFwID0gZG90TWFwUmVnZXgudGVzdChmaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBpc01hcCA/IFwibWFwXCIgOiBcInNvdXJjZVwiO1xuICAgICAgICAvLyBQZXIgdGhlIHN0YW5kYXJkLCBFVGFncyBtdXN0IGJlIHF1b3RlZDpcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzIjc2VjdGlvbi0yLjNcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRFdGFnID0gJ1wiJyArIGNsaWVudFZlcnNpb24gKyAnXCInO1xuICAgICAgICBjb25zdCB3ZWFrRXRhZyA9IFwiVy9cIiArIGV4cGVjdGVkRXRhZztcbiAgICAgICAgY29uc3QgZXRhZyA9IHJlcS5oZWFkZXJzW1wiaWYtbm9uZS1tYXRjaFwiXTtcbiAgICAgICAgaWYgKGV0YWcpIHtcbiAgICAgICAgICAgIGlmIChleHBlY3RlZEV0YWcgPT09IGV0YWcgfHwgd2Vha0V0YWcgPT09IGV0YWcpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInNlcnZlIGNsaWVudCAlcyAzMDRcIiwgdHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgzMDQpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJzZXJ2ZSBjbGllbnQgJXNcIiwgdHlwZSk7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoXCJDYWNoZS1Db250cm9sXCIsIFwicHVibGljLCBtYXgtYWdlPTBcIik7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9cIiArIChpc01hcCA/IFwianNvblwiIDogXCJqYXZhc2NyaXB0XCIpICsgXCI7IGNoYXJzZXQ9dXRmLThcIik7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoXCJFVGFnXCIsIGV4cGVjdGVkRXRhZyk7XG4gICAgICAgIFNlcnZlci5zZW5kRmlsZShmaWxlbmFtZSwgcmVxLCByZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWVcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICogQHBhcmFtIHJlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIHNlbmRGaWxlKGZpbGVuYW1lLCByZXEsIHJlcykge1xuICAgICAgICBjb25zdCByZWFkU3RyZWFtID0gKDAsIGZzXzEuY3JlYXRlUmVhZFN0cmVhbSkocGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLi9jbGllbnQtZGlzdC9cIiwgZmlsZW5hbWUpKTtcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBhY2NlcHRzKHJlcSkuZW5jb2RpbmdzKFtcImJyXCIsIFwiZ3ppcFwiLCBcImRlZmxhdGVcIl0pO1xuICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICAgICAgY2FzZSBcImJyXCI6XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDAsIHsgXCJjb250ZW50LWVuY29kaW5nXCI6IFwiYnJcIiB9KTtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHJlYWRTdHJlYW0sICgwLCB6bGliXzEuY3JlYXRlQnJvdGxpQ29tcHJlc3MpKCksIHJlcywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ3ppcFwiOlxuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwLCB7IFwiY29udGVudC1lbmNvZGluZ1wiOiBcImd6aXBcIiB9KTtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHJlYWRTdHJlYW0sICgwLCB6bGliXzEuY3JlYXRlR3ppcCkoKSwgcmVzLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkZWZsYXRlXCI6XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDAsIHsgXCJjb250ZW50LWVuY29kaW5nXCI6IFwiZGVmbGF0ZVwiIH0pO1xuICAgICAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkocmVhZFN0cmVhbSwgKDAsIHpsaWJfMS5jcmVhdGVEZWZsYXRlKSgpLCByZXMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCk7XG4gICAgICAgICAgICAgICAgKDAsIHN0cmVhbV8xLnBpcGVsaW5lKShyZWFkU3RyZWFtLCByZXMsIG9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIHNvY2tldC5pbyB0byBhbiBlbmdpbmUuaW8gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5naW5lIGVuZ2luZS5pbyAob3IgY29tcGF0aWJsZSkgc2VydmVyXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgYmluZChlbmdpbmUpIHtcbiAgICAgICAgLy8gVE9ETyBhcHBseSBzdHJpY3QgdHlwZXMgdG8gdGhlIGVuZ2luZTogXCJjb25uZWN0aW9uXCIgZXZlbnQsIGBjbG9zZSgpYCBhbmQgYSBtZXRob2QgdG8gc2VydmUgc3RhdGljIGNvbnRlbnRcbiAgICAgICAgLy8gIHRoaXMgd291bGQgYWxsb3cgdG8gcHJvdmlkZSBhbnkgY3VzdG9tIGVuZ2luZSwgbGlrZSBvbmUgYmFzZWQgb24gRGVubyBvciBCdW4gYnVpbHQtaW4gSFRUUCBzZXJ2ZXJcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICAgIHRoaXMuZW5naW5lLm9uKFwiY29ubmVjdGlvblwiLCB0aGlzLm9uY29ubmVjdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGVhY2ggaW5jb21pbmcgdHJhbnNwb3J0IGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2VuZ2luZS5Tb2NrZXR9IGNvbm5cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY29ubmVjdGlvbihjb25uKSB7XG4gICAgICAgIGRlYnVnKFwiaW5jb21pbmcgY29ubmVjdGlvbiB3aXRoIGlkICVzXCIsIGNvbm4uaWQpO1xuICAgICAgICBjb25zdCBjbGllbnQgPSBuZXcgY2xpZW50XzEuQ2xpZW50KHRoaXMsIGNvbm4pO1xuICAgICAgICBpZiAoY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2xpZW50LmNvbm5lY3QoXCIvXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rcyB1cCBhIG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gd2l0aCBhIHNpbXBsZSBzdHJpbmdcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYSByZWdleFxuICAgICAqIGNvbnN0IGR5bmFtaWNOc3AgPSBpby5vZigvXlxcL2R5bmFtaWMtXFxkKyQvKS5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgY29uc3QgbmFtZXNwYWNlID0gc29ja2V0Lm5zcDsgLy8gbmV3TmFtZXNwYWNlLm5hbWUgPT09IFwiL2R5bmFtaWMtMTAxXCJcbiAgICAgKlxuICAgICAqICAgLy8gYnJvYWRjYXN0IHRvIGFsbCBjbGllbnRzIGluIHRoZSBnaXZlbiBzdWItbmFtZXNwYWNlXG4gICAgICogICBuYW1lc3BhY2UuZW1pdChcImhlbGxvXCIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBuc3AgbmFtZVxuICAgICAqIEBwYXJhbSBmbiBvcHRpb25hbCwgbnNwIGBjb25uZWN0aW9uYCBldiBoYW5kbGVyXG4gICAgICovXG4gICAgb2YobmFtZSwgZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgfHwgbmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TnNwID0gbmV3IHBhcmVudF9uYW1lc3BhY2VfMS5QYXJlbnROYW1lc3BhY2UodGhpcyk7XG4gICAgICAgICAgICBkZWJ1ZyhcImluaXRpYWxpemluZyBwYXJlbnQgbmFtZXNwYWNlICVzXCIsIHBhcmVudE5zcC5uYW1lKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROc3BzLnNldChuYW1lLCBwYXJlbnROc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROc3BzLnNldCgobnNwLCBjb25uLCBuZXh0KSA9PiBuZXh0KG51bGwsIG5hbWUudGVzdChuc3ApKSwgcGFyZW50TnNwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5hbWVzcGFjZXNGcm9tUmVnRXhwLnNldChuYW1lLCBwYXJlbnROc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHBhcmVudE5zcC5vbihcImNvbm5lY3RcIiwgZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5zcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3RyaW5nKG5hbWUpWzBdICE9PSBcIi9cIilcbiAgICAgICAgICAgIG5hbWUgPSBcIi9cIiArIG5hbWU7XG4gICAgICAgIGxldCBuc3AgPSB0aGlzLl9uc3BzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFuc3ApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3JlZ2V4LCBwYXJlbnROYW1lc3BhY2VdIG9mIHRoaXMucGFyZW50TmFtZXNwYWNlc0Zyb21SZWdFeHApIHtcbiAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImF0dGFjaGluZyBuYW1lc3BhY2UgJXMgdG8gcGFyZW50IG5hbWVzcGFjZSAlc1wiLCBuYW1lLCByZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnROYW1lc3BhY2UuY3JlYXRlQ2hpbGQobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVidWcoXCJpbml0aWFsaXppbmcgbmFtZXNwYWNlICVzXCIsIG5hbWUpO1xuICAgICAgICAgICAgbnNwID0gbmV3IG5hbWVzcGFjZV8xLk5hbWVzcGFjZSh0aGlzLCBuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX25zcHMuc2V0KG5hbWUsIG5zcCk7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRzLmVtaXRSZXNlcnZlZChcIm5ld19uYW1lc3BhY2VcIiwgbnNwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm4pXG4gICAgICAgICAgICBuc3Aub24oXCJjb25uZWN0XCIsIGZuKTtcbiAgICAgICAgcmV0dXJuIG5zcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHNlcnZlciBjb25uZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW2ZuXSBvcHRpb25hbCwgY2FsbGVkIGFzIGBmbihbZXJyXSlgIG9uIGVycm9yIE9SIGFsbCBjb25ucyBjbG9zZWRcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZShmbikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoWy4uLnRoaXMuX25zcHMudmFsdWVzKCldLm1hcChhc3luYyAobnNwKSA9PiB7XG4gICAgICAgICAgICBuc3Auc29ja2V0cy5mb3JFYWNoKChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuX29uY2xvc2UoXCJzZXJ2ZXIgc2h1dHRpbmcgZG93blwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgbnNwLmFkYXB0ZXIuY2xvc2UoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICAvLyByZXN0b3JlIHRoZSBBZGFwdGVyIHByb3RvdHlwZSwgd2hlbiB0aGUgU29ja2V0LklPIHNlcnZlciB3YXMgYXR0YWNoZWQgdG8gYSB1V2ViU29ja2V0cy5qcyBzZXJ2ZXJcbiAgICAgICAgKDAsIHV3c18xLnJlc3RvcmVBZGFwdGVyKSgpO1xuICAgICAgICBpZiAodGhpcy5odHRwU2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmh0dHBTZXJ2ZXIuY2xvc2UoZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm4gJiYgZm4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBtaWRkbGV3YXJlLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCBmb3IgZXZlcnkgaW5jb21pbmcge0BsaW5rIFNvY2tldH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLnVzZSgoc29ja2V0LCBuZXh0KSA9PiB7XG4gICAgICogICAvLyAuLi5cbiAgICAgKiAgIG5leHQoKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIHRoZSBtaWRkbGV3YXJlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgdXNlKGZuKSB7XG4gICAgICAgIHRoaXMuc29ja2V0cy51c2UoZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgaW4gdGhlIOKAnHJvb20tMTAx4oCdIHJvb21cbiAgICAgKiBpby50byhcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFycmF5IG9mIHJvb21zIChhIGNsaWVudCB3aWxsIGJlIG5vdGlmaWVkIGF0IG1vc3Qgb25jZSlcbiAgICAgKiBpby50byhbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogaW8udG8oXCJyb29tLTEwMVwiKS50byhcInJvb20tMTAyXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgdG8ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnRvKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLiBTaW1pbGFyIHRvIGB0bygpYCwgYnV0IG1pZ2h0IGZlZWwgY2xlYXJlciBpbiBzb21lIGNhc2VzOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBkaXNjb25uZWN0IGFsbCBjbGllbnRzIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqIGlvLmluKFwicm9vbS0xMDFcIikuZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBpbihyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGVzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGUgXCJmb29cIiBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMsIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGFyZSBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiBpby5leGNlcHQoXCJyb29tLTEwMVwiKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIGlvLmV4Y2VwdChbXCJyb29tLTEwMVwiLCBcInJvb20tMTAyXCJdKS5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogaW8uZXhjZXB0KFwicm9vbS0xMDFcIikuZXhjZXB0KFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBleGNlcHQocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmV4Y2VwdChyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQgdG8gYWxsIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtaW1pY3MgdGhlIFdlYlNvY2tldC5zZW5kKCkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViU29ja2V0L3NlbmRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8uc2VuZChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICogaW8uZW1pdChcIm1lc3NhZ2VcIiwgXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICAvLyBUaGlzIHR5cGUtY2FzdCBpcyBuZWVkZWQgYmVjYXVzZSBFbWl0RXZlbnRzIGxpa2VseSBkb2Vzbid0IGhhdmUgYG1lc3NhZ2VgIGFzIGEga2V5LlxuICAgICAgICAvLyBpZiB5b3Ugc3BlY2lmeSB0aGUgRW1pdEV2ZW50cywgdGhlIHR5cGUgb2YgYXJncyB3aWxsIGJlIG5ldmVyLlxuICAgICAgICB0aGlzLnNvY2tldHMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudCB0byBhbGwgY2xpZW50cy4gQWxpYXMgb2Yge0BsaW5rIHNlbmR9LlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgd3JpdGUoLi4uYXJncykge1xuICAgICAgICAvLyBUaGlzIHR5cGUtY2FzdCBpcyBuZWVkZWQgYmVjYXVzZSBFbWl0RXZlbnRzIGxpa2VseSBkb2Vzbid0IGhhdmUgYG1lc3NhZ2VgIGFzIGEga2V5LlxuICAgICAgICAvLyBpZiB5b3Ugc3BlY2lmeSB0aGUgRW1pdEV2ZW50cywgdGhlIHR5cGUgb2YgYXJncyB3aWxsIGJlIG5ldmVyLlxuICAgICAgICB0aGlzLnNvY2tldHMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5zZXJ2ZXJTaWRlRW1pdChcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiBpby5vbihcImhlbGxvXCIsIChhcmcxKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhhcmcxKTsgLy8gcHJpbnRzIFwid29ybGRcIlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gYWNrbm93bGVkZ2VtZW50cyAod2l0aG91dCBiaW5hcnkgY29udGVudCkgYXJlIHN1cHBvcnRlZCB0b286XG4gICAgICogaW8uc2VydmVyU2lkZUVtaXQoXCJwaW5nXCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgc2VydmVycyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgc2VydmVyIChleGNlcHQgdGhlIGN1cnJlbnQgb25lKVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogaW8ub24oXCJwaW5nXCIsIChjYikgPT4ge1xuICAgICAqICAgY2IoXCJwb25nXCIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2IC0gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFuIGFycmF5IG9mIGFyZ3VtZW50cywgd2hpY2ggbWF5IGluY2x1ZGUgYW4gYWNrbm93bGVkZ2VtZW50IGNhbGxiYWNrIGF0IHRoZSBlbmRcbiAgICAgKi9cbiAgICBzZXJ2ZXJTaWRlRW1pdChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnNlcnZlclNpZGVFbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIGFuZCBleHBlY3QgYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gdGhlIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzIG9mIHRoZSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0cnkge1xuICAgICAqICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgaW8uc2VydmVyU2lkZUVtaXRXaXRoQWNrKFwicGluZ1wiKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgc2VydmVyIChleGNlcHQgdGhlIGN1cnJlbnQgb25lKVxuICAgICAqIH0gY2F0Y2ggKGUpIHtcbiAgICAgKiAgIC8vIHNvbWUgc2VydmVycyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgLSB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gYWxsIHNlcnZlcnMgaGF2ZSBhY2tub3dsZWRnZWQgdGhlIGV2ZW50XG4gICAgICovXG4gICAgc2VydmVyU2lkZUVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuc2VydmVyU2lkZUVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2Ygc29ja2V0IGlkcy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLCBwbGVhc2UgdXNlIHtAbGluayBTZXJ2ZXIjc2VydmVyU2lkZUVtaXR9IG9yXG4gICAgICoge0BsaW5rIFNlcnZlciNmZXRjaFNvY2tldHN9IGluc3RlYWQuXG4gICAgICovXG4gICAgYWxsU29ja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5hbGxTb2NrZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLmNvbXByZXNzKGZhbHNlKS5lbWl0KFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmNvbXByZXNzKGNvbXByZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSBtYXkgYmUgbG9zdCBpZiB0aGUgY2xpZW50IGlzIG5vdCByZWFkeSB0b1xuICAgICAqIHJlY2VpdmUgbWVzc2FnZXMgKGJlY2F1c2Ugb2YgbmV0d29yayBzbG93bmVzcyBvciBvdGhlciBpc3N1ZXMsIG9yIGJlY2F1c2UgdGhleeKAmXJlIGNvbm5lY3RlZCB0aHJvdWdoIGxvbmcgcG9sbGluZ1xuICAgICAqIGFuZCBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgcmVxdWVzdC1yZXNwb25zZSBjeWNsZSkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLnZvbGF0aWxlLmVtaXQoXCJoZWxsb1wiKTsgLy8gdGhlIGNsaWVudHMgbWF5IG9yIG1heSBub3QgcmVjZWl2ZSBpdFxuICAgICAqXG4gICAgICogQHJldHVybiBhIG5ldyB7QGxpbmsgQnJvYWRjYXN0T3BlcmF0b3J9IGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGdldCB2b2xhdGlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy52b2xhdGlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIG9uIHRoaXMgbm9kZVxuICAgICAqIGlvLmxvY2FsLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZ2V0IGxvY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmxvY2FsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBuZXh0IG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8udGltZW91dCgxMDAwKS5lbWl0KFwic29tZS1ldmVudFwiLCAoZXJyLCByZXNwb25zZXMpID0+IHtcbiAgICAgKiAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gc29tZSBjbGllbnRzIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2VzKTsgLy8gb25lIHJlc3BvbnNlIHBlciBjbGllbnRcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0XG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMudGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm4gYWxsIFNvY2tldCBpbnN0YW5jZXNcbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgaW8uZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm4gYWxsIFNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogY29uc3Qgc29ja2V0cyA9IGF3YWl0IGlvLmluKFwicm9vbTFcIikuZmV0Y2hTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiBmb3IgKGNvbnN0IHNvY2tldCBvZiBzb2NrZXRzKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuaWQpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmhhbmRzaGFrZSk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQucm9vbXMpO1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmRhdGEpO1xuICAgICAqXG4gICAgICogICBzb2NrZXQuZW1pdChcImhlbGxvXCIpO1xuICAgICAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAgICAgKiAgIHNvY2tldC5sZWF2ZShcInJvb20yXCIpO1xuICAgICAqICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgZmV0Y2hTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmZldGNoU29ja2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBzcGVjaWZpZWQgcm9vbXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogaW8uc29ja2V0c0pvaW4oXCJyb29tMVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgaW4gdGhlIFwicm9vbTFcIiByb29tIGpvaW4gdGhlIFwicm9vbTJcIiBhbmQgXCJyb29tM1wiIHJvb21zXG4gICAgICogaW8uaW4oXCJyb29tMVwiKS5zb2NrZXRzSm9pbihbXCJyb29tMlwiLCBcInJvb20zXCJdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIHNvY2tldHNKb2luKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5zb2NrZXRzSm9pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIGlvLnNvY2tldHNMZWF2ZShcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb20gbGVhdmUgdGhlIFwicm9vbTJcIiBhbmQgXCJyb29tM1wiIHJvb21zXG4gICAgICogaW8uaW4oXCJyb29tMVwiKS5zb2NrZXRzTGVhdmUoW1wicm9vbTJcIiwgXCJyb29tM1wiXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBzb2NrZXRzTGVhdmUocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnNvY2tldHNMZWF2ZShyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3QgKHRoZSBjb25uZWN0aW9ucyBtaWdodCBiZSBrZXB0IGFsaXZlIGZvciBvdGhlciBuYW1lc3BhY2VzKVxuICAgICAqIGlvLmRpc2Nvbm5lY3RTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBkaXNjb25uZWN0IGFuZCBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uc1xuICAgICAqIGlvLmluKFwicm9vbTFcIikuZGlzY29ubmVjdFNvY2tldHModHJ1ZSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xvc2UgLSB3aGV0aGVyIHRvIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0U29ja2V0cyhjbG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuZGlzY29ubmVjdFNvY2tldHMoY2xvc2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xuLyoqXG4gKiBFeHBvc2UgbWFpbiBuYW1lc3BhY2UgKC8pLlxuICovXG5jb25zdCBlbWl0dGVyTWV0aG9kcyA9IE9iamVjdC5rZXlzKGV2ZW50c18xLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBldmVudHNfMS5FdmVudEVtaXR0ZXIucHJvdG90eXBlW2tleV0gPT09IFwiZnVuY3Rpb25cIjtcbn0pO1xuZW1pdHRlck1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICBTZXJ2ZXIucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0c1tmbl0uYXBwbHkodGhpcy5zb2NrZXRzLCBhcmd1bWVudHMpO1xuICAgIH07XG59KTtcbm1vZHVsZS5leHBvcnRzID0gKHNydiwgb3B0cykgPT4gbmV3IFNlcnZlcihzcnYsIG9wdHMpO1xubW9kdWxlLmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xubW9kdWxlLmV4cG9ydHMuTmFtZXNwYWNlID0gbmFtZXNwYWNlXzEuTmFtZXNwYWNlO1xubW9kdWxlLmV4cG9ydHMuU29ja2V0ID0gc29ja2V0XzEuU29ja2V0O1xuIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9faW1wb3J0RGVmYXVsdCIsImV4cG9ydHMiLCJOYW1lc3BhY2UiLCJTb2NrZXQiLCJTZXJ2ZXIiLCJodHRwIiwicmVxdWlyZSIsImZzXzEiLCJ6bGliXzEiLCJhY2NlcHRzIiwic3RyZWFtXzEiLCJwYXRoIiwiZW5naW5lX2lvXzEiLCJjbGllbnRfMSIsImV2ZW50c18xIiwibmFtZXNwYWNlXzEiLCJwYXJlbnRfbmFtZXNwYWNlXzEiLCJzb2NrZXRfaW9fYWRhcHRlcl8xIiwicGFyc2VyIiwiZGVidWdfMSIsInNvY2tldF8xIiwidHlwZWRfZXZlbnRzXzEiLCJ1d3NfMSIsImNvcnNfMSIsImRlYnVnIiwiZGVmYXVsdCIsImNsaWVudFZlcnNpb24iLCJ2ZXJzaW9uIiwiZG90TWFwUmVnZXgiLCJTdHJpY3RFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsInNydiIsIm9wdHMiLCJfbnNwcyIsIk1hcCIsInBhcmVudE5zcHMiLCJwYXJlbnROYW1lc3BhY2VzRnJvbVJlZ0V4cCIsImxpc3RlbiIsImNvbm5lY3RUaW1lb3V0Iiwic2VydmVDbGllbnQiLCJfcGFyc2VyIiwiZW5jb2RlciIsIkVuY29kZXIiLCJjb25uZWN0aW9uU3RhdGVSZWNvdmVyeSIsImFzc2lnbiIsIm1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbiIsInNraXBNaWRkbGV3YXJlcyIsImFkYXB0ZXIiLCJTZXNzaW9uQXdhcmVBZGFwdGVyIiwiQWRhcHRlciIsImNsZWFudXBFbXB0eUNoaWxkTmFtZXNwYWNlcyIsInNvY2tldHMiLCJvZiIsImF0dGFjaCIsImNvcnMiLCJfY29yc01pZGRsZXdhcmUiLCJfb3B0cyIsImFyZ3VtZW50cyIsImxlbmd0aCIsIl9zZXJ2ZUNsaWVudCIsIl9jaGVja05hbWVzcGFjZSIsIm5hbWUiLCJhdXRoIiwiZm4iLCJzaXplIiwia2V5c0l0ZXJhdG9yIiwia2V5cyIsInJ1biIsIm5leHRGbiIsIm5leHQiLCJkb25lIiwiZXJyIiwiYWxsb3ciLCJoYXMiLCJuYW1lc3BhY2UiLCJjcmVhdGVDaGlsZCIsIl9wYXRoIiwicmVwbGFjZSIsImVzY2FwZWRQYXRoIiwiY2xpZW50UGF0aFJlZ2V4IiwiUmVnRXhwIiwiX2Nvbm5lY3RUaW1lb3V0IiwiX2FkYXB0ZXIiLCJuc3AiLCJ2YWx1ZXMiLCJfaW5pdEFkYXB0ZXIiLCJtc2ciLCJFcnJvciIsIk51bWJlciIsInBvcnQiLCJjcmVhdGVTZXJ2ZXIiLCJyZXEiLCJyZXMiLCJ3cml0ZUhlYWQiLCJlbmQiLCJpbml0RW5naW5lIiwiYXR0YWNoQXBwIiwiYXBwIiwiZW5naW5lIiwidVNlcnZlciIsImJpbmQiLCJ0ZXN0IiwiZ2V0VXJsIiwic2V0WWllbGQiLCJmaWxlbmFtZSIsImlzTWFwIiwidHlwZSIsImV4cGVjdGVkRXRhZyIsIndlYWtFdGFnIiwiZXRhZyIsImdldEhlYWRlciIsIndyaXRlU3RhdHVzIiwid3JpdGVIZWFkZXIiLCJmaWxlcGF0aCIsImpvaW4iLCJfX2Rpcm5hbWUiLCJzZXJ2ZUZpbGUiLCJwYXRjaEFkYXB0ZXIiLCJlaW8iLCJhdHRhY2hTZXJ2ZSIsImh0dHBTZXJ2ZXIiLCJldnMiLCJsaXN0ZW5lcnMiLCJzbGljZSIsInJlbW92ZUFsbExpc3RlbmVycyIsIm9uIiwidXJsIiwic2VydmUiLCJpIiwiaGVhZGVycyIsInNldEhlYWRlciIsInNlbmRGaWxlIiwicmVhZFN0cmVhbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJlbmNvZGluZyIsImVuY29kaW5ncyIsIm9uRXJyb3IiLCJwaXBlbGluZSIsImNyZWF0ZUJyb3RsaUNvbXByZXNzIiwiY3JlYXRlR3ppcCIsImNyZWF0ZURlZmxhdGUiLCJvbmNvbm5lY3Rpb24iLCJjb25uIiwiaWQiLCJjbGllbnQiLCJDbGllbnQiLCJwcm90b2NvbCIsImNvbm5lY3QiLCJwYXJlbnROc3AiLCJQYXJlbnROYW1lc3BhY2UiLCJzZXQiLCJTdHJpbmciLCJyZWdleCIsInBhcmVudE5hbWVzcGFjZSIsImVtaXRSZXNlcnZlZCIsImNsb3NlIiwiUHJvbWlzZSIsImFsbFNldHRsZWQiLCJtYXAiLCJmb3JFYWNoIiwic29ja2V0IiwiX29uY2xvc2UiLCJyZXN0b3JlQWRhcHRlciIsInVzZSIsInRvIiwicm9vbSIsImluIiwiZXhjZXB0Iiwic2VuZCIsImFyZ3MiLCJlbWl0Iiwid3JpdGUiLCJzZXJ2ZXJTaWRlRW1pdCIsImV2Iiwic2VydmVyU2lkZUVtaXRXaXRoQWNrIiwiYWxsU29ja2V0cyIsImNvbXByZXNzIiwidm9sYXRpbGUiLCJsb2NhbCIsInRpbWVvdXQiLCJmZXRjaFNvY2tldHMiLCJzb2NrZXRzSm9pbiIsInNvY2tldHNMZWF2ZSIsImRpc2Nvbm5lY3RTb2NrZXRzIiwiZW1pdHRlck1ldGhvZHMiLCJFdmVudEVtaXR0ZXIiLCJmaWx0ZXIiLCJrZXkiLCJhcHBseSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/namespace.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io/dist/namespace.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Namespace = exports.RESERVED_EVENTS = void 0;\nconst socket_1 = __webpack_require__(/*! ./socket */ \"(rsc)/./node_modules/socket.io/dist/socket.js\");\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ \"(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\");\nconst debug = (0, debug_1.default)(\"socket.io:namespace\");\nexports.RESERVED_EVENTS = new Set([\n    \"connect\",\n    \"connection\",\n    \"new_namespace\"\n]);\n/**\n * A Namespace is a communication channel that allows you to split the logic of your application over a single shared\n * connection.\n *\n * Each namespace has its own:\n *\n * - event handlers\n *\n * ```\n * io.of(\"/orders\").on(\"connection\", (socket) => {\n *   socket.on(\"order:list\", () => {});\n *   socket.on(\"order:create\", () => {});\n * });\n *\n * io.of(\"/users\").on(\"connection\", (socket) => {\n *   socket.on(\"user:list\", () => {});\n * });\n * ```\n *\n * - rooms\n *\n * ```\n * const orderNamespace = io.of(\"/orders\");\n *\n * orderNamespace.on(\"connection\", (socket) => {\n *   socket.join(\"room1\");\n *   orderNamespace.to(\"room1\").emit(\"hello\");\n * });\n *\n * const userNamespace = io.of(\"/users\");\n *\n * userNamespace.on(\"connection\", (socket) => {\n *   socket.join(\"room1\"); // distinct from the room in the \"orders\" namespace\n *   userNamespace.to(\"room1\").emit(\"hol\");\n * });\n * ```\n *\n * - middlewares\n *\n * ```\n * const orderNamespace = io.of(\"/orders\");\n *\n * orderNamespace.use((socket, next) => {\n *   // ensure the socket has access to the \"orders\" namespace\n * });\n *\n * const userNamespace = io.of(\"/users\");\n *\n * userNamespace.use((socket, next) => {\n *   // ensure the socket has access to the \"users\" namespace\n * });\n * ```\n */ class Namespace extends typed_events_1.StrictEventEmitter {\n    /**\n     * Namespace constructor.\n     *\n     * @param server instance\n     * @param name\n     */ constructor(server, name){\n        super();\n        /**\n         * A map of currently connected sockets.\n         */ this.sockets = new Map();\n        /**\n         * A map of currently connecting sockets.\n         */ this._preConnectSockets = new Map();\n        this._fns = [];\n        /** @private */ this._ids = 0;\n        this.server = server;\n        this.name = name;\n        this._initAdapter();\n    }\n    /**\n     * Initializes the `Adapter` for this nsp.\n     * Run upon changing adapter by `Server#adapter`\n     * in addition to the constructor.\n     *\n     * @private\n     */ _initAdapter() {\n        // @ts-ignore\n        this.adapter = new (this.server.adapter())(this);\n    }\n    /**\n     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.use((socket, next) => {\n     *   // ...\n     *   next();\n     * });\n     *\n     * @param fn - the middleware function\n     */ use(fn) {\n        this._fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming client.\n     *\n     * @param socket - the socket that will get added\n     * @param fn - last fn call in the middleware\n     * @private\n     */ run(socket, fn) {\n        if (!this._fns.length) return fn();\n        const fns = this._fns.slice(0);\n        function run(i) {\n            fns[i](socket, (err)=>{\n                // upon error, short-circuit\n                if (err) return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1]) return fn();\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the foo event will be broadcast to all connected clients in the room-101 room\n     * myNamespace.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms (a client will be notified at most once)\n     * myNamespace.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * myNamespace.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);\n    }\n    /**\n     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // disconnect all clients in the \"room-101\" room\n     * myNamespace.in(\"room-101\").disconnectSockets();\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     * myNamespace.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     * // with an array of rooms\n     * myNamespace.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     * // with multiple chained calls\n     * myNamespace.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);\n    }\n    /**\n     * Adds a new client.\n     *\n     * @return {Socket}\n     * @private\n     */ async _add(client, auth, fn) {\n        var _a;\n        debug(\"adding socket to nsp %s\", this.name);\n        const socket = await this._createSocket(client, auth);\n        this._preConnectSockets.set(socket.id, socket);\n        if (// @ts-ignore\n        ((_a = this.server.opts.connectionStateRecovery) === null || _a === void 0 ? void 0 : _a.skipMiddlewares) && socket.recovered && client.conn.readyState === \"open\") {\n            return this._doConnect(socket, fn);\n        }\n        this.run(socket, (err)=>{\n            process.nextTick(()=>{\n                if (\"open\" !== client.conn.readyState) {\n                    debug(\"next called after client was closed - ignoring socket\");\n                    socket._cleanup();\n                    return;\n                }\n                if (err) {\n                    debug(\"middleware error, sending CONNECT_ERROR packet to the client\");\n                    socket._cleanup();\n                    if (client.conn.protocol === 3) {\n                        return socket._error(err.data || err.message);\n                    } else {\n                        return socket._error({\n                            message: err.message,\n                            data: err.data\n                        });\n                    }\n                }\n                this._doConnect(socket, fn);\n            });\n        });\n    }\n    async _createSocket(client, auth) {\n        const sessionId = auth.pid;\n        const offset = auth.offset;\n        if (// @ts-ignore\n        this.server.opts.connectionStateRecovery && typeof sessionId === \"string\" && typeof offset === \"string\") {\n            let session;\n            try {\n                session = await this.adapter.restoreSession(sessionId, offset);\n            } catch (e) {\n                debug(\"error while restoring session: %s\", e);\n            }\n            if (session) {\n                debug(\"connection state recovered for sid %s\", session.sid);\n                return new socket_1.Socket(this, client, auth, session);\n            }\n        }\n        return new socket_1.Socket(this, client, auth);\n    }\n    _doConnect(socket, fn) {\n        this._preConnectSockets.delete(socket.id);\n        this.sockets.set(socket.id, socket);\n        // it's paramount that the internal `onconnect` logic\n        // fires before user-set events to prevent state order\n        // violations (such as a disconnection before the connection\n        // logic is complete)\n        socket._onconnect();\n        if (fn) fn(socket);\n        // fire user-set events\n        this.emitReserved(\"connect\", socket);\n        this.emitReserved(\"connection\", socket);\n    }\n    /**\n     * Removes a client. Called by each `Socket`.\n     *\n     * @private\n     */ _remove(socket) {\n        this.sockets.delete(socket.id) || this._preConnectSockets.delete(socket.id);\n    }\n    /**\n     * Emits to all connected clients.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * myNamespace.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the clients\n     * myNamespace.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @return Always true\n     */ emit(ev, ...args) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.send(\"hello\");\n     *\n     * // this is equivalent to\n     * myNamespace.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */ send(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event to all clients. Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */ write(...args) {\n        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.\n        // if you specify the EmitEvents, the type of args will be never.\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a message to the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.serverSideEmit(\"hello\", \"world\");\n     *\n     * myNamespace.on(\"hello\", (arg1) => {\n     *   console.log(arg1); // prints \"world\"\n     * });\n     *\n     * // acknowledgements (without binary content) are supported too:\n     * myNamespace.serverSideEmit(\"ping\", (err, responses) => {\n     *  if (err) {\n     *     // some servers did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per server (except the current one)\n     *   }\n     * });\n     *\n     * myNamespace.on(\"ping\", (cb) => {\n     *   cb(\"pong\");\n     * });\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     */ serverSideEmit(ev, ...args) {\n        if (exports.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        args.unshift(ev);\n        this.adapter.serverSideEmit(args);\n        return true;\n    }\n    /**\n     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * try {\n     *   const responses = await myNamespace.serverSideEmitWithAck(\"ping\");\n     *   console.log(responses); // one response per server (except the current one)\n     * } catch (e) {\n     *   // some servers did not acknowledge the event in the given delay\n     * }\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments\n     *\n     * @return a Promise that will be fulfilled when all servers have acknowledged the event\n     */ serverSideEmitWithAck(ev, ...args) {\n        return new Promise((resolve, reject)=>{\n            args.push((err, responses)=>{\n                if (err) {\n                    err.responses = responses;\n                    return reject(err);\n                } else {\n                    return resolve(responses);\n                }\n            });\n            this.serverSideEmit(ev, ...args);\n        });\n    }\n    /**\n     * Called when a packet is received from another Socket.IO server\n     *\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     *\n     * @private\n     */ _onServerSideEmit(args) {\n        super.emitUntyped.apply(this, args);\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @deprecated this method will be removed in the next major release, please use {@link Namespace#serverSideEmit} or\n     * {@link Namespace#fetchSockets} instead.\n     */ allSockets() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */ compress(compress) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.volatile.emit(\"hello\"); // the clients may or may not receive it\n     *\n     * @return self\n     */ get volatile() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // the foo event will be broadcast to all connected clients on this node\n     * myNamespace.local.emit(\"foo\", \"bar\");\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).local;\n    }\n    /**\n     * Adds a timeout in milliseconds for the next operation.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * myNamespace.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   if (err) {\n     *     // some clients did not acknowledge the event in the given delay\n     *   } else {\n     *     console.log(responses); // one response per client\n     *   }\n     * });\n     *\n     * @param timeout\n     */ timeout(timeout) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);\n    }\n    /**\n     * Returns the matching socket instances.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // return all Socket instances\n     * const sockets = await myNamespace.fetchSockets();\n     *\n     * // return all Socket instances in the \"room1\" room\n     * const sockets = await myNamespace.in(\"room1\").fetchSockets();\n     *\n     * for (const socket of sockets) {\n     *   console.log(socket.id);\n     *   console.log(socket.handshake);\n     *   console.log(socket.rooms);\n     *   console.log(socket.data);\n     *\n     *   socket.emit(\"hello\");\n     *   socket.join(\"room1\");\n     *   socket.leave(\"room2\");\n     *   socket.disconnect();\n     * }\n     */ fetchSockets() {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances join the \"room1\" room\n     * myNamespace.socketsJoin(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room join the \"room2\" and \"room3\" rooms\n     * myNamespace.in(\"room1\").socketsJoin([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsJoin(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances leave the \"room1\" room\n     * myNamespace.socketsLeave(\"room1\");\n     *\n     * // make all socket instances in the \"room1\" room leave the \"room2\" and \"room3\" rooms\n     * myNamespace.in(\"room1\").socketsLeave([\"room2\", \"room3\"]);\n     *\n     * @param room - a room, or an array of rooms\n     */ socketsLeave(room) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);\n    }\n    /**\n     * Makes the matching socket instances disconnect.\n     *\n     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.\n     *\n     * @example\n     * const myNamespace = io.of(\"/my-namespace\");\n     *\n     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)\n     * myNamespace.disconnectSockets();\n     *\n     * // make all socket instances in the \"room1\" room disconnect and close the underlying connections\n     * myNamespace.in(\"room1\").disconnectSockets(true);\n     *\n     * @param close - whether to close the underlying connection\n     */ disconnectSockets(close = false) {\n        return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);\n    }\n}\nexports.Namespace = Namespace;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvbmFtZXNwYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUNuRCxNQUFNSSxXQUFXQyxtQkFBT0EsQ0FBQywrREFBVTtBQUNuQyxNQUFNQyxpQkFBaUJELG1CQUFPQSxDQUFDLDJFQUFnQjtBQUMvQyxNQUFNRSxVQUFVWixnQkFBZ0JVLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9DLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUMsdUZBQXNCO0FBQzNELE1BQU1JLFFBQVEsQ0FBQyxHQUFHRixRQUFRRyxPQUFPLEVBQUU7QUFDbkNWLHVCQUF1QixHQUFHLElBQUlXLElBQUk7SUFBQztJQUFXO0lBQWM7Q0FBZ0I7QUFDNUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvREMsR0FDRCxNQUFNVCxrQkFBa0JJLGVBQWVNLGtCQUFrQjtJQUNyRDs7Ozs7S0FLQyxHQUNEQyxZQUFZQyxNQUFNLEVBQUVDLElBQUksQ0FBRTtRQUN0QixLQUFLO1FBQ0w7O1NBRUMsR0FDRCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJQztRQUNuQjs7U0FFQyxHQUNELElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsSUFBSUQ7UUFDOUIsSUFBSSxDQUFDRSxJQUFJLEdBQUcsRUFBRTtRQUNkLGFBQWEsR0FDYixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ04sTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsSUFB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T0FBTyxFQUFFdUUsT0FBTyxDQUFDQTtJQUM1RTtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBeUJDLEdBQ0RDLGVBQWU7UUFDWCxPQUFPLElBQUl0RixxQkFBcUIyQixpQkFBaUIsQ0FBQyxJQUFJLENBQUNiLE9BQU8sRUFBRXdFLFlBQVk7SUFDaEY7SUFDQTs7Ozs7Ozs7Ozs7Ozs7O0tBZUMsR0FDREMsWUFBWTdELElBQUksRUFBRTtRQUNkLE9BQU8sSUFBSTFCLHFCQUFxQjJCLGlCQUFpQixDQUFDLElBQUksQ0FBQ2IsT0FBTyxFQUFFeUUsV0FBVyxDQUFDN0Q7SUFDaEY7SUFDQTs7Ozs7Ozs7Ozs7Ozs7O0tBZUMsR0FDRDhELGFBQWE5RCxJQUFJLEVBQUU7UUFDZixPQUFPLElBQUkxQixxQkFBcUIyQixpQkFBaUIsQ0FBQyxJQUFJLENBQUNiLE9BQU8sRUFBRTBFLFlBQVksQ0FBQzlEO0lBQ2pGO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0QrRCxrQkFBa0JDLFFBQVEsS0FBSyxFQUFFO1FBQzdCLE9BQU8sSUFBSTFGLHFCQUFxQjJCLGlCQUFpQixDQUFDLElBQUksQ0FBQ2IsT0FBTyxFQUFFMkUsaUJBQWlCLENBQUNDO0lBQ3RGO0FBQ0o7QUFDQWxHLGlCQUFpQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL21lZGNvZGVzX2FwcC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9uYW1lc3BhY2UuanM/Yjk3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmFtZXNwYWNlID0gZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMgPSB2b2lkIDA7XG5jb25zdCBzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3NvY2tldFwiKTtcbmNvbnN0IHR5cGVkX2V2ZW50c18xID0gcmVxdWlyZShcIi4vdHlwZWQtZXZlbnRzXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgYnJvYWRjYXN0X29wZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9icm9hZGNhc3Qtb3BlcmF0b3JcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOm5hbWVzcGFjZVwiKTtcbmV4cG9ydHMuUkVTRVJWRURfRVZFTlRTID0gbmV3IFNldChbXCJjb25uZWN0XCIsIFwiY29ubmVjdGlvblwiLCBcIm5ld19uYW1lc3BhY2VcIl0pO1xuLyoqXG4gKiBBIE5hbWVzcGFjZSBpcyBhIGNvbW11bmljYXRpb24gY2hhbm5lbCB0aGF0IGFsbG93cyB5b3UgdG8gc3BsaXQgdGhlIGxvZ2ljIG9mIHlvdXIgYXBwbGljYXRpb24gb3ZlciBhIHNpbmdsZSBzaGFyZWRcbiAqIGNvbm5lY3Rpb24uXG4gKlxuICogRWFjaCBuYW1lc3BhY2UgaGFzIGl0cyBvd246XG4gKlxuICogLSBldmVudCBoYW5kbGVyc1xuICpcbiAqIGBgYFxuICogaW8ub2YoXCIvb3JkZXJzXCIpLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gKiAgIHNvY2tldC5vbihcIm9yZGVyOmxpc3RcIiwgKCkgPT4ge30pO1xuICogICBzb2NrZXQub24oXCJvcmRlcjpjcmVhdGVcIiwgKCkgPT4ge30pO1xuICogfSk7XG4gKlxuICogaW8ub2YoXCIvdXNlcnNcIikub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAqICAgc29ja2V0Lm9uKFwidXNlcjpsaXN0XCIsICgpID0+IHt9KTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogLSByb29tc1xuICpcbiAqIGBgYFxuICogY29uc3Qgb3JkZXJOYW1lc3BhY2UgPSBpby5vZihcIi9vcmRlcnNcIik7XG4gKlxuICogb3JkZXJOYW1lc3BhY2Uub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAqICAgc29ja2V0LmpvaW4oXCJyb29tMVwiKTtcbiAqICAgb3JkZXJOYW1lc3BhY2UudG8oXCJyb29tMVwiKS5lbWl0KFwiaGVsbG9cIik7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCB1c2VyTmFtZXNwYWNlID0gaW8ub2YoXCIvdXNlcnNcIik7XG4gKlxuICogdXNlck5hbWVzcGFjZS5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBzb2NrZXQuam9pbihcInJvb20xXCIpOyAvLyBkaXN0aW5jdCBmcm9tIHRoZSByb29tIGluIHRoZSBcIm9yZGVyc1wiIG5hbWVzcGFjZVxuICogICB1c2VyTmFtZXNwYWNlLnRvKFwicm9vbTFcIikuZW1pdChcImhvbMOgXCIpO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiAtIG1pZGRsZXdhcmVzXG4gKlxuICogYGBgXG4gKiBjb25zdCBvcmRlck5hbWVzcGFjZSA9IGlvLm9mKFwiL29yZGVyc1wiKTtcbiAqXG4gKiBvcmRlck5hbWVzcGFjZS51c2UoKHNvY2tldCwgbmV4dCkgPT4ge1xuICogICAvLyBlbnN1cmUgdGhlIHNvY2tldCBoYXMgYWNjZXNzIHRvIHRoZSBcIm9yZGVyc1wiIG5hbWVzcGFjZVxuICogfSk7XG4gKlxuICogY29uc3QgdXNlck5hbWVzcGFjZSA9IGlvLm9mKFwiL3VzZXJzXCIpO1xuICpcbiAqIHVzZXJOYW1lc3BhY2UudXNlKChzb2NrZXQsIG5leHQpID0+IHtcbiAqICAgLy8gZW5zdXJlIHRoZSBzb2NrZXQgaGFzIGFjY2VzcyB0byB0aGUgXCJ1c2Vyc1wiIG5hbWVzcGFjZVxuICogfSk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgTmFtZXNwYWNlIGV4dGVuZHMgdHlwZWRfZXZlbnRzXzEuU3RyaWN0RXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBOYW1lc3BhY2UgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VydmVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIGN1cnJlbnRseSBjb25uZWN0ZWQgc29ja2V0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ja2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIGN1cnJlbnRseSBjb25uZWN0aW5nIHNvY2tldHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcmVDb25uZWN0U29ja2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZm5zID0gW107XG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICB0aGlzLl9pZHMgPSAwO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5faW5pdEFkYXB0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGBBZGFwdGVyYCBmb3IgdGhpcyBuc3AuXG4gICAgICogUnVuIHVwb24gY2hhbmdpbmcgYWRhcHRlciBieSBgU2VydmVyI2FkYXB0ZXJgXG4gICAgICogaW4gYWRkaXRpb24gdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEFkYXB0ZXIoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gbmV3ICh0aGlzLnNlcnZlci5hZGFwdGVyKCkpKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBtaWRkbGV3YXJlLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBleGVjdXRlZCBmb3IgZXZlcnkgaW5jb21pbmcge0BsaW5rIFNvY2tldH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2UudXNlKChzb2NrZXQsIG5leHQpID0+IHtcbiAgICAgKiAgIC8vIC4uLlxuICAgICAqICAgbmV4dCgpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gdGhlIG1pZGRsZXdhcmUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICB1c2UoZm4pIHtcbiAgICAgICAgdGhpcy5fZm5zLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIG1pZGRsZXdhcmUgZm9yIGFuIGluY29taW5nIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb2NrZXQgLSB0aGUgc29ja2V0IHRoYXQgd2lsbCBnZXQgYWRkZWRcbiAgICAgKiBAcGFyYW0gZm4gLSBsYXN0IGZuIGNhbGwgaW4gdGhlIG1pZGRsZXdhcmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bihzb2NrZXQsIGZuKSB7XG4gICAgICAgIGlmICghdGhpcy5fZm5zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICBjb25zdCBmbnMgPSB0aGlzLl9mbnMuc2xpY2UoMCk7XG4gICAgICAgIGZ1bmN0aW9uIHJ1bihpKSB7XG4gICAgICAgICAgICBmbnNbaV0oc29ja2V0LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdXBvbiBlcnJvciwgc2hvcnQtY2lyY3VpdFxuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihlcnIpO1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1pZGRsZXdhcmUgbGVmdCwgc3VtbW9uIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKCFmbnNbaSArIDFdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgICAgICAvLyBnbyBvbiB0byBuZXh0XG4gICAgICAgICAgICAgICAgcnVuKGkgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJ1bigwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBpbiB0aGUg4oCccm9vbS0xMDHigJ0gcm9vbVxuICAgICAqIG15TmFtZXNwYWNlLnRvKFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYXJyYXkgb2Ygcm9vbXMgKGEgY2xpZW50IHdpbGwgYmUgbm90aWZpZWQgYXQgbW9zdCBvbmNlKVxuICAgICAqIG15TmFtZXNwYWNlLnRvKFtcInJvb20tMTAxXCIsIFwicm9vbS0xMDJcIl0pLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIG11bHRpcGxlIGNoYWluZWQgY2FsbHNcbiAgICAgKiBteU5hbWVzcGFjZS50byhcInJvb20tMTAxXCIpLnRvKFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS50byhyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy4gU2ltaWxhciB0byBgdG8oKWAsIGJ1dCBtaWdodCBmZWVsIGNsZWFyZXIgaW4gc29tZSBjYXNlczpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyBkaXNjb25uZWN0IGFsbCBjbGllbnRzIGluIHRoZSBcInJvb20tMTAxXCIgcm9vbVxuICAgICAqIG15TmFtZXNwYWNlLmluKFwicm9vbS0xMDFcIikuZGlzY29ubmVjdFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBpbihyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjbHVkZXMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gdGhlIFwiZm9vXCIgZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzLCBleGNlcHQgdGhlIG9uZXMgdGhhdCBhcmUgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tXG4gICAgICogbXlOYW1lc3BhY2UuZXhjZXB0KFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBteU5hbWVzcGFjZS5leGNlcHQoW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggbXVsdGlwbGUgY2hhaW5lZCBjYWxsc1xuICAgICAqIG15TmFtZXNwYWNlLmV4Y2VwdChcInJvb20tMTAxXCIpLmV4Y2VwdChcInJvb20tMTAyXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZXhjZXB0KHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmV4Y2VwdChyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfYWRkKGNsaWVudCwgYXV0aCwgZm4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBkZWJ1ZyhcImFkZGluZyBzb2NrZXQgdG8gbnNwICVzXCIsIHRoaXMubmFtZSk7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IGF3YWl0IHRoaXMuX2NyZWF0ZVNvY2tldChjbGllbnQsIGF1dGgpO1xuICAgICAgICB0aGlzLl9wcmVDb25uZWN0U29ja2V0cy5zZXQoc29ja2V0LmlkLCBzb2NrZXQpO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgKChfYSA9IHRoaXMuc2VydmVyLm9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5za2lwTWlkZGxld2FyZXMpICYmXG4gICAgICAgICAgICBzb2NrZXQucmVjb3ZlcmVkICYmXG4gICAgICAgICAgICBjbGllbnQuY29ubi5yZWFkeVN0YXRlID09PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvQ29ubmVjdChzb2NrZXQsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bihzb2NrZXQsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcIm9wZW5cIiAhPT0gY2xpZW50LmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIm5leHQgY2FsbGVkIGFmdGVyIGNsaWVudCB3YXMgY2xvc2VkIC0gaWdub3Jpbmcgc29ja2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuX2NsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwibWlkZGxld2FyZSBlcnJvciwgc2VuZGluZyBDT05ORUNUX0VSUk9SIHBhY2tldCB0byB0aGUgY2xpZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuX2NsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWVudC5jb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0Ll9lcnJvcihlcnIuZGF0YSB8fCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0Ll9lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZXJyLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kb0Nvbm5lY3Qoc29ja2V0LCBmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVTb2NrZXQoY2xpZW50LCBhdXRoKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IGF1dGgucGlkO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBhdXRoLm9mZnNldDtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuc2VydmVyLm9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZXNzaW9uSWQgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvZmZzZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBzZXNzaW9uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gYXdhaXQgdGhpcy5hZGFwdGVyLnJlc3RvcmVTZXNzaW9uKHNlc3Npb25JZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJlcnJvciB3aGlsZSByZXN0b3Jpbmcgc2Vzc2lvbjogJXNcIiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBzdGF0ZSByZWNvdmVyZWQgZm9yIHNpZCAlc1wiLCBzZXNzaW9uLnNpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzb2NrZXRfMS5Tb2NrZXQodGhpcywgY2xpZW50LCBhdXRoLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNvY2tldF8xLlNvY2tldCh0aGlzLCBjbGllbnQsIGF1dGgpO1xuICAgIH1cbiAgICBfZG9Db25uZWN0KHNvY2tldCwgZm4pIHtcbiAgICAgICAgdGhpcy5fcHJlQ29ubmVjdFNvY2tldHMuZGVsZXRlKHNvY2tldC5pZCk7XG4gICAgICAgIHRoaXMuc29ja2V0cy5zZXQoc29ja2V0LmlkLCBzb2NrZXQpO1xuICAgICAgICAvLyBpdCdzIHBhcmFtb3VudCB0aGF0IHRoZSBpbnRlcm5hbCBgb25jb25uZWN0YCBsb2dpY1xuICAgICAgICAvLyBmaXJlcyBiZWZvcmUgdXNlci1zZXQgZXZlbnRzIHRvIHByZXZlbnQgc3RhdGUgb3JkZXJcbiAgICAgICAgLy8gdmlvbGF0aW9ucyAoc3VjaCBhcyBhIGRpc2Nvbm5lY3Rpb24gYmVmb3JlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIGxvZ2ljIGlzIGNvbXBsZXRlKVxuICAgICAgICBzb2NrZXQuX29uY29ubmVjdCgpO1xuICAgICAgICBpZiAoZm4pXG4gICAgICAgICAgICBmbihzb2NrZXQpO1xuICAgICAgICAvLyBmaXJlIHVzZXItc2V0IGV2ZW50c1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3RcIiwgc29ja2V0KTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0aW9uXCIsIHNvY2tldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjbGllbnQuIENhbGxlZCBieSBlYWNoIGBTb2NrZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldHMuZGVsZXRlKHNvY2tldC5pZCkgfHwgdGhpcy5fcHJlQ29ubmVjdFNvY2tldHMuZGVsZXRlKHNvY2tldC5pZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS5lbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqIC8vIGFsbCBzZXJpYWxpemFibGUgZGF0YXN0cnVjdHVyZXMgYXJlIHN1cHBvcnRlZCAobm8gbmVlZCB0byBjYWxsIEpTT04uc3RyaW5naWZ5KVxuICAgICAqIG15TmFtZXNwYWNlLmVtaXQoXCJoZWxsb1wiLCAxLCBcIjJcIiwgeyAzOiBbXCI0XCJdLCA1OiBVaW50OEFycmF5LmZyb20oWzZdKSB9KTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gdGhlIGNsaWVudHNcbiAgICAgKiBteU5hbWVzcGFjZS50aW1lb3V0KDEwMDApLmVtaXQoXCJzb21lLWV2ZW50XCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyBzb21lIGNsaWVudHMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9IGVsc2Uge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIGNsaWVudFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgdHJ1ZVxuICAgICAqL1xuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudCB0byBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1pbWljcyB0aGUgV2ViU29ja2V0LnNlbmQoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXQvc2VuZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLnNlbmQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIC8vIHRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAqIG15TmFtZXNwYWNlLmVtaXQoXCJtZXNzYWdlXCIsIFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBzZW5kKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVGhpcyB0eXBlLWNhc3QgaXMgbmVlZGVkIGJlY2F1c2UgRW1pdEV2ZW50cyBsaWtlbHkgZG9lc24ndCBoYXZlIGBtZXNzYWdlYCBhcyBhIGtleS5cbiAgICAgICAgLy8gaWYgeW91IHNwZWNpZnkgdGhlIEVtaXRFdmVudHMsIHRoZSB0eXBlIG9mIGFyZ3Mgd2lsbCBiZSBuZXZlci5cbiAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50IHRvIGFsbCBjbGllbnRzLiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC4gQWxpYXMgb2Yge0BsaW5rIHNlbmR9LlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgd3JpdGUoLi4uYXJncykge1xuICAgICAgICAvLyBUaGlzIHR5cGUtY2FzdCBpcyBuZWVkZWQgYmVjYXVzZSBFbWl0RXZlbnRzIGxpa2VseSBkb2Vzbid0IGhhdmUgYG1lc3NhZ2VgIGFzIGEga2V5LlxuICAgICAgICAvLyBpZiB5b3Ugc3BlY2lmeSB0aGUgRW1pdEV2ZW50cywgdGhlIHR5cGUgb2YgYXJncyB3aWxsIGJlIG5ldmVyLlxuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBvdGhlciBTb2NrZXQuSU8gc2VydmVycyBvZiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS5zZXJ2ZXJTaWRlRW1pdChcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiBteU5hbWVzcGFjZS5vbihcImhlbGxvXCIsIChhcmcxKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhhcmcxKTsgLy8gcHJpbnRzIFwid29ybGRcIlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gYWNrbm93bGVkZ2VtZW50cyAod2l0aG91dCBiaW5hcnkgY29udGVudCkgYXJlIHN1cHBvcnRlZCB0b286XG4gICAgICogbXlOYW1lc3BhY2Uuc2VydmVyU2lkZUVtaXQoXCJwaW5nXCIsIChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAqICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgc2VydmVycyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgc2VydmVyIChleGNlcHQgdGhlIGN1cnJlbnQgb25lKVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogbXlOYW1lc3BhY2Uub24oXCJwaW5nXCIsIChjYikgPT4ge1xuICAgICAqICAgY2IoXCJwb25nXCIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2IC0gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFuIGFycmF5IG9mIGFyZ3VtZW50cywgd2hpY2ggbWF5IGluY2x1ZGUgYW4gYWNrbm93bGVkZ2VtZW50IGNhbGxiYWNrIGF0IHRoZSBlbmRcbiAgICAgKi9cbiAgICBzZXJ2ZXJTaWRlRW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMuaGFzKGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7U3RyaW5nKGV2KX1cIiBpcyBhIHJlc2VydmVkIGV2ZW50IG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnVuc2hpZnQoZXYpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIuc2VydmVyU2lkZUVtaXQoYXJncyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgYW5kIGV4cGVjdCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogdHJ5IHtcbiAgICAgKiAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IG15TmFtZXNwYWNlLnNlcnZlclNpZGVFbWl0V2l0aEFjayhcInBpbmdcIik7XG4gICAgICogICBjb25zb2xlLmxvZyhyZXNwb25zZXMpOyAvLyBvbmUgcmVzcG9uc2UgcGVyIHNlcnZlciAoZXhjZXB0IHRoZSBjdXJyZW50IG9uZSlcbiAgICAgKiB9IGNhdGNoIChlKSB7XG4gICAgICogICAvLyBzb21lIHNlcnZlcnMgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogfVxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IC0gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFuIGFycmF5IG9mIGFyZ3VtZW50c1xuICAgICAqXG4gICAgICogQHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIGFsbCBzZXJ2ZXJzIGhhdmUgYWNrbm93bGVkZ2VkIHRoZSBldmVudFxuICAgICAqL1xuICAgIHNlcnZlclNpZGVFbWl0V2l0aEFjayhldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYXJncy5wdXNoKChlcnIsIHJlc3BvbnNlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnJlc3BvbnNlcyA9IHJlc3BvbnNlcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyU2lkZUVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBwYWNrZXQgaXMgcmVjZWl2ZWQgZnJvbSBhbm90aGVyIFNvY2tldC5JTyBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzLCB3aGljaCBtYXkgaW5jbHVkZSBhbiBhY2tub3dsZWRnZW1lbnQgY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25TZXJ2ZXJTaWRlRW1pdChhcmdzKSB7XG4gICAgICAgIHN1cGVyLmVtaXRVbnR5cGVkLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UsIHBsZWFzZSB1c2Uge0BsaW5rIE5hbWVzcGFjZSNzZXJ2ZXJTaWRlRW1pdH0gb3JcbiAgICAgKiB7QGxpbmsgTmFtZXNwYWNlI2ZldGNoU29ja2V0c30gaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhbGxTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuYWxsU29ja2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLmNvbXByZXNzKGZhbHNlKS5lbWl0KFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGNvbXByZXNzKGNvbXByZXNzKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5jb21wcmVzcyhjb21wcmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgbWF5IGJlIGxvc3QgaWYgdGhlIGNsaWVudCBpcyBub3QgcmVhZHkgdG9cbiAgICAgKiByZWNlaXZlIG1lc3NhZ2VzIChiZWNhdXNlIG9mIG5ldHdvcmsgc2xvd25lc3Mgb3Igb3RoZXIgaXNzdWVzLCBvciBiZWNhdXNlIHRoZXnigJlyZSBjb25uZWN0ZWQgdGhyb3VnaCBsb25nIHBvbGxpbmdcbiAgICAgKiBhbmQgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHJlcXVlc3QtcmVzcG9uc2UgY3ljbGUpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLnZvbGF0aWxlLmVtaXQoXCJoZWxsb1wiKTsgLy8gdGhlIGNsaWVudHMgbWF5IG9yIG1heSBub3QgcmVjZWl2ZSBpdFxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikudm9sYXRpbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgd2lsbCBvbmx5IGJlIGJyb2FkY2FzdCB0byB0aGUgY3VycmVudCBub2RlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIHRoZSDigJxmb2/igJ0gZXZlbnQgd2lsbCBiZSBicm9hZGNhc3QgdG8gYWxsIGNvbm5lY3RlZCBjbGllbnRzIG9uIHRoaXMgbm9kZVxuICAgICAqIG15TmFtZXNwYWNlLmxvY2FsLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZ2V0IGxvY2FsKCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikubG9jYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIG5leHQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIG15TmFtZXNwYWNlLnRpbWVvdXQoMTAwMCkuZW1pdChcInNvbWUtZXZlbnRcIiwgKGVyciwgcmVzcG9uc2VzKSA9PiB7XG4gICAgICogICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHNvbWUgY2xpZW50cyBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlcyk7IC8vIG9uZSByZXNwb25zZSBwZXIgY2xpZW50XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dFxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikudGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybiBhbGwgU29ja2V0IGluc3RhbmNlc1xuICAgICAqIGNvbnN0IHNvY2tldHMgPSBhd2FpdCBteU5hbWVzcGFjZS5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybiBhbGwgU29ja2V0IGluc3RhbmNlcyBpbiB0aGUgXCJyb29tMVwiIHJvb21cbiAgICAgKiBjb25zdCBzb2NrZXRzID0gYXdhaXQgbXlOYW1lc3BhY2UuaW4oXCJyb29tMVwiKS5mZXRjaFNvY2tldHMoKTtcbiAgICAgKlxuICAgICAqIGZvciAoY29uc3Qgc29ja2V0IG9mIHNvY2tldHMpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5pZCk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuaGFuZHNoYWtlKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5yb29tcyk7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuZGF0YSk7XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5lbWl0KFwiaGVsbG9cIik7XG4gICAgICogICBzb2NrZXQuam9pbihcInJvb20xXCIpO1xuICAgICAqICAgc29ja2V0LmxlYXZlKFwicm9vbTJcIik7XG4gICAgICogICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBmZXRjaFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5mZXRjaFNvY2tldHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgc3BlY2lmaWVkIHJvb21zLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgYWxzbyB3b3JrcyB3aXRoaW4gYSBjbHVzdGVyIG9mIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCB3aXRoIGEgY29tcGF0aWJsZSB7QGxpbmsgQWRhcHRlcn0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IG15TmFtZXNwYWNlID0gaW8ub2YoXCIvbXktbmFtZXNwYWNlXCIpO1xuICAgICAqXG4gICAgICogLy8gbWFrZSBhbGwgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBcInJvb20xXCIgcm9vbVxuICAgICAqIG15TmFtZXNwYWNlLnNvY2tldHNKb2luKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBqb2luIHRoZSBcInJvb20yXCIgYW5kIFwicm9vbTNcIiByb29tc1xuICAgICAqIG15TmFtZXNwYWNlLmluKFwicm9vbTFcIikuc29ja2V0c0pvaW4oW1wicm9vbTJcIiwgXCJyb29tM1wiXSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKi9cbiAgICBzb2NrZXRzSm9pbihyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5zb2NrZXRzSm9pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGFsc28gd29ya3Mgd2l0aGluIGEgY2x1c3RlciBvZiBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgd2l0aCBhIGNvbXBhdGlibGUge0BsaW5rIEFkYXB0ZXJ9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBteU5hbWVzcGFjZSA9IGlvLm9mKFwiL215LW5hbWVzcGFjZVwiKTtcbiAgICAgKlxuICAgICAqIC8vIG1ha2UgYWxsIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIFwicm9vbTFcIiByb29tXG4gICAgICogbXlOYW1lc3BhY2Uuc29ja2V0c0xlYXZlKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBsZWF2ZSB0aGUgXCJyb29tMlwiIGFuZCBcInJvb20zXCIgcm9vbXNcbiAgICAgKiBteU5hbWVzcGFjZS5pbihcInJvb20xXCIpLnNvY2tldHNMZWF2ZShbXCJyb29tMlwiLCBcInJvb20zXCJdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqL1xuICAgIHNvY2tldHNMZWF2ZShyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5zb2NrZXRzTGVhdmUocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3QuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIHdpdGhpbiBhIGNsdXN0ZXIgb2YgbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIHdpdGggYSBjb21wYXRpYmxlIHtAbGluayBBZGFwdGVyfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgbXlOYW1lc3BhY2UgPSBpby5vZihcIi9teS1uYW1lc3BhY2VcIik7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3QgKHRoZSBjb25uZWN0aW9ucyBtaWdodCBiZSBrZXB0IGFsaXZlIGZvciBvdGhlciBuYW1lc3BhY2VzKVxuICAgICAqIG15TmFtZXNwYWNlLmRpc2Nvbm5lY3RTb2NrZXRzKCk7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGFsbCBzb2NrZXQgaW5zdGFuY2VzIGluIHRoZSBcInJvb20xXCIgcm9vbSBkaXNjb25uZWN0IGFuZCBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uc1xuICAgICAqIG15TmFtZXNwYWNlLmluKFwicm9vbTFcIikuZGlzY29ubmVjdFNvY2tldHModHJ1ZSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2xvc2UgLSB3aGV0aGVyIHRvIGNsb3NlIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0U29ja2V0cyhjbG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5kaXNjb25uZWN0U29ja2V0cyhjbG9zZSk7XG4gICAgfVxufVxuZXhwb3J0cy5OYW1lc3BhY2UgPSBOYW1lc3BhY2U7XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTmFtZXNwYWNlIiwiUkVTRVJWRURfRVZFTlRTIiwic29ja2V0XzEiLCJyZXF1aXJlIiwidHlwZWRfZXZlbnRzXzEiLCJkZWJ1Z18xIiwiYnJvYWRjYXN0X29wZXJhdG9yXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJTZXQiLCJTdHJpY3RFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsInNlcnZlciIsIm5hbWUiLCJzb2NrZXRzIiwiTWFwIiwiX3ByZUNvbm5lY3RTb2NrZXRzIiwiX2ZucyIsIl9pZHMiLCJfaW5pdEFkYXB0ZXIiLCJhZGFwdGVyIiwidXNlIiwiZm4iLCJwdXNoIiwicnVuIiwic29ja2V0IiwibGVuZ3RoIiwiZm5zIiwic2xpY2UiLCJpIiwiZXJyIiwidG8iLCJyb29tIiwiQnJvYWRjYXN0T3BlcmF0b3IiLCJpbiIsImV4Y2VwdCIsIl9hZGQiLCJjbGllbnQiLCJhdXRoIiwiX2EiLCJfY3JlYXRlU29ja2V0Iiwic2V0IiwiaWQiLCJvcHRzIiwiY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkiLCJza2lwTWlkZGxld2FyZXMiLCJyZWNvdmVyZWQiLCJjb25uIiwicmVhZHlTdGF0ZSIsIl9kb0Nvbm5lY3QiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJfY2xlYW51cCIsInByb3RvY29sIiwiX2Vycm9yIiwiZGF0YSIsIm1lc3NhZ2UiLCJzZXNzaW9uSWQiLCJwaWQiLCJvZmZzZXQiLCJzZXNzaW9uIiwicmVzdG9yZVNlc3Npb24iLCJlIiwic2lkIiwiU29ja2V0IiwiZGVsZXRlIiwiX29uY29ubmVjdCIsImVtaXRSZXNlcnZlZCIsIl9yZW1vdmUiLCJlbWl0IiwiZXYiLCJhcmdzIiwic2VuZCIsIndyaXRlIiwic2VydmVyU2lkZUVtaXQiLCJoYXMiLCJFcnJvciIsIlN0cmluZyIsInVuc2hpZnQiLCJzZXJ2ZXJTaWRlRW1pdFdpdGhBY2siLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlc3BvbnNlcyIsIl9vblNlcnZlclNpZGVFbWl0IiwiZW1pdFVudHlwZWQiLCJhcHBseSIsImFsbFNvY2tldHMiLCJjb21wcmVzcyIsInZvbGF0aWxlIiwibG9jYWwiLCJ0aW1lb3V0IiwiZmV0Y2hTb2NrZXRzIiwic29ja2V0c0pvaW4iLCJzb2NrZXRzTGVhdmUiLCJkaXNjb25uZWN0U29ja2V0cyIsImNsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/namespace.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/parent-namespace.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io/dist/parent-namespace.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ParentNamespace = void 0;\nconst namespace_1 = __webpack_require__(/*! ./namespace */ \"(rsc)/./node_modules/socket.io/dist/namespace.js\");\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:parent-namespace\");\n/**\n * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either\n * with a regular expression or with a function.\n *\n * @example\n * const parentNamespace = io.of(/\\/dynamic-\\d+/);\n *\n * parentNamespace.on(\"connection\", (socket) => {\n *   const childNamespace = socket.nsp;\n * }\n *\n * // will reach all the clients that are in one of the child namespaces, like \"/dynamic-101\"\n * parentNamespace.emit(\"hello\", \"world\");\n *\n */ class ParentNamespace extends namespace_1.Namespace {\n    constructor(server){\n        super(server, \"/_\" + ParentNamespace.count++);\n        this.children = new Set();\n    }\n    /**\n     * @private\n     */ _initAdapter() {\n        this.adapter = new ParentBroadcastAdapter(this);\n    }\n    emit(ev, ...args) {\n        this.children.forEach((nsp)=>{\n            nsp.emit(ev, ...args);\n        });\n        return true;\n    }\n    createChild(name) {\n        debug(\"creating child namespace %s\", name);\n        const namespace = new namespace_1.Namespace(this.server, name);\n        this[\"_fns\"].forEach((fn)=>namespace.use(fn));\n        this.listeners(\"connect\").forEach((listener)=>namespace.on(\"connect\", listener));\n        this.listeners(\"connection\").forEach((listener)=>namespace.on(\"connection\", listener));\n        this.children.add(namespace);\n        if (this.server._opts.cleanupEmptyChildNamespaces) {\n            const remove = namespace._remove;\n            namespace._remove = (socket)=>{\n                remove.call(namespace, socket);\n                if (namespace.sockets.size === 0) {\n                    debug(\"closing child namespace %s\", name);\n                    namespace.adapter.close();\n                    this.server._nsps.delete(namespace.name);\n                    this.children.delete(namespace);\n                }\n            };\n        }\n        this.server._nsps.set(name, namespace);\n        // @ts-ignore\n        this.server.sockets.emitReserved(\"new_namespace\", namespace);\n        return namespace;\n    }\n    fetchSockets() {\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n        // the behavior for namespaces created with a function is less clear\n        // note: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n        // may exist on one node but not exist on another (since it is created upon client connection)\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n/**\n * A dummy adapter that only supports broadcasting to child (concrete) namespaces.\n * @private file\n */ class ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {\n    broadcast(packet, opts) {\n        this.nsp.children.forEach((nsp)=>{\n            nsp.adapter.broadcast(packet, opts);\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvcGFyZW50LW5hbWVzcGFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixNQUFNRyxjQUFjQyxtQkFBT0EsQ0FBQyxxRUFBYTtBQUN6QyxNQUFNQyxzQkFBc0JELG1CQUFPQSxDQUFDLCtFQUFtQjtBQUN2RCxNQUFNRSxVQUFVWCxnQkFBZ0JTLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9DLE1BQU1HLFFBQVEsQ0FBQyxHQUFHRCxRQUFRRSxPQUFPLEVBQUU7QUFDbkM7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDRCxNQUFNTix3QkFBd0JDLFlBQVlNLFNBQVM7SUFDL0NDLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQixLQUFLLENBQUNBLFFBQVEsT0FBT1QsZ0JBQWdCVSxLQUFLO1FBQzFDLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUlDO0lBQ3hCO0lBQ0E7O0tBRUMsR0FDREMsZUFBZTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlDLHVCQUF1QixJQUFJO0lBQ2xEO0lBQ0FDLEtBQUtDLEVBQUUsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDZCxJQUFJLENBQUNQLFFBQVEsQ0FBQ1EsT0FBTyxDQUFDLENBQUNDO1lBQ25CQSxJQUFJSixJQUFJLENBQUNDLE9BQU9DO1FBQ3BCO1FBQ0EsT0FBTztJQUNYO0lBQ0FHLFlBQVlDLElBQUksRUFBRTtRQUNkakIsTUFBTSwrQkFBK0JpQjtRQUNyQyxNQUFNQyxZQUFZLElBQUl0QixZQUFZTSxTQUFTLENBQUMsSUFBSSxDQUFDRSxNQUFNLEVBQUVhO1FBQ3pELElBQUksQ0FBQyxPQUFPLENBQUNILE9BQU8sQ0FBQyxDQUFDSyxLQUFPRCxVQUFVRSxHQUFHLENBQUNEO1FBQzNDLElBQUksQ0FBQ0UsU0FBUyxDQUFDLFdBQVdQLE9BQU8sQ0FBQyxDQUFDUSxXQUFhSixVQUFVSyxFQUFFLENBQUMsV0FBV0Q7UUFDeEUsSUFBSSxDQUFDRCxTQUFTLENBQUMsY0FBY1AsT0FBTyxDQUFDLENBQUNRLFdBQWFKLFVBQVVLLEVBQUUsQ0FBQyxjQUFjRDtRQUM5RSxJQUFJLENBQUNoQixRQUFRLENBQUNrQixHQUFHLENBQUNOO1FBQ2xCLElBQUksSUFBSSxDQUFDZCxNQUFNLENBQUNxQixLQUFLLENBQUNDLDJCQUEyQixFQUFFO1lBQy9DLE1BQU1DLFNBQVNULFVBQVVVLE9BQU87WUFDaENWLFVBQVVVLE9BQU8sR0FBRyxDQUFDQztnQkFDakJGLE9BQU9HLElBQUksQ0FBQ1osV0FBV1c7Z0JBQ3ZCLElBQUlYLFVBQVVhLE9BQU8sQ0FBQ0MsSUFBSSxLQUFLLEdBQUc7b0JBQzlCaEMsTUFBTSw4QkFBOEJpQjtvQkFDcENDLFVBQVVULE9BQU8sQ0FBQ3dCLEtBQUs7b0JBQ3ZCLElBQUksQ0FBQzdCLE1BQU0sQ0FBQzhCLEtBQUssQ0FBQ0MsTUFBTSxDQUFDakIsVUFBVUQsSUFBSTtvQkFDdkMsSUFBSSxDQUFDWCxRQUFRLENBQUM2QixNQUFNLENBQUNqQjtnQkFDekI7WUFDSjtRQUNKO1FBQ0EsSUFBSSxDQUFDZCxNQUFNLENBQUM4QixLQUFLLENBQUNFLEdBQUcsQ0FBQ25CLE1BQU1DO1FBQzVCLGFBQWE7UUFDYixJQUFJLENBQUNkLE1BQU0sQ0FBQzJCLE9BQU8sQ0FBQ00sWUFBWSxDQUFDLGlCQUFpQm5CO1FBQ2xELE9BQU9BO0lBQ1g7SUFDQW9CLGVBQWU7UUFDWCxpSEFBaUg7UUFDakgsK0dBQStHO1FBQy9HLG9FQUFvRTtRQUNwRSxpSEFBaUg7UUFDakgsOEZBQThGO1FBQzlGLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtBQUNKO0FBQ0E5Qyx1QkFBdUIsR0FBR0U7QUFDMUJBLGdCQUFnQlUsS0FBSyxHQUFHO0FBQ3hCOzs7Q0FHQyxHQUNELE1BQU1LLCtCQUErQlosb0JBQW9CMEMsT0FBTztJQUM1REMsVUFBVUMsTUFBTSxFQUFFQyxJQUFJLEVBQUU7UUFDcEIsSUFBSSxDQUFDNUIsR0FBRyxDQUFDVCxRQUFRLENBQUNRLE9BQU8sQ0FBQyxDQUFDQztZQUN2QkEsSUFBSU4sT0FBTyxDQUFDZ0MsU0FBUyxDQUFDQyxRQUFRQztRQUNsQztJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWRjb2Rlc19hcHAvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvcGFyZW50LW5hbWVzcGFjZS5qcz9lZGFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG5jb25zdCBuYW1lc3BhY2VfMSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbmNvbnN0IHNvY2tldF9pb19hZGFwdGVyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLWFkYXB0ZXJcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOnBhcmVudC1uYW1lc3BhY2VcIik7XG4vKipcbiAqIEEgcGFyZW50IG5hbWVzcGFjZSBpcyBhIHNwZWNpYWwge0BsaW5rIE5hbWVzcGFjZX0gdGhhdCBob2xkcyBhIGxpc3Qgb2YgY2hpbGQgbmFtZXNwYWNlcyB3aGljaCB3ZXJlIGNyZWF0ZWQgZWl0aGVyXG4gKiB3aXRoIGEgcmVndWxhciBleHByZXNzaW9uIG9yIHdpdGggYSBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgcGFyZW50TmFtZXNwYWNlID0gaW8ub2YoL1xcL2R5bmFtaWMtXFxkKy8pO1xuICpcbiAqIHBhcmVudE5hbWVzcGFjZS5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBjb25zdCBjaGlsZE5hbWVzcGFjZSA9IHNvY2tldC5uc3A7XG4gKiB9XG4gKlxuICogLy8gd2lsbCByZWFjaCBhbGwgdGhlIGNsaWVudHMgdGhhdCBhcmUgaW4gb25lIG9mIHRoZSBjaGlsZCBuYW1lc3BhY2VzLCBsaWtlIFwiL2R5bmFtaWMtMTAxXCJcbiAqIHBhcmVudE5hbWVzcGFjZS5lbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAqXG4gKi9cbmNsYXNzIFBhcmVudE5hbWVzcGFjZSBleHRlbmRzIG5hbWVzcGFjZV8xLk5hbWVzcGFjZSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmVyKSB7XG4gICAgICAgIHN1cGVyKHNlcnZlciwgXCIvX1wiICsgUGFyZW50TmFtZXNwYWNlLmNvdW50KyspO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0QWRhcHRlcigpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gbmV3IFBhcmVudEJyb2FkY2FzdEFkYXB0ZXIodGhpcyk7XG4gICAgfVxuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChuc3ApID0+IHtcbiAgICAgICAgICAgIG5zcC5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjcmVhdGVDaGlsZChuYW1lKSB7XG4gICAgICAgIGRlYnVnKFwiY3JlYXRpbmcgY2hpbGQgbmFtZXNwYWNlICVzXCIsIG5hbWUpO1xuICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBuZXcgbmFtZXNwYWNlXzEuTmFtZXNwYWNlKHRoaXMuc2VydmVyLCBuYW1lKTtcbiAgICAgICAgdGhpc1tcIl9mbnNcIl0uZm9yRWFjaCgoZm4pID0+IG5hbWVzcGFjZS51c2UoZm4pKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMoXCJjb25uZWN0XCIpLmZvckVhY2goKGxpc3RlbmVyKSA9PiBuYW1lc3BhY2Uub24oXCJjb25uZWN0XCIsIGxpc3RlbmVyKSk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzKFwiY29ubmVjdGlvblwiKS5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbmFtZXNwYWNlLm9uKFwiY29ubmVjdGlvblwiLCBsaXN0ZW5lcikpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmFkZChuYW1lc3BhY2UpO1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZXIuX29wdHMuY2xlYW51cEVtcHR5Q2hpbGROYW1lc3BhY2VzKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmUgPSBuYW1lc3BhY2UuX3JlbW92ZTtcbiAgICAgICAgICAgIG5hbWVzcGFjZS5fcmVtb3ZlID0gKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlbW92ZS5jYWxsKG5hbWVzcGFjZSwgc29ja2V0KTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlLnNvY2tldHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImNsb3NpbmcgY2hpbGQgbmFtZXNwYWNlICVzXCIsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2UuYWRhcHRlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlci5fbnNwcy5kZWxldGUobmFtZXNwYWNlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmRlbGV0ZShuYW1lc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2ZXIuX25zcHMuc2V0KG5hbWUsIG5hbWVzcGFjZSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5zZXJ2ZXIuc29ja2V0cy5lbWl0UmVzZXJ2ZWQoXCJuZXdfbmFtZXNwYWNlXCIsIG5hbWVzcGFjZSk7XG4gICAgICAgIHJldHVybiBuYW1lc3BhY2U7XG4gICAgfVxuICAgIGZldGNoU29ja2V0cygpIHtcbiAgICAgICAgLy8gbm90ZTogd2UgY291bGQgbWFrZSB0aGUgZmV0Y2hTb2NrZXRzKCkgbWV0aG9kIHdvcmsgZm9yIGR5bmFtaWMgbmFtZXNwYWNlcyBjcmVhdGVkIHdpdGggYSByZWdleCAoYnkgc2VuZGluZyB0aGVcbiAgICAgICAgLy8gcmVnZXggdG8gdGhlIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzLCBhbmQgcmV0dXJuaW5nIHRoZSBzb2NrZXRzIG9mIGVhY2ggbWF0Y2hpbmcgbmFtZXNwYWNlIGZvciBleGFtcGxlKSwgYnV0XG4gICAgICAgIC8vIHRoZSBiZWhhdmlvciBmb3IgbmFtZXNwYWNlcyBjcmVhdGVkIHdpdGggYSBmdW5jdGlvbiBpcyBsZXNzIGNsZWFyXG4gICAgICAgIC8vIG5vdGXCsjogd2UgY2Fubm90IGxvb3Agb3ZlciBlYWNoIGNoaWxkcmVuIG5hbWVzcGFjZSwgYmVjYXVzZSB3aXRoIG11bHRpcGxlIFNvY2tldC5JTyBzZXJ2ZXJzLCBhIGdpdmVuIG5hbWVzcGFjZVxuICAgICAgICAvLyBtYXkgZXhpc3Qgb24gb25lIG5vZGUgYnV0IG5vdCBleGlzdCBvbiBhbm90aGVyIChzaW5jZSBpdCBpcyBjcmVhdGVkIHVwb24gY2xpZW50IGNvbm5lY3Rpb24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZldGNoU29ja2V0cygpIGlzIG5vdCBzdXBwb3J0ZWQgb24gcGFyZW50IG5hbWVzcGFjZXNcIik7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJlbnROYW1lc3BhY2UgPSBQYXJlbnROYW1lc3BhY2U7XG5QYXJlbnROYW1lc3BhY2UuY291bnQgPSAwO1xuLyoqXG4gKiBBIGR1bW15IGFkYXB0ZXIgdGhhdCBvbmx5IHN1cHBvcnRzIGJyb2FkY2FzdGluZyB0byBjaGlsZCAoY29uY3JldGUpIG5hbWVzcGFjZXMuXG4gKiBAcHJpdmF0ZSBmaWxlXG4gKi9cbmNsYXNzIFBhcmVudEJyb2FkY2FzdEFkYXB0ZXIgZXh0ZW5kcyBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIge1xuICAgIGJyb2FkY2FzdChwYWNrZXQsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5uc3AuY2hpbGRyZW4uZm9yRWFjaCgobnNwKSA9PiB7XG4gICAgICAgICAgICBuc3AuYWRhcHRlci5icm9hZGNhc3QocGFja2V0LCBvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBhcmVudE5hbWVzcGFjZSIsIm5hbWVzcGFjZV8xIiwicmVxdWlyZSIsInNvY2tldF9pb19hZGFwdGVyXzEiLCJkZWJ1Z18xIiwiZGVidWciLCJkZWZhdWx0IiwiTmFtZXNwYWNlIiwiY29uc3RydWN0b3IiLCJzZXJ2ZXIiLCJjb3VudCIsImNoaWxkcmVuIiwiU2V0IiwiX2luaXRBZGFwdGVyIiwiYWRhcHRlciIsIlBhcmVudEJyb2FkY2FzdEFkYXB0ZXIiLCJlbWl0IiwiZXYiLCJhcmdzIiwiZm9yRWFjaCIsIm5zcCIsImNyZWF0ZUNoaWxkIiwibmFtZSIsIm5hbWVzcGFjZSIsImZuIiwidXNlIiwibGlzdGVuZXJzIiwibGlzdGVuZXIiLCJvbiIsImFkZCIsIl9vcHRzIiwiY2xlYW51cEVtcHR5Q2hpbGROYW1lc3BhY2VzIiwicmVtb3ZlIiwiX3JlbW92ZSIsInNvY2tldCIsImNhbGwiLCJzb2NrZXRzIiwic2l6ZSIsImNsb3NlIiwiX25zcHMiLCJkZWxldGUiLCJzZXQiLCJlbWl0UmVzZXJ2ZWQiLCJmZXRjaFNvY2tldHMiLCJFcnJvciIsIkFkYXB0ZXIiLCJicm9hZGNhc3QiLCJwYWNrZXQiLCJvcHRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/parent-namespace.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/socket-types.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/socket-types.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RESERVED_EVENTS = void 0;\nexports.RESERVED_EVENTS = new Set([\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\"\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBRyxLQUFLO0FBQy9CQSx1QkFBdUIsR0FBRyxJQUFJRyxJQUFJO0lBQzlCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkY29kZXNfYXBwLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L3NvY2tldC10eXBlcy5qcz9jMGQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMgPSB2b2lkIDA7XG5leHBvcnRzLlJFU0VSVkVEX0VWRU5UUyA9IG5ldyBTZXQoW1xuICAgIFwiY29ubmVjdFwiLFxuICAgIFwiY29ubmVjdF9lcnJvclwiLFxuICAgIFwiZGlzY29ubmVjdFwiLFxuICAgIFwiZGlzY29ubmVjdGluZ1wiLFxuICAgIFwibmV3TGlzdGVuZXJcIixcbiAgICBcInJlbW92ZUxpc3RlbmVyXCIsXG5dKTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJFU0VSVkVEX0VWRU5UUyIsIlNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/socket-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/socket.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/socket.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Socket = void 0;\nconst socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ \"(rsc)/./node_modules/socket.io-parser/build/cjs/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst typed_events_1 = __webpack_require__(/*! ./typed-events */ \"(rsc)/./node_modules/socket.io/dist/typed-events.js\");\nconst base64id_1 = __importDefault(__webpack_require__(/*! base64id */ \"(rsc)/./node_modules/base64id/lib/base64id.js\"));\nconst broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ \"(rsc)/./node_modules/socket.io/dist/broadcast-operator.js\");\nconst socket_types_1 = __webpack_require__(/*! ./socket-types */ \"(rsc)/./node_modules/socket.io/dist/socket-types.js\");\nconst debug = (0, debug_1.default)(\"socket.io:socket\");\nconst RECOVERABLE_DISCONNECT_REASONS = new Set([\n    \"transport error\",\n    \"transport close\",\n    \"forced close\",\n    \"ping timeout\",\n    \"server shutting down\",\n    \"forced server close\"\n]);\nfunction noop() {}\n/**\n * This is the main object for interacting with a client.\n *\n * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.\n *\n * Within each {@link Namespace}, you can also define arbitrary channels (called \"rooms\") that the {@link Socket} can\n * join and leave. That provides a convenient way to broadcast to a group of socket instances.\n *\n * @example\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // join the room named \"room1\"\n *   socket.join(\"room1\");\n *\n *   // broadcast to everyone in the room named \"room1\"\n *   io.to(\"room1\").emit(\"hello\");\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n */ class Socket extends typed_events_1.StrictEventEmitter {\n    /**\n     * Interface to a `Client` for a given `Namespace`.\n     *\n     * @param {Namespace} nsp\n     * @param {Client} client\n     * @param {Object} auth\n     * @package\n     */ constructor(nsp, client, auth, previousSession){\n        super();\n        this.nsp = nsp;\n        this.client = client;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted to the client, the data attribute and the rooms will be restored.\n         */ this.recovered = false;\n        /**\n         * Additional information that can be attached to the Socket instance and which will be used in the\n         * {@link Server.fetchSockets()} method.\n         */ this.data = {};\n        /**\n         * Whether the socket is currently connected or not.\n         *\n         * @example\n         * io.use((socket, next) => {\n         *   console.log(socket.connected); // false\n         *   next();\n         * });\n         *\n         * io.on(\"connection\", (socket) => {\n         *   console.log(socket.connected); // true\n         * });\n         */ this.connected = false;\n        this.acks = new Map();\n        this.fns = [];\n        this.flags = {};\n        this.server = nsp.server;\n        this.adapter = this.nsp.adapter;\n        if (previousSession) {\n            this.id = previousSession.sid;\n            this.pid = previousSession.pid;\n            previousSession.rooms.forEach((room)=>this.join(room));\n            this.data = previousSession.data;\n            previousSession.missedPackets.forEach((packet)=>{\n                this.packet({\n                    type: socket_io_parser_1.PacketType.EVENT,\n                    data: packet\n                });\n            });\n            this.recovered = true;\n        } else {\n            if (client.conn.protocol === 3) {\n                // @ts-ignore\n                this.id = nsp.name !== \"/\" ? nsp.name + \"#\" + client.id : client.id;\n            } else {\n                this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information\n            }\n            if (this.server._opts.connectionStateRecovery) {\n                this.pid = base64id_1.default.generateId();\n            }\n        }\n        this.handshake = this.buildHandshake(auth);\n        // prevents crash when the socket receives an \"error\" event without listener\n        this.on(\"error\", noop);\n    }\n    /**\n     * Builds the `handshake` BC object\n     *\n     * @private\n     */ buildHandshake(auth) {\n        var _a, _b, _c, _d;\n        return {\n            headers: ((_a = this.request) === null || _a === void 0 ? void 0 : _a.headers) || {},\n            time: new Date() + \"\",\n            address: this.conn.remoteAddress,\n            xdomain: !!((_b = this.request) === null || _b === void 0 ? void 0 : _b.headers.origin),\n            // @ts-ignore\n            secure: !this.request || !!this.request.connection.encrypted,\n            issued: +new Date(),\n            url: (_c = this.request) === null || _c === void 0 ? void 0 : _c.url,\n            // @ts-ignore\n            query: ((_d = this.request) === null || _d === void 0 ? void 0 : _d._query) || {},\n            auth\n        };\n    }\n    /**\n     * Emits to this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.emit(\"hello\", \"world\");\n     *\n     *   // all serializable datastructures are supported (no need to call JSON.stringify)\n     *   socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Buffer.from([6]) });\n     *\n     *   // with an acknowledgement from the client\n     *   socket.emit(\"hello\", \"world\", (val) => {\n     *     // ...\n     *   });\n     * });\n     *\n     * @return Always returns `true`.\n     */ emit(ev, ...args) {\n        if (socket_types_1.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        const data = [\n            ev,\n            ...args\n        ];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data\n        };\n        // access last argument to see if it's an ACK callback\n        if (typeof data[data.length - 1] === \"function\") {\n            const id = this.nsp._ids++;\n            debug(\"emitting packet with ack id %d\", id);\n            this.registerAckCallback(id, data.pop());\n            packet.id = id;\n        }\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        // @ts-ignore\n        if (this.nsp.server.opts.connectionStateRecovery) {\n            // this ensures the packet is stored and can be transmitted upon reconnection\n            this.adapter.broadcast(packet, {\n                rooms: new Set([\n                    this.id\n                ]),\n                except: new Set(),\n                flags\n            });\n        } else {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet, flags);\n        }\n        return true;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * io.on(\"connection\", async (socket) => {\n     *   // without timeout\n     *   const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     *   // with a specific timeout\n     *   try {\n     *     const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     *   } catch (err) {\n     *     // the client did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @return a Promise that will be fulfilled when the client acknowledges the event\n     */ emitWithAck(ev, ...args) {\n        // the timeout flag is optional\n        const withErr = this.flags.timeout !== undefined;\n        return new Promise((resolve, reject)=>{\n            args.push((arg1, arg2)=>{\n                if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                } else {\n                    return resolve(arg1);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * @private\n     */ registerAckCallback(id, ack) {\n        const timeout = this.flags.timeout;\n        if (timeout === undefined) {\n            this.acks.set(id, ack);\n            return;\n        }\n        const timer = setTimeout(()=>{\n            debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\n            this.acks.delete(id);\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks.set(id, (...args)=>{\n            clearTimeout(timer);\n            ack.apply(this, [\n                null,\n                ...args\n            ]);\n        });\n    }\n    /**\n     * Targets a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the foo event will be broadcast to all connected clients in the room-101 room, except this socket\n     *   socket.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // the code above is equivalent to:\n     *   io.to(\"room-101\").except(socket.id).emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms (a client will be notified at most once)\n     *   socket.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ to(room) {\n        return this.newBroadcastOperator().to(room);\n    }\n    /**\n     * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect all clients in the \"room-101\" room, except this socket\n     *   socket.in(\"room-101\").disconnectSockets();\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ in(room) {\n        return this.newBroadcastOperator().in(room);\n    }\n    /**\n     * Excludes a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     *   // and this socket\n     *   socket.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms\n     *   socket.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ except(room) {\n        return this.newBroadcastOperator().except(room);\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.send(\"hello\");\n     *\n     *   // this is equivalent to\n     *   socket.emit(\"message\", \"hello\");\n     * });\n     *\n     * @return self\n     */ send(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */ write(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param {Object} packet - packet object\n     * @param {Object} opts - options\n     * @private\n     */ packet(packet, opts = {}) {\n        packet.nsp = this.nsp.name;\n        opts.compress = false !== opts.compress;\n        this.client._packet(packet, opts);\n    }\n    /**\n     * Joins a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // join a single room\n     *   socket.join(\"room1\");\n     *\n     *   // join multiple rooms\n     *   socket.join([\"room1\", \"room2\"]);\n     * });\n     *\n     * @param {String|Array} rooms - room or array of rooms\n     * @return a Promise or nothing, depending on the adapter\n     */ join(rooms) {\n        debug(\"join room %s\", rooms);\n        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [\n            rooms\n        ]));\n    }\n    /**\n     * Leaves a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // leave a single room\n     *   socket.leave(\"room1\");\n     *\n     *   // leave multiple rooms\n     *   socket.leave(\"room1\").leave(\"room2\");\n     * });\n     *\n     * @param {String} room\n     * @return a Promise or nothing, depending on the adapter\n     */ leave(room) {\n        debug(\"leave room %s\", room);\n        return this.adapter.del(this.id, room);\n    }\n    /**\n     * Leave all rooms.\n     *\n     * @private\n     */ leaveAll() {\n        this.adapter.delAll(this.id);\n    }\n    /**\n     * Called by `Namespace` upon successful\n     * middleware execution (ie: authorization).\n     * Socket is added to namespace array before\n     * call to join, so adapters can access it.\n     *\n     * @private\n     */ _onconnect() {\n        debug(\"socket connected - writing packet\");\n        this.connected = true;\n        this.join(this.id);\n        if (this.conn.protocol === 3) {\n            this.packet({\n                type: socket_io_parser_1.PacketType.CONNECT\n            });\n        } else {\n            this.packet({\n                type: socket_io_parser_1.PacketType.CONNECT,\n                data: {\n                    sid: this.id,\n                    pid: this.pid\n                }\n            });\n        }\n    }\n    /**\n     * Called with each packet. Called by `Client`.\n     *\n     * @param {Object} packet\n     * @private\n     */ _onpacket(packet) {\n        debug(\"got packet %j\", packet);\n        switch(packet.type){\n            case socket_io_parser_1.PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n        }\n    }\n    /**\n     * Called upon event packet.\n     *\n     * @param {Packet} packet - packet object\n     * @private\n     */ onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners){\n                listener.apply(this, args);\n            }\n        }\n        this.dispatch(args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @param {Number} id - packet id\n     * @private\n     */ ack(id) {\n        const self = this;\n        let sent = false;\n        return function() {\n            // prevent double callbacks\n            if (sent) return;\n            const args = Array.prototype.slice.call(arguments);\n            debug(\"sending ack %j\", args);\n            self.packet({\n                id: id,\n                type: socket_io_parser_1.PacketType.ACK,\n                data: args\n            });\n            sent = true;\n        };\n    }\n    /**\n     * Called upon ack packet.\n     *\n     * @private\n     */ onack(packet) {\n        const ack = this.acks.get(packet.id);\n        if (\"function\" == typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            this.acks.delete(packet.id);\n        } else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon client disconnect packet.\n     *\n     * @private\n     */ ondisconnect() {\n        debug(\"got disconnect packet\");\n        this._onclose(\"client namespace disconnect\");\n    }\n    /**\n     * Handles a client error.\n     *\n     * @private\n     */ _onerror(err) {\n        // FIXME the meaning of the \"error\" event is overloaded:\n        //  - it can be sent by the client (`socket.emit(\"error\")`)\n        //  - it can be emitted when the connection encounters an error (an invalid packet for example)\n        //  - it can be emitted when a packet is rejected in a middleware (`socket.use()`)\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Called upon closing. Called by `Client`.\n     *\n     * @param {String} reason\n     * @param description\n     * @throw {Error} optional error object\n     *\n     * @private\n     */ _onclose(reason, description) {\n        if (!this.connected) return this;\n        debug(\"closing socket - reason %s\", reason);\n        this.emitReserved(\"disconnecting\", reason, description);\n        if (this.server._opts.connectionStateRecovery && RECOVERABLE_DISCONNECT_REASONS.has(reason)) {\n            debug(\"connection state recovery is enabled for sid %s\", this.id);\n            this.adapter.persistSession({\n                sid: this.id,\n                pid: this.pid,\n                rooms: [\n                    ...this.rooms\n                ],\n                data: this.data\n            });\n        }\n        this._cleanup();\n        this.client._remove(this);\n        this.connected = false;\n        this.emitReserved(\"disconnect\", reason, description);\n        return;\n    }\n    /**\n     * Makes the socket leave all the rooms it was part of and prevents it from joining any other room\n     *\n     * @private\n     */ _cleanup() {\n        this.leaveAll();\n        this.nsp._remove(this);\n        this.join = noop;\n    }\n    /**\n     * Produces an `error` packet.\n     *\n     * @param {Object} err - error object\n     *\n     * @private\n     */ _error(err) {\n        this.packet({\n            type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n            data: err\n        });\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect this socket (the connection might be kept alive for other namespaces)\n     *   socket.disconnect();\n     *\n     *   // disconnect this socket and close the underlying connection\n     *   socket.disconnect(true);\n     * })\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return self\n     */ disconnect(close = false) {\n        if (!this.connected) return this;\n        if (close) {\n            this.client._disconnect();\n        } else {\n            this.packet({\n                type: socket_io_parser_1.PacketType.DISCONNECT\n            });\n            this._onclose(\"server namespace disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.compress(false).emit(\"hello\");\n     * });\n     *\n     * @param {Boolean} compress - if `true`, compresses the sending data\n     * @return {Socket} self\n     */ compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyre connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.volatile.emit(\"hello\"); // the client may or may not receive it\n     * });\n     *\n     * @return {Socket} self\n     */ get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the\n     * sender.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the foo event will be broadcast to all connected clients, except this socket\n     *   socket.broadcast.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get broadcast() {\n        return this.newBroadcastOperator();\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the foo event will be broadcast to all connected clients on this node, except this socket\n     *   socket.local.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */ get local() {\n        return this.newBroadcastOperator().local;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the client:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.timeout(5000).emit(\"my-event\", (err) => {\n     *     if (err) {\n     *       // the client did not acknowledge the event in the given delay\n     *     }\n     *   });\n     * });\n     *\n     * @returns self\n     */ timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Dispatch incoming event to socket listeners.\n     *\n     * @param {Array} event - event that will get emitted\n     * @private\n     */ dispatch(event) {\n        debug(\"dispatching an event %j\", event);\n        this.run(event, (err)=>{\n            process.nextTick(()=>{\n                if (err) {\n                    return this._onerror(err);\n                }\n                if (this.connected) {\n                    super.emitUntyped.apply(this, event);\n                } else {\n                    debug(\"ignore packet received after disconnection\");\n                }\n            });\n        });\n    }\n    /**\n     * Sets up socket middleware.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.use(([event, ...args], next) => {\n     *     if (isUnauthorized(event)) {\n     *       return next(new Error(\"unauthorized event\"));\n     *     }\n     *     // do not forget to call next\n     *     next();\n     *   });\n     *\n     *   socket.on(\"error\", (err) => {\n     *     if (err && err.message === \"unauthorized event\") {\n     *       socket.disconnect();\n     *     }\n     *   });\n     * });\n     *\n     * @param {Function} fn - middleware function (event, next)\n     * @return {Socket} self\n     */ use(fn) {\n        this.fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming event.\n     *\n     * @param {Array} event - event that will get emitted\n     * @param {Function} fn - last fn call in the middleware\n     * @private\n     */ run(event, fn) {\n        if (!this.fns.length) return fn();\n        const fns = this.fns.slice(0);\n        function run(i) {\n            fns[i](event, (err)=>{\n                // upon error, short-circuit\n                if (err) return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1]) return fn();\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Whether the socket is currently disconnected\n     */ get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * A reference to the request that originated the underlying Engine.IO Socket.\n     */ get request() {\n        return this.client.request;\n    }\n    /**\n     * A reference to the underlying Client transport connection (Engine.IO Socket object).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.conn.transport.name); // prints \"polling\" or \"websocket\"\n     *\n     *   socket.conn.once(\"upgrade\", () => {\n     *     console.log(socket.conn.transport.name); // prints \"websocket\"\n     *   });\n     * });\n     */ get conn() {\n        return this.client.conn;\n    }\n    /**\n     * Returns the rooms the socket is currently in.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.rooms); // Set { <socket.id> }\n     *\n     *   socket.join(\"room1\");\n     *\n     *   console.log(socket.rooms); // Set { <socket.id>, \"room1\" }\n     * });\n     */ get rooms() {\n        return this.adapter.socketRooms(this.id) || new Set();\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAny((event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */ onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     */ prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is received.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   }\n     *\n     *   socket.onAny(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAny(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAny();\n     * });\n     *\n     * @param listener\n     */ offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for(let i = 0; i < listeners.length; i++){\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        } else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */ listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to\n     * the callback.\n     *\n     * Note: acknowledgements sent to the client are not included.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */ onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.prependAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */ prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is sent.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   }\n     *\n     *   socket.onAnyOutgoing(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAnyOutgoing(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAnyOutgoing();\n     * });\n     *\n     * @param listener - the catch-all listener\n     */ offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for(let i = 0; i < listeners.length; i++){\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        } else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */ listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent (emit or broadcast)\n     *\n     * @param packet\n     *\n     * @private\n     */ notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners){\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n    newBroadcastOperator() {\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([\n            this.id\n        ]), flags);\n    }\n}\nexports.Socket = Socket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxxQkFBcUJDLG1CQUFPQSxDQUFDLGtGQUFrQjtBQUNyRCxNQUFNQyxVQUFVVixnQkFBZ0JTLG1CQUFPQSxDQUFDLDZFQUFPO0FBQy9DLE1BQU1FLGlCQUFpQkYsbUJBQU9BLENBQUMsMkVBQWdCO0FBQy9DLE1BQU1HLGFBQWFaLGdCQUFnQlMsbUJBQU9BLENBQUMsK0RBQVU7QUFDckQsTUFBTUksdUJBQXVCSixtQkFBT0EsQ0FBQyx1RkFBc0I7QUFDM0QsTUFBTUssaUJBQWlCTCxtQkFBT0EsQ0FBQywyRUFBZ0I7QUFDL0MsTUFBTU0sUUFBUSxDQUFDLEdBQUdMLFFBQVFNLE9BQU8sRUFBRTtBQUNuQyxNQUFNQyxpQ0FBaUMsSUFBSUMsSUFBSTtJQUMzQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELFNBQVNDLFFBQVM7QUFDbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQThCQyxHQUNELE1BQU1aLGVBQWVJLGVBQWVTLGtCQUFrQjtJQUNsRDs7Ozs7OztLQU9DLEdBQ0RDLFlBQVlDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLGVBQWUsQ0FBRTtRQUM1QyxLQUFLO1FBQ0wsSUFBSSxDQUFDSCxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2Q7OztTQUdDLEdBQ0QsSUFBSSxDQUFDRyxTQUFTLEdBQUc7UUFDakI7OztTQUdD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L2Rpc3Qvc29ja2V0LmpzP2FlNDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tcGFyc2VyXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgdHlwZWRfZXZlbnRzXzEgPSByZXF1aXJlKFwiLi90eXBlZC1ldmVudHNcIik7XG5jb25zdCBiYXNlNjRpZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiYXNlNjRpZFwiKSk7XG5jb25zdCBicm9hZGNhc3Rfb3BlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdC1vcGVyYXRvclwiKTtcbmNvbnN0IHNvY2tldF90eXBlc18xID0gcmVxdWlyZShcIi4vc29ja2V0LXR5cGVzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pbzpzb2NrZXRcIik7XG5jb25zdCBSRUNPVkVSQUJMRV9ESVNDT05ORUNUX1JFQVNPTlMgPSBuZXcgU2V0KFtcbiAgICBcInRyYW5zcG9ydCBlcnJvclwiLFxuICAgIFwidHJhbnNwb3J0IGNsb3NlXCIsXG4gICAgXCJmb3JjZWQgY2xvc2VcIixcbiAgICBcInBpbmcgdGltZW91dFwiLFxuICAgIFwic2VydmVyIHNodXR0aW5nIGRvd25cIixcbiAgICBcImZvcmNlZCBzZXJ2ZXIgY2xvc2VcIixcbl0pO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIG9iamVjdCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhIGNsaWVudC5cbiAqXG4gKiBBIFNvY2tldCBiZWxvbmdzIHRvIGEgZ2l2ZW4ge0BsaW5rIE5hbWVzcGFjZX0gYW5kIHVzZXMgYW4gdW5kZXJseWluZyB7QGxpbmsgQ2xpZW50fSB0byBjb21tdW5pY2F0ZS5cbiAqXG4gKiBXaXRoaW4gZWFjaCB7QGxpbmsgTmFtZXNwYWNlfSwgeW91IGNhbiBhbHNvIGRlZmluZSBhcmJpdHJhcnkgY2hhbm5lbHMgKGNhbGxlZCBcInJvb21zXCIpIHRoYXQgdGhlIHtAbGluayBTb2NrZXR9IGNhblxuICogam9pbiBhbmQgbGVhdmUuIFRoYXQgcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSB0byBicm9hZGNhc3QgdG8gYSBncm91cCBvZiBzb2NrZXQgaW5zdGFuY2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhgc29ja2V0ICR7c29ja2V0LmlkfSBjb25uZWN0ZWRgKTtcbiAqXG4gKiAgIC8vIHNlbmQgYW4gZXZlbnQgdG8gdGhlIGNsaWVudFxuICogICBzb2NrZXQuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAqXG4gKiAgIHNvY2tldC5vbihcImZvb2JhclwiLCAoKSA9PiB7XG4gKiAgICAgLy8gYW4gZXZlbnQgd2FzIHJlY2VpdmVkIGZyb20gdGhlIGNsaWVudFxuICogICB9KTtcbiAqXG4gKiAgIC8vIGpvaW4gdGhlIHJvb20gbmFtZWQgXCJyb29tMVwiXG4gKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gKlxuICogICAvLyBicm9hZGNhc3QgdG8gZXZlcnlvbmUgaW4gdGhlIHJvb20gbmFtZWQgXCJyb29tMVwiXG4gKiAgIGlvLnRvKFwicm9vbTFcIikuZW1pdChcImhlbGxvXCIpO1xuICpcbiAqICAgLy8gdXBvbiBkaXNjb25uZWN0aW9uXG4gKiAgIHNvY2tldC5vbihcImRpc2Nvbm5lY3RcIiwgKHJlYXNvbikgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGBzb2NrZXQgJHtzb2NrZXQuaWR9IGRpc2Nvbm5lY3RlZCBkdWUgdG8gJHtyZWFzb259YCk7XG4gKiAgIH0pO1xuICogfSk7XG4gKi9cbmNsYXNzIFNvY2tldCBleHRlbmRzIHR5cGVkX2V2ZW50c18xLlN0cmljdEV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogSW50ZXJmYWNlIHRvIGEgYENsaWVudGAgZm9yIGEgZ2l2ZW4gYE5hbWVzcGFjZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05hbWVzcGFjZX0gbnNwXG4gICAgICogQHBhcmFtIHtDbGllbnR9IGNsaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihuc3AsIGNsaWVudCwgYXV0aCwgcHJldmlvdXNTZXNzaW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubnNwID0gbnNwO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNvbm5lY3Rpb24gc3RhdGUgd2FzIHJlY292ZXJlZCBhZnRlciBhIHRlbXBvcmFyeSBkaXNjb25uZWN0aW9uLiBJbiB0aGF0IGNhc2UsIGFueSBtaXNzZWQgcGFja2V0cyB3aWxsXG4gICAgICAgICAqIGJlIHRyYW5zbWl0dGVkIHRvIHRoZSBjbGllbnQsIHRoZSBkYXRhIGF0dHJpYnV0ZSBhbmQgdGhlIHJvb21zIHdpbGwgYmUgcmVzdG9yZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlY292ZXJlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgU29ja2V0IGluc3RhbmNlIGFuZCB3aGljaCB3aWxsIGJlIHVzZWQgaW4gdGhlXG4gICAgICAgICAqIHtAbGluayBTZXJ2ZXIuZmV0Y2hTb2NrZXRzKCl9IG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBjb25uZWN0ZWQgb3Igbm90LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBpby51c2UoKHNvY2tldCwgbmV4dCkgPT4ge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5jb25uZWN0ZWQpOyAvLyBmYWxzZVxuICAgICAgICAgKiAgIG5leHQoKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmNvbm5lY3RlZCk7IC8vIHRydWVcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZm5zID0gW107XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBuc3Auc2VydmVyO1xuICAgICAgICB0aGlzLmFkYXB0ZXIgPSB0aGlzLm5zcC5hZGFwdGVyO1xuICAgICAgICBpZiAocHJldmlvdXNTZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gcHJldmlvdXNTZXNzaW9uLnNpZDtcbiAgICAgICAgICAgIHRoaXMucGlkID0gcHJldmlvdXNTZXNzaW9uLnBpZDtcbiAgICAgICAgICAgIHByZXZpb3VzU2Vzc2lvbi5yb29tcy5mb3JFYWNoKChyb29tKSA9PiB0aGlzLmpvaW4ocm9vbSkpO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gcHJldmlvdXNTZXNzaW9uLmRhdGE7XG4gICAgICAgICAgICBwcmV2aW91c1Nlc3Npb24ubWlzc2VkUGFja2V0cy5mb3JFYWNoKChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhY2tldCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5ULFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYWNrZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbGllbnQuY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gbnNwLm5hbWUgIT09IFwiL1wiID8gbnNwLm5hbWUgKyBcIiNcIiArIGNsaWVudC5pZCA6IGNsaWVudC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBiYXNlNjRpZF8xLmRlZmF1bHQuZ2VuZXJhdGVJZCgpOyAvLyBkb24ndCByZXVzZSB0aGUgRW5naW5lLklPIGlkIGJlY2F1c2UgaXQncyBzZW5zaXRpdmUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNlcnZlci5fb3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGlkID0gYmFzZTY0aWRfMS5kZWZhdWx0LmdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRzaGFrZSA9IHRoaXMuYnVpbGRIYW5kc2hha2UoYXV0aCk7XG4gICAgICAgIC8vIHByZXZlbnRzIGNyYXNoIHdoZW4gdGhlIHNvY2tldCByZWNlaXZlcyBhbiBcImVycm9yXCIgZXZlbnQgd2l0aG91dCBsaXN0ZW5lclxuICAgICAgICB0aGlzLm9uKFwiZXJyb3JcIiwgbm9vcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgYGhhbmRzaGFrZWAgQkMgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ1aWxkSGFuZHNoYWtlKGF1dGgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyczogKChfYSA9IHRoaXMucmVxdWVzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlcnMpIHx8IHt9LFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKSArIFwiXCIsXG4gICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmNvbm4ucmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgIHhkb21haW46ICEhKChfYiA9IHRoaXMucmVxdWVzdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlYWRlcnMub3JpZ2luKSxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHNlY3VyZTogIXRoaXMucmVxdWVzdCB8fCAhIXRoaXMucmVxdWVzdC5jb25uZWN0aW9uLmVuY3J5cHRlZCxcbiAgICAgICAgICAgIGlzc3VlZDogK25ldyBEYXRlKCksXG4gICAgICAgICAgICB1cmw6IChfYyA9IHRoaXMucmVxdWVzdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybCxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHF1ZXJ5OiAoKF9kID0gdGhpcy5yZXF1ZXN0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuX3F1ZXJ5KSB8fCB7fSxcbiAgICAgICAgICAgIGF1dGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHRvIHRoaXMgY2xpZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LmVtaXQoXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqXG4gICAgICogICAvLyBhbGwgc2VyaWFsaXphYmxlIGRhdGFzdHJ1Y3R1cmVzIGFyZSBzdXBwb3J0ZWQgKG5vIG5lZWQgdG8gY2FsbCBKU09OLnN0cmluZ2lmeSlcbiAgICAgKiAgIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgMSwgXCIyXCIsIHsgMzogW1wiNFwiXSwgNTogQnVmZmVyLmZyb20oWzZdKSB9KTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgY2xpZW50XG4gICAgICogICBzb2NrZXQuZW1pdChcImhlbGxvXCIsIFwid29ybGRcIiwgKHZhbCkgPT4ge1xuICAgICAqICAgICAvLyAuLi5cbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoc29ja2V0X3R5cGVzXzEuUkVTRVJWRURfRVZFTlRTLmhhcyhldikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke1N0cmluZyhldil9XCIgaXMgYSByZXNlcnZlZCBldmVudCBuYW1lYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IFtldiwgLi4uYXJnc107XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5ULFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYWNjZXNzIGxhc3QgYXJndW1lbnQgdG8gc2VlIGlmIGl0J3MgYW4gQUNLIGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5uc3AuX2lkcysrO1xuICAgICAgICAgICAgZGVidWcoXCJlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWRcIiwgaWQpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckFja0NhbGxiYWNrKGlkLCBkYXRhLnBvcCgpKTtcbiAgICAgICAgICAgIHBhY2tldC5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncyk7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodGhpcy5uc3Auc2VydmVyLm9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgZW5zdXJlcyB0aGUgcGFja2V0IGlzIHN0b3JlZCBhbmQgY2FuIGJlIHRyYW5zbWl0dGVkIHVwb24gcmVjb25uZWN0aW9uXG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIuYnJvYWRjYXN0KHBhY2tldCwge1xuICAgICAgICAgICAgICAgIHJvb21zOiBuZXcgU2V0KFt0aGlzLmlkXSksXG4gICAgICAgICAgICAgICAgZXhjZXB0OiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHBhY2tldCwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhbmQgd2FpdHMgZm9yIGFuIGFja25vd2xlZGdlbWVudFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgYXN5bmMgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gd2l0aG91dCB0aW1lb3V0XG4gICAgICogICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNvY2tldC5lbWl0V2l0aEFjayhcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIHdpdGggYSBzcGVjaWZpYyB0aW1lb3V0XG4gICAgICogICB0cnkge1xuICAgICAqICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNvY2tldC50aW1lb3V0KDEwMDApLmVtaXRXaXRoQWNrKFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKiAgIH0gY2F0Y2ggKGVycikge1xuICAgICAqICAgICAvLyB0aGUgY2xpZW50IGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBjbGllbnQgYWNrbm93bGVkZ2VzIHRoZSBldmVudFxuICAgICAqL1xuICAgIGVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIHRoZSB0aW1lb3V0IGZsYWcgaXMgb3B0aW9uYWxcbiAgICAgICAgY29uc3Qgd2l0aEVyciA9IHRoaXMuZmxhZ3MudGltZW91dCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYXJncy5wdXNoKChhcmcxLCBhcmcyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHdpdGhFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZzEgPyByZWplY3QoYXJnMSkgOiByZXNvbHZlKGFyZzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYXJnMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZWdpc3RlckFja0NhbGxiYWNrKGlkLCBhY2spIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuZmxhZ3MudGltZW91dDtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hY2tzLnNldChpZCwgYWNrKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJldmVudCB3aXRoIGFjayBpZCAlZCBoYXMgdGltZWQgb3V0IGFmdGVyICVkIG1zXCIsIGlkLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuYWNrcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgYWNrLmNhbGwodGhpcywgbmV3IEVycm9yKFwib3BlcmF0aW9uIGhhcyB0aW1lZCBvdXRcIikpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgdGhpcy5hY2tzLnNldChpZCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICBhY2suYXBwbHkodGhpcywgW251bGwsIC4uLmFyZ3NdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gYnJvYWRjYXN0aW5nLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gdGhlIOKAnGZvb+KAnSBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMgaW4gdGhlIOKAnHJvb20tMTAx4oCdIHJvb20sIGV4Y2VwdCB0aGlzIHNvY2tldFxuICAgICAqICAgc29ja2V0LnRvKFwicm9vbS0xMDFcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gdGhlIGNvZGUgYWJvdmUgaXMgZXF1aXZhbGVudCB0bzpcbiAgICAgKiAgIGlvLnRvKFwicm9vbS0xMDFcIikuZXhjZXB0KHNvY2tldC5pZCkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBhbiBhcnJheSBvZiByb29tcyAoYSBjbGllbnQgd2lsbCBiZSBub3RpZmllZCBhdCBtb3N0IG9uY2UpXG4gICAgICogICBzb2NrZXQudG8oW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogICBzb2NrZXQudG8oXCJyb29tLTEwMVwiKS50byhcInJvb20tMTAyXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgdG8ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLnRvKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGJyb2FkY2FzdGluZy4gU2ltaWxhciB0byBgdG8oKWAsIGJ1dCBtaWdodCBmZWVsIGNsZWFyZXIgaW4gc29tZSBjYXNlczpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIGRpc2Nvbm5lY3QgYWxsIGNsaWVudHMgaW4gdGhlIFwicm9vbS0xMDFcIiByb29tLCBleGNlcHQgdGhpcyBzb2NrZXRcbiAgICAgKiAgIHNvY2tldC5pbihcInJvb20tMTAxXCIpLmRpc2Nvbm5lY3RTb2NrZXRzKCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbSAtIGEgcm9vbSwgb3IgYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLmluKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlcyBhIHJvb20gd2hlbiBicm9hZGNhc3RpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB0aGUgXCJmb29cIiBldmVudCB3aWxsIGJlIGJyb2FkY2FzdCB0byBhbGwgY29ubmVjdGVkIGNsaWVudHMsIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGFyZSBpbiB0aGUgXCJyb29tLTEwMVwiIHJvb21cbiAgICAgKiAgIC8vIGFuZCB0aGlzIHNvY2tldFxuICAgICAqICAgc29ja2V0LmV4Y2VwdChcInJvb20tMTAxXCIpLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIHdpdGggYW4gYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiAgIHNvY2tldC5leGNlcHQoW1wicm9vbS0xMDFcIiwgXCJyb29tLTEwMlwiXSkuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKlxuICAgICAqICAgLy8gd2l0aCBtdWx0aXBsZSBjaGFpbmVkIGNhbGxzXG4gICAgICogICBzb2NrZXQuZXhjZXB0KFwicm9vbS0xMDFcIikuZXhjZXB0KFwicm9vbS0xMDJcIikuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tIC0gYSByb29tLCBvciBhbiBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBuZXcge0BsaW5rIEJyb2FkY2FzdE9wZXJhdG9yfSBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBleGNlcHQocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLmV4Y2VwdChyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtaW1pY3MgdGhlIFdlYlNvY2tldC5zZW5kKCkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViU29ja2V0L3NlbmRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC5zZW5kKFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiAgIC8vIHRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAqICAgc29ja2V0LmVtaXQoXCJtZXNzYWdlXCIsIFwiaGVsbG9cIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBzZW5kKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LiBBbGlhcyBvZiB7QGxpbmsgc2VuZH0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICB3cml0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gcGFja2V0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcGFja2V0KHBhY2tldCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHBhY2tldC5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdHMuY29tcHJlc3M7XG4gICAgICAgIHRoaXMuY2xpZW50Ll9wYWNrZXQocGFja2V0LCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbnMgYSByb29tLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gam9pbiBhIHNpbmdsZSByb29tXG4gICAgICogICBzb2NrZXQuam9pbihcInJvb20xXCIpO1xuICAgICAqXG4gICAgICogICAvLyBqb2luIG11bHRpcGxlIHJvb21zXG4gICAgICogICBzb2NrZXQuam9pbihbXCJyb29tMVwiLCBcInJvb20yXCJdKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSByb29tcyAtIHJvb20gb3IgYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSBvciBub3RoaW5nLCBkZXBlbmRpbmcgb24gdGhlIGFkYXB0ZXJcbiAgICAgKi9cbiAgICBqb2luKHJvb21zKSB7XG4gICAgICAgIGRlYnVnKFwiam9pbiByb29tICVzXCIsIHJvb21zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5hZGRBbGwodGhpcy5pZCwgbmV3IFNldChBcnJheS5pc0FycmF5KHJvb21zKSA/IHJvb21zIDogW3Jvb21zXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZXMgYSByb29tLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgLy8gbGVhdmUgYSBzaW5nbGUgcm9vbVxuICAgICAqICAgc29ja2V0LmxlYXZlKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAgIC8vIGxlYXZlIG11bHRpcGxlIHJvb21zXG4gICAgICogICBzb2NrZXQubGVhdmUoXCJyb29tMVwiKS5sZWF2ZShcInJvb20yXCIpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJvb21cbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSBvciBub3RoaW5nLCBkZXBlbmRpbmcgb24gdGhlIGFkYXB0ZXJcbiAgICAgKi9cbiAgICBsZWF2ZShyb29tKSB7XG4gICAgICAgIGRlYnVnKFwibGVhdmUgcm9vbSAlc1wiLCByb29tKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5kZWwodGhpcy5pZCwgcm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlIGFsbCByb29tcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbGVhdmVBbGwoKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlci5kZWxBbGwodGhpcy5pZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSBgTmFtZXNwYWNlYCB1cG9uIHN1Y2Nlc3NmdWxcbiAgICAgKiBtaWRkbGV3YXJlIGV4ZWN1dGlvbiAoaWU6IGF1dGhvcml6YXRpb24pLlxuICAgICAqIFNvY2tldCBpcyBhZGRlZCB0byBuYW1lc3BhY2UgYXJyYXkgYmVmb3JlXG4gICAgICogY2FsbCB0byBqb2luLCBzbyBhZGFwdGVycyBjYW4gYWNjZXNzIGl0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25jb25uZWN0KCkge1xuICAgICAgICBkZWJ1ZyhcInNvY2tldCBjb25uZWN0ZWQgLSB3cml0aW5nIHBhY2tldFwiKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmpvaW4odGhpcy5pZCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm4ucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNULFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgc2lkOiB0aGlzLmlkLCBwaWQ6IHRoaXMucGlkIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBlYWNoIHBhY2tldC4gQ2FsbGVkIGJ5IGBDbGllbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29ucGFja2V0KHBhY2tldCkge1xuICAgICAgICBkZWJ1ZyhcImdvdCBwYWNrZXQgJWpcIiwgcGFja2V0KTtcbiAgICAgICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5FVkVOVDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQklOQVJZX0VWRU5UOlxuICAgICAgICAgICAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5CSU5BUllfQUNLOlxuICAgICAgICAgICAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRElTQ09OTkVDVDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGV2ZW50IHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFja2V0fSBwYWNrZXQgLSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmV2ZW50KHBhY2tldCkge1xuICAgICAgICBjb25zdCBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gICAgICAgIGRlYnVnKFwiZW1pdHRpbmcgZXZlbnQgJWpcIiwgYXJncyk7XG4gICAgICAgIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgICAgICAgICAgZGVidWcoXCJhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50XCIpO1xuICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hbnlMaXN0ZW5lcnMgJiYgdGhpcy5fYW55TGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgLSBwYWNrZXQgaWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFjayhpZCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IHNlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgICAgICAgICAgaWYgKHNlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBkZWJ1ZyhcInNlbmRpbmcgYWNrICVqXCIsIGFyZ3MpO1xuICAgICAgICAgICAgc2VsZi5wYWNrZXQoe1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5BQ0ssXG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VudCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGFjayBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uYWNrKHBhY2tldCkge1xuICAgICAgICBjb25zdCBhY2sgPSB0aGlzLmFja3MuZ2V0KHBhY2tldC5pZCk7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGFjaykge1xuICAgICAgICAgICAgZGVidWcoXCJjYWxsaW5nIGFjayAlcyB3aXRoICVqXCIsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuYWNrcy5kZWxldGUocGFja2V0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiYmFkIGFjayAlc1wiLCBwYWNrZXQuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGNsaWVudCBkaXNjb25uZWN0IHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kaXNjb25uZWN0KCkge1xuICAgICAgICBkZWJ1ZyhcImdvdCBkaXNjb25uZWN0IHBhY2tldFwiKTtcbiAgICAgICAgdGhpcy5fb25jbG9zZShcImNsaWVudCBuYW1lc3BhY2UgZGlzY29ubmVjdFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIGNsaWVudCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uZXJyb3IoZXJyKSB7XG4gICAgICAgIC8vIEZJWE1FIHRoZSBtZWFuaW5nIG9mIHRoZSBcImVycm9yXCIgZXZlbnQgaXMgb3ZlcmxvYWRlZDpcbiAgICAgICAgLy8gIC0gaXQgY2FuIGJlIHNlbnQgYnkgdGhlIGNsaWVudCAoYHNvY2tldC5lbWl0KFwiZXJyb3JcIilgKVxuICAgICAgICAvLyAgLSBpdCBjYW4gYmUgZW1pdHRlZCB3aGVuIHRoZSBjb25uZWN0aW9uIGVuY291bnRlcnMgYW4gZXJyb3IgKGFuIGludmFsaWQgcGFja2V0IGZvciBleGFtcGxlKVxuICAgICAgICAvLyAgLSBpdCBjYW4gYmUgZW1pdHRlZCB3aGVuIGEgcGFja2V0IGlzIHJlamVjdGVkIGluIGEgbWlkZGxld2FyZSAoYHNvY2tldC51c2UoKWApXG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gY2xvc2luZy4gQ2FsbGVkIGJ5IGBDbGllbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEB0aHJvdyB7RXJyb3J9IG9wdGlvbmFsIGVycm9yIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25jbG9zZShyZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nIHNvY2tldCAtIHJlYXNvbiAlc1wiLCByZWFzb24pO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRpc2Nvbm5lY3RpbmdcIiwgcmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlci5fb3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSAmJlxuICAgICAgICAgICAgUkVDT1ZFUkFCTEVfRElTQ09OTkVDVF9SRUFTT05TLmhhcyhyZWFzb24pKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gc3RhdGUgcmVjb3ZlcnkgaXMgZW5hYmxlZCBmb3Igc2lkICVzXCIsIHRoaXMuaWQpO1xuICAgICAgICAgICAgdGhpcy5hZGFwdGVyLnBlcnNpc3RTZXNzaW9uKHtcbiAgICAgICAgICAgICAgICBzaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgcGlkOiB0aGlzLnBpZCxcbiAgICAgICAgICAgICAgICByb29tczogWy4uLnRoaXMucm9vbXNdLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgdGhpcy5jbGllbnQuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkaXNjb25uZWN0XCIsIHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBzb2NrZXQgbGVhdmUgYWxsIHRoZSByb29tcyBpdCB3YXMgcGFydCBvZiBhbmQgcHJldmVudHMgaXQgZnJvbSBqb2luaW5nIGFueSBvdGhlciByb29tXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhbnVwKCkge1xuICAgICAgICB0aGlzLmxlYXZlQWxsKCk7XG4gICAgICAgIHRoaXMubnNwLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuam9pbiA9IG5vb3A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGFuIGBlcnJvcmAgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVyciAtIGVycm9yIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXJyb3IoZXJyKSB7XG4gICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUiwgZGF0YTogZXJyIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGlzIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIC8vIGRpc2Nvbm5lY3QgdGhpcyBzb2NrZXQgKHRoZSBjb25uZWN0aW9uIG1pZ2h0IGJlIGtlcHQgYWxpdmUgZm9yIG90aGVyIG5hbWVzcGFjZXMpXG4gICAgICogICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAqXG4gICAgICogICAvLyBkaXNjb25uZWN0IHRoaXMgc29ja2V0IGFuZCBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICogICBzb2NrZXQuZGlzY29ubmVjdCh0cnVlKTtcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjbG9zZSAtIGlmIGB0cnVlYCwgY2xvc2VzIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoY2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50Ll9kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkRJU0NPTk5FQ1QgfSk7XG4gICAgICAgICAgICB0aGlzLl9vbmNsb3NlKFwic2VydmVyIG5hbWVzcGFjZSBkaXNjb25uZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LmNvbXByZXNzKGZhbHNlKS5lbWl0KFwiaGVsbG9cIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIG1heSBiZSBsb3N0IGlmIHRoZSBjbGllbnQgaXMgbm90IHJlYWR5IHRvXG4gICAgICogcmVjZWl2ZSBtZXNzYWdlcyAoYmVjYXVzZSBvZiBuZXR3b3JrIHNsb3duZXNzIG9yIG90aGVyIGlzc3Vlcywgb3IgYmVjYXVzZSB0aGV54oCZcmUgY29ubmVjdGVkIHRocm91Z2ggbG9uZyBwb2xsaW5nXG4gICAgICogYW5kIGlzIGluIHRoZSBtaWRkbGUgb2YgYSByZXF1ZXN0LXJlc3BvbnNlIGN5Y2xlKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC52b2xhdGlsZS5lbWl0KFwiaGVsbG9cIik7IC8vIHRoZSBjbGllbnQgbWF5IG9yIG1heSBub3QgcmVjZWl2ZSBpdFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICB0aGlzLmZsYWdzLnZvbGF0aWxlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgd2lsbCBvbmx5IGJlIGJyb2FkY2FzdCB0byBldmVyeSBzb2NrZXRzIGJ1dCB0aGVcbiAgICAgKiBzZW5kZXIuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cywgZXhjZXB0IHRoaXMgc29ja2V0XG4gICAgICogICBzb2NrZXQuYnJvYWRjYXN0LmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZ2V0IGJyb2FkY2FzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3QnJvYWRjYXN0T3BlcmF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICAvLyB0aGUg4oCcZm9v4oCdIGV2ZW50IHdpbGwgYmUgYnJvYWRjYXN0IHRvIGFsbCBjb25uZWN0ZWQgY2xpZW50cyBvbiB0aGlzIG5vZGUsIGV4Y2VwdCB0aGlzIHNvY2tldFxuICAgICAqICAgc29ja2V0LmxvY2FsLmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IHtAbGluayBCcm9hZGNhc3RPcGVyYXRvcn0gaW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZ2V0IGxvY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLmxvY2FsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgICogZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgd2l0aG91dCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgY2xpZW50OlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0LnRpbWVvdXQoNTAwMCkuZW1pdChcIm15LWV2ZW50XCIsIChlcnIpID0+IHtcbiAgICAgKiAgICAgaWYgKGVycikge1xuICAgICAqICAgICAgIC8vIHRoZSBjbGllbnQgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICAgIH1cbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybnMgc2VsZlxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICB0aGlzLmZsYWdzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggaW5jb21pbmcgZXZlbnQgdG8gc29ja2V0IGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50IC0gZXZlbnQgdGhhdCB3aWxsIGdldCBlbWl0dGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkaXNwYXRjaChldmVudCkge1xuICAgICAgICBkZWJ1ZyhcImRpc3BhdGNoaW5nIGFuIGV2ZW50ICVqXCIsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5ydW4oZXZlbnQsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmVtaXRVbnR5cGVkLmFwcGx5KHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiaWdub3JlIHBhY2tldCByZWNlaXZlZCBhZnRlciBkaXNjb25uZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBzb2NrZXQgbWlkZGxld2FyZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIHNvY2tldC51c2UoKFtldmVudCwgLi4uYXJnc10sIG5leHQpID0+IHtcbiAgICAgKiAgICAgaWYgKGlzVW5hdXRob3JpemVkKGV2ZW50KSkge1xuICAgICAqICAgICAgIHJldHVybiBuZXh0KG5ldyBFcnJvcihcInVuYXV0aG9yaXplZCBldmVudFwiKSk7XG4gICAgICogICAgIH1cbiAgICAgKiAgICAgLy8gZG8gbm90IGZvcmdldCB0byBjYWxsIG5leHRcbiAgICAgKiAgICAgbmV4dCgpO1xuICAgICAqICAgfSk7XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgKiAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gXCJ1bmF1dGhvcml6ZWQgZXZlbnRcIikge1xuICAgICAqICAgICAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBtaWRkbGV3YXJlIGZ1bmN0aW9uIChldmVudCwgbmV4dClcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKi9cbiAgICB1c2UoZm4pIHtcbiAgICAgICAgdGhpcy5mbnMucHVzaChmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgbWlkZGxld2FyZSBmb3IgYW4gaW5jb21pbmcgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBldmVudCAtIGV2ZW50IHRoYXQgd2lsbCBnZXQgZW1pdHRlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gbGFzdCBmbiBjYWxsIGluIHRoZSBtaWRkbGV3YXJlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydW4oZXZlbnQsIGZuKSB7XG4gICAgICAgIGlmICghdGhpcy5mbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIGNvbnN0IGZucyA9IHRoaXMuZm5zLnNsaWNlKDApO1xuICAgICAgICBmdW5jdGlvbiBydW4oaSkge1xuICAgICAgICAgICAgZm5zW2ldKGV2ZW50LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdXBvbiBlcnJvciwgc2hvcnQtY2lyY3VpdFxuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihlcnIpO1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1pZGRsZXdhcmUgbGVmdCwgc3VtbW9uIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKCFmbnNbaSArIDFdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgICAgICAvLyBnbyBvbiB0byBuZXh0XG4gICAgICAgICAgICAgICAgcnVuKGkgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJ1bigwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBkaXNjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29ubmVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgcmVxdWVzdCB0aGF0IG9yaWdpbmF0ZWQgdGhlIHVuZGVybHlpbmcgRW5naW5lLklPIFNvY2tldC5cbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIENsaWVudCB0cmFuc3BvcnQgY29ubmVjdGlvbiAoRW5naW5lLklPIFNvY2tldCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmNvbm4udHJhbnNwb3J0Lm5hbWUpOyAvLyBwcmludHMgXCJwb2xsaW5nXCIgb3IgXCJ3ZWJzb2NrZXRcIlxuICAgICAqXG4gICAgICogICBzb2NrZXQuY29ubi5vbmNlKFwidXBncmFkZVwiLCAoKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHNvY2tldC5jb25uLnRyYW5zcG9ydC5uYW1lKTsgLy8gcHJpbnRzIFwid2Vic29ja2V0XCJcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGdldCBjb25uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY29ubjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm9vbXMgdGhlIHNvY2tldCBpcyBjdXJyZW50bHkgaW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQucm9vbXMpOyAvLyBTZXQgeyA8c29ja2V0LmlkPiB9XG4gICAgICpcbiAgICAgKiAgIHNvY2tldC5qb2luKFwicm9vbTFcIik7XG4gICAgICpcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5yb29tcyk7IC8vIFNldCB7IDxzb2NrZXQuaWQ+LCBcInJvb20xXCIgfVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGdldCByb29tcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5zb2NrZXRSb29tcyh0aGlzLmlkKSB8fCBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgcmVjZWl2ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG9cbiAgICAgKiB0aGUgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQub25BbnkoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGBnb3QgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25BbnkobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIHJlY2VpdmVkLiBUaGUgZXZlbnQgbmFtZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvXG4gICAgICogdGhlIGNhbGxiYWNrLiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdGVuZXJzIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgcHJlcGVuZEFueShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyByZWNlaXZlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIGNvbnN0IGNhdGNoQWxsTGlzdGVuZXIgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYGdvdCBldmVudCAke2V2ZW50fWApO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogICBzb2NrZXQub25BbnkoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAgIC8vIHJlbW92ZSBhIHNwZWNpZmljIGxpc3RlbmVyXG4gICAgICogICBzb2NrZXQub2ZmQW55KGNhdGNoQWxsTGlzdGVuZXIpO1xuICAgICAqXG4gICAgICogICAvLyBvciByZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgICAqICAgc29ja2V0Lm9mZkFueSgpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb2ZmQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYW55TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyID09PSBsaXN0ZW5lcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50IHRoYXQgaXMgc3BlY2lmaWVkLiBUaGlzIGFycmF5IGNhbiBiZSBtYW5pcHVsYXRlZCxcbiAgICAgKiBlLmcuIHRvIHJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgbGlzdGVuZXJzQW55KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW55TGlzdGVuZXJzIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIHNlbnQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG9cbiAgICAgKiB0aGUgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBOb3RlOiBhY2tub3dsZWRnZW1lbnRzIHNlbnQgdG8gdGhlIGNsaWVudCBhcmUgbm90IGluY2x1ZGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpby5vbihcImNvbm5lY3Rpb25cIiwgKHNvY2tldCkgPT4ge1xuICAgICAqICAgc29ja2V0Lm9uQW55T3V0Z29pbmcoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGBzZW50IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9uQW55T3V0Z29pbmcobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgPSB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlXG4gICAgICogY2FsbGJhY2suIFRoZSBsaXN0ZW5lciBpcyBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGlvLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0KSA9PiB7XG4gICAgICogICBzb2NrZXQucHJlcGVuZEFueU91dGdvaW5nKChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcmVwZW5kQW55T3V0Z29pbmcobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgPSB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgc2VudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW8ub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQpID0+IHtcbiAgICAgKiAgIGNvbnN0IGNhdGNoQWxsTGlzdGVuZXIgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYHNlbnQgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgc29ja2V0Lm9uQW55T3V0Z29pbmcoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAgIC8vIHJlbW92ZSBhIHNwZWNpZmljIGxpc3RlbmVyXG4gICAgICogICBzb2NrZXQub2ZmQW55T3V0Z29pbmcoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAgIC8vIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzXG4gICAgICogICBzb2NrZXQub2ZmQW55T3V0Z29pbmcoKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIHRoZSBjYXRjaC1hbGwgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvZmZBbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgPT09IGxpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0aGF0IGFyZSBsaXN0ZW5pbmcgZm9yIGFueSBldmVudCB0aGF0IGlzIHNwZWNpZmllZC4gVGhpcyBhcnJheSBjYW4gYmUgbWFuaXB1bGF0ZWQsXG4gICAgICogZS5nLiB0byByZW1vdmUgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIGxpc3RlbmVyc0FueU91dGdvaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmeSB0aGUgbGlzdGVuZXJzIGZvciBlYWNoIHBhY2tldCBzZW50IChlbWl0IG9yIGJyb2FkY2FzdClcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyAmJiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdCcm9hZGNhc3RPcGVyYXRvcigpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzKTtcbiAgICAgICAgdGhpcy5mbGFncyA9IHt9O1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgbmV3IFNldCgpLCBuZXcgU2V0KFt0aGlzLmlkXSksIGZsYWdzKTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tldCA9IFNvY2tldDtcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTb2NrZXQiLCJzb2NrZXRfaW9fcGFyc2VyXzEiLCJyZXF1aXJlIiwiZGVidWdfMSIsInR5cGVkX2V2ZW50c18xIiwiYmFzZTY0aWRfMSIsImJyb2FkY2FzdF9vcGVyYXRvcl8xIiwic29ja2V0X3R5cGVzXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJSRUNPVkVSQUJMRV9ESVNDT05ORUNUX1JFQVNPTlMiLCJTZXQiLCJub29wIiwiU3RyaWN0RXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJuc3AiLCJjbGllbnQiLCJhdXRoIiwicHJldmlvdXNTZXNzaW9uIiwicmVjb3ZlcmVkIiwiZGF0YSIsImNvbm5lY3RlZCIsImFja3MiLCJNYXAiLCJmbnMiLCJmbGFncyIsInNlcnZlciIsImFkYXB0ZXIiLCJpZCIsInNpZCIsInBpZCIsInJvb21zIiwiZm9yRWFjaCIsInJvb20iLCJqb2luIiwibWlzc2VkUGFja2V0cyIsInBhY2tldCIsInR5cGUiLCJQYWNrZXRUeXBlIiwiRVZFTlQiLCJjb25uIiwicHJvdG9jb2wiLCJuYW1lIiwiZ2VuZXJhdGVJZCIsIl9vcHRzIiwiY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkiLCJoYW5kc2hha2UiLCJidWlsZEhhbmRzaGFrZSIsIm9uIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJoZWFkZXJzIiwicmVxdWVzdCIsInRpbWUiLCJEYXRlIiwiYWRkcmVzcyIsInJlbW90ZUFkZHJlc3MiLCJ4ZG9tYWluIiwib3JpZ2luIiwic2VjdXJlIiwiY29ubmVjdGlvbiIsImVuY3J5cHRlZCIsImlzc3VlZCIsInVybCIsInF1ZXJ5IiwiX3F1ZXJ5IiwiZW1pdCIsImV2IiwiYXJncyIsIlJFU0VSVkVEX0VWRU5UUyIsImhhcyIsIkVycm9yIiwiU3RyaW5nIiwibGVuZ3RoIiwiX2lkcyIsInJlZ2lzdGVyQWNrQ2FsbGJhY2siLCJwb3AiLCJhc3NpZ24iLCJvcHRzIiwiYnJvYWRjYXN0IiwiZXhjZXB0Iiwibm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMiLCJlbWl0V2l0aEFjayIsIndpdGhFcnIiLCJ0aW1lb3V0IiwidW5kZWZpbmVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwdXNoIiwiYXJnMSIsImFyZzIiLCJhY2siLCJzZXQiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJkZWxldGUiLCJjYWxsIiwiY2xlYXJUaW1lb3V0IiwiYXBwbHkiLCJ0byIsIm5ld0Jyb2FkY2FzdE9wZXJhdG9yIiwiaW4iLCJzZW5kIiwid3JpdGUiLCJjb21wcmVzcyIsIl9wYWNrZXQiLCJhZGRBbGwiLCJBcnJheSIsImlzQXJyYXkiLCJsZWF2ZSIsImRlbCIsImxlYXZlQWxsIiwiZGVsQWxsIiwiX29uY29ubmVjdCIsIkNPTk5FQ1QiLCJfb25wYWNrZXQiLCJvbmV2ZW50IiwiQklOQVJZX0VWRU5UIiwiQUNLIiwib25hY2siLCJCSU5BUllfQUNLIiwiRElTQ09OTkVDVCIsIm9uZGlzY29ubmVjdCIsIl9hbnlMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJzbGljZSIsImxpc3RlbmVyIiwiZGlzcGF0Y2giLCJzZWxmIiwic2VudCIsInByb3RvdHlwZSIsImFyZ3VtZW50cyIsImdldCIsIl9vbmNsb3NlIiwiX29uZXJyb3IiLCJlcnIiLCJlbWl0UmVzZXJ2ZWQiLCJyZWFzb24iLCJkZXNjcmlwdGlvbiIsInBlcnNpc3RTZXNzaW9uIiwiX2NsZWFudXAiLCJfcmVtb3ZlIiwiX2Vycm9yIiwiQ09OTkVDVF9FUlJPUiIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsIl9kaXNjb25uZWN0Iiwidm9sYXRpbGUiLCJsb2NhbCIsImV2ZW50IiwicnVuIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiZW1pdFVudHlwZWQiLCJ1c2UiLCJmbiIsImkiLCJkaXNjb25uZWN0ZWQiLCJzb2NrZXRSb29tcyIsIm9uQW55IiwicHJlcGVuZEFueSIsInVuc2hpZnQiLCJvZmZBbnkiLCJzcGxpY2UiLCJsaXN0ZW5lcnNBbnkiLCJvbkFueU91dGdvaW5nIiwiX2FueU91dGdvaW5nTGlzdGVuZXJzIiwicHJlcGVuZEFueU91dGdvaW5nIiwib2ZmQW55T3V0Z29pbmciLCJsaXN0ZW5lcnNBbnlPdXRnb2luZyIsIkJyb2FkY2FzdE9wZXJhdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/socket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/typed-events.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/typed-events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StrictEventEmitter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\n/**\n * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type\n * parameters for mappings of event names to event data types, and strictly\n * types method calls to the `EventEmitter` according to these event maps.\n *\n * @typeParam ListenEvents - `EventsMap` of user-defined events that can be\n * listened to with `on` or `once`\n * @typeParam EmitEvents - `EventsMap` of user-defined events that can be\n * emitted with `emit`\n * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be\n * emitted by socket.io with `emitReserved`, and can be listened to with\n * `listen`.\n */ class StrictEventEmitter extends events_1.EventEmitter {\n    /**\n     * Adds the `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */ on(ev, listener) {\n        return super.on(ev, listener);\n    }\n    /**\n     * Adds a one-time `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */ once(ev, listener) {\n        return super.once(ev, listener);\n    }\n    /**\n     * Emits an event.\n     *\n     * @param ev Name of the event\n     * @param args Values to send to listeners of this event\n     */ emit(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits a reserved event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can emit its own reserved events.\n     *\n     * @param ev Reserved event name\n     * @param args Arguments to emit along with the event\n     */ emitReserved(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits an event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can get around the strict typing. This is useful for\n     * calling `emit.apply`, which can be called as `emitUntyped.apply`.\n     *\n     * @param ev Event name\n     * @param args Arguments to emit along with the event\n     */ emitUntyped(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Returns the listeners listening to an event.\n     *\n     * @param event Event name\n     * @returns Array of listeners subscribed to `event`\n     */ listeners(event) {\n        return super.listeners(event);\n    }\n}\nexports.StrictEventEmitter = StrictEventEmitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdHlwZWQtZXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBRyxLQUFLO0FBQ2xDLE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELE1BQU1GLDJCQUEyQkMsU0FBU0UsWUFBWTtJQUNsRDs7Ozs7S0FLQyxHQUNEQyxHQUFHQyxFQUFFLEVBQUVDLFFBQVEsRUFBRTtRQUNiLE9BQU8sS0FBSyxDQUFDRixHQUFHQyxJQUFJQztJQUN4QjtJQUNBOzs7OztLQUtDLEdBQ0RDLEtBQUtGLEVBQUUsRUFBRUMsUUFBUSxFQUFFO1FBQ2YsT0FBTyxLQUFLLENBQUNDLEtBQUtGLElBQUlDO0lBQzFCO0lBQ0E7Ozs7O0tBS0MsR0FDREUsS0FBS0gsRUFBRSxFQUFFLEdBQUdJLElBQUksRUFBRTtRQUNkLE9BQU8sS0FBSyxDQUFDRCxLQUFLSCxPQUFPSTtJQUM3QjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0RDLGFBQWFMLEVBQUUsRUFBRSxHQUFHSSxJQUFJLEVBQUU7UUFDdEIsT0FBTyxLQUFLLENBQUNELEtBQUtILE9BQU9JO0lBQzdCO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0RFLFlBQVlOLEVBQUUsRUFBRSxHQUFHSSxJQUFJLEVBQUU7UUFDckIsT0FBTyxLQUFLLENBQUNELEtBQUtILE9BQU9JO0lBQzdCO0lBQ0E7Ozs7O0tBS0MsR0FDREcsVUFBVUMsS0FBSyxFQUFFO1FBQ2IsT0FBTyxLQUFLLENBQUNELFVBQVVDO0lBQzNCO0FBQ0o7QUFDQWYsMEJBQTBCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkY29kZXNfYXBwLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L3R5cGVkLWV2ZW50cy5qcz9kYzI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJpY3RFdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG4vKipcbiAqIFN0cmljdGx5IHR5cGVkIHZlcnNpb24gb2YgYW4gYEV2ZW50RW1pdHRlcmAuIEEgYFR5cGVkRXZlbnRFbWl0dGVyYCB0YWtlcyB0eXBlXG4gKiBwYXJhbWV0ZXJzIGZvciBtYXBwaW5ncyBvZiBldmVudCBuYW1lcyB0byBldmVudCBkYXRhIHR5cGVzLCBhbmQgc3RyaWN0bHlcbiAqIHR5cGVzIG1ldGhvZCBjYWxscyB0byB0aGUgYEV2ZW50RW1pdHRlcmAgYWNjb3JkaW5nIHRvIHRoZXNlIGV2ZW50IG1hcHMuXG4gKlxuICogQHR5cGVQYXJhbSBMaXN0ZW5FdmVudHMgLSBgRXZlbnRzTWFwYCBvZiB1c2VyLWRlZmluZWQgZXZlbnRzIHRoYXQgY2FuIGJlXG4gKiBsaXN0ZW5lZCB0byB3aXRoIGBvbmAgb3IgYG9uY2VgXG4gKiBAdHlwZVBhcmFtIEVtaXRFdmVudHMgLSBgRXZlbnRzTWFwYCBvZiB1c2VyLWRlZmluZWQgZXZlbnRzIHRoYXQgY2FuIGJlXG4gKiBlbWl0dGVkIHdpdGggYGVtaXRgXG4gKiBAdHlwZVBhcmFtIFJlc2VydmVkRXZlbnRzIC0gYEV2ZW50c01hcGAgb2YgcmVzZXJ2ZWQgZXZlbnRzLCB0aGF0IGNhbiBiZVxuICogZW1pdHRlZCBieSBzb2NrZXQuaW8gd2l0aCBgZW1pdFJlc2VydmVkYCwgYW5kIGNhbiBiZSBsaXN0ZW5lZCB0byB3aXRoXG4gKiBgbGlzdGVuYC5cbiAqL1xuY2xhc3MgU3RyaWN0RXZlbnRFbWl0dGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBgbGlzdGVuZXJgIGZ1bmN0aW9uIGFzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBgZXZgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IE5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIGxpc3RlbmVyIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb24oZXYsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5vbihldiwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgb25lLXRpbWUgYGxpc3RlbmVyYCBmdW5jdGlvbiBhcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgYGV2YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBOYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIG9uY2UoZXYsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5vbmNlKGV2LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IE5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIGFyZ3MgVmFsdWVzIHRvIHNlbmQgdG8gbGlzdGVuZXJzIG9mIHRoaXMgZXZlbnRcbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYSByZXNlcnZlZCBldmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGBwcm90ZWN0ZWRgLCBzbyB0aGF0IG9ubHkgYSBjbGFzcyBleHRlbmRpbmdcbiAgICAgKiBgU3RyaWN0RXZlbnRFbWl0dGVyYCBjYW4gZW1pdCBpdHMgb3duIHJlc2VydmVkIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBSZXNlcnZlZCBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgQXJndW1lbnRzIHRvIGVtaXQgYWxvbmcgd2l0aCB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBlbWl0UmVzZXJ2ZWQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGBwcm90ZWN0ZWRgLCBzbyB0aGF0IG9ubHkgYSBjbGFzcyBleHRlbmRpbmdcbiAgICAgKiBgU3RyaWN0RXZlbnRFbWl0dGVyYCBjYW4gZ2V0IGFyb3VuZCB0aGUgc3RyaWN0IHR5cGluZy4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAgICogY2FsbGluZyBgZW1pdC5hcHBseWAsIHdoaWNoIGNhbiBiZSBjYWxsZWQgYXMgYGVtaXRVbnR5cGVkLmFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBFdmVudCBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgQXJndW1lbnRzIHRvIGVtaXQgYWxvbmcgd2l0aCB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBlbWl0VW50eXBlZChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgbmFtZVxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIGxpc3RlbmVycyBzdWJzY3JpYmVkIHRvIGBldmVudGBcbiAgICAgKi9cbiAgICBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVycyhldmVudCk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJpY3RFdmVudEVtaXR0ZXIgPSBTdHJpY3RFdmVudEVtaXR0ZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdHJpY3RFdmVudEVtaXR0ZXIiLCJldmVudHNfMSIsInJlcXVpcmUiLCJFdmVudEVtaXR0ZXIiLCJvbiIsImV2IiwibGlzdGVuZXIiLCJvbmNlIiwiZW1pdCIsImFyZ3MiLCJlbWl0UmVzZXJ2ZWQiLCJlbWl0VW50eXBlZCIsImxpc3RlbmVycyIsImV2ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/typed-events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/dist/uws.js":
/*!********************************************!*\
  !*** ./node_modules/socket.io/dist/uws.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.patchAdapter = patchAdapter;\nexports.restoreAdapter = restoreAdapter;\nexports.serveFile = serveFile;\nconst socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ \"(rsc)/./node_modules/socket.io-adapter/dist/index.js\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/socket.io/node_modules/debug/src/index.js\"));\nconst debug = (0, debug_1.default)(\"socket.io:adapter-uws\");\nconst SEPARATOR = \"\\x1f\"; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;\nfunction patchAdapter(app /* : TemplatedApp */ ) {\n    socket_io_adapter_1.Adapter.prototype.addAll = function(id, rooms) {\n        const isNew = !this.sids.has(id);\n        addAll.call(this, id, rooms);\n        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);\n        if (!socket) {\n            return;\n        }\n        if (socket.conn.transport.name === \"websocket\") {\n            subscribe(this.nsp.name, socket, isNew, rooms);\n            return;\n        }\n        if (isNew) {\n            socket.conn.on(\"upgrade\", ()=>{\n                const rooms = this.sids.get(id);\n                if (rooms) {\n                    subscribe(this.nsp.name, socket, isNew, rooms);\n                }\n            });\n        }\n    };\n    socket_io_adapter_1.Adapter.prototype.del = function(id, room) {\n        del.call(this, id, room);\n        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);\n        if (socket && socket.conn.transport.name === \"websocket\") {\n            // @ts-ignore\n            const sessionId = socket.conn.id;\n            // @ts-ignore\n            const websocket = socket.conn.transport.socket;\n            const topic = `${this.nsp.name}${SEPARATOR}${room}`;\n            debug(\"unsubscribe connection %s from topic %s\", sessionId, topic);\n            websocket.unsubscribe(topic);\n        }\n    };\n    socket_io_adapter_1.Adapter.prototype.broadcast = function(packet, opts) {\n        const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;\n        if (!useFastPublish) {\n            broadcast.call(this, packet, opts);\n            return;\n        }\n        const flags = opts.flags || {};\n        const basePacketOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this.encoder.encode(packet);\n        const topic = opts.rooms.size === 0 ? this.nsp.name : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;\n        debug(\"fast publish to %s\", topic);\n        // fast publish for clients connected with WebSocket\n        encodedPackets.forEach((encodedPacket)=>{\n            const isBinary = typeof encodedPacket !== \"string\";\n            // \"4\" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol\n            app.publish(topic, isBinary ? encodedPacket : \"4\" + encodedPacket, isBinary);\n        });\n        this.apply(opts, (socket)=>{\n            if (socket.conn.transport.name !== \"websocket\") {\n                // classic publish for clients connected with HTTP long-polling\n                socket.client.writeToEngine(encodedPackets, basePacketOpts);\n            }\n        });\n    };\n}\nfunction subscribe(namespaceName, socket, isNew, rooms) {\n    // @ts-ignore\n    const sessionId = socket.conn.id;\n    // @ts-ignore\n    const websocket = socket.conn.transport.socket;\n    if (isNew) {\n        debug(\"subscribe connection %s to topic %s\", sessionId, namespaceName);\n        websocket.subscribe(namespaceName);\n    }\n    rooms.forEach((room)=>{\n        const topic = `${namespaceName}${SEPARATOR}${room}`; // '#' can be used as wildcard\n        debug(\"subscribe connection %s to topic %s\", sessionId, topic);\n        websocket.subscribe(topic);\n    });\n}\nfunction restoreAdapter() {\n    socket_io_adapter_1.Adapter.prototype.addAll = addAll;\n    socket_io_adapter_1.Adapter.prototype.del = del;\n    socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;\n}\nconst toArrayBuffer = (buffer)=>{\n    const { buffer: arrayBuffer, byteOffset, byteLength } = buffer;\n    return arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n};\n// imported from https://github.com/kolodziejczak-sz/uwebsocket-serve\nfunction serveFile(res /* : HttpResponse */ , filepath) {\n    const { size } = (0, fs_1.statSync)(filepath);\n    const readStream = (0, fs_1.createReadStream)(filepath);\n    const destroyReadStream = ()=>!readStream.destroyed && readStream.destroy();\n    const onError = (error)=>{\n        destroyReadStream();\n        throw error;\n    };\n    const onDataChunk = (chunk)=>{\n        const arrayBufferChunk = toArrayBuffer(chunk);\n        res.cork(()=>{\n            const lastOffset = res.getWriteOffset();\n            const [ok, done] = res.tryEnd(arrayBufferChunk, size);\n            if (!done && !ok) {\n                readStream.pause();\n                res.onWritable((offset)=>{\n                    const [ok, done] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);\n                    if (!done && ok) {\n                        readStream.resume();\n                    }\n                    return ok;\n                });\n            }\n        });\n    };\n    res.onAborted(destroyReadStream);\n    readStream.on(\"data\", onDataChunk).on(\"error\", onError).on(\"end\", destroyReadStream);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvdXdzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0U7QUFDdkJGLHNCQUFzQixHQUFHRztBQUN6QkgsaUJBQWlCLEdBQUdJO0FBQ3BCLE1BQU1DLHNCQUFzQkMsbUJBQU9BLENBQUMsK0VBQW1CO0FBQ3ZELE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDLGNBQUk7QUFDekIsTUFBTUUsVUFBVWIsZ0JBQWdCVyxtQkFBT0EsQ0FBQyw2RUFBTztBQUMvQyxNQUFNRyxRQUFRLENBQUMsR0FBR0QsUUFBUUUsT0FBTyxFQUFFO0FBQ25DLE1BQU1DLFlBQVksUUFBUSxtRUFBbUU7QUFDN0YsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsU0FBUyxFQUFFLEdBQUdULG9CQUFvQlUsT0FBTyxDQUFDQyxTQUFTO0FBQ3hFLFNBQVNkLGFBQWFlLElBQUksa0JBQWtCLEdBQW5CO0lBQ3JCWixvQkFBb0JVLE9BQU8sQ0FBQ0MsU0FBUyxDQUFDSixNQUFNLEdBQUcsU0FBVU0sRUFBRSxFQUFFQyxLQUFLO1FBQzlELE1BQU1DLFFBQVEsQ0FBQyxJQUFJLENBQUNDLElBQUksQ0FBQ0MsR0FBRyxDQUFDSjtRQUM3Qk4sT0FBT1csSUFBSSxDQUFDLElBQUksRUFBRUwsSUFBSUM7UUFDdEIsTUFBTUssU0FBUyxJQUFJLENBQUNDLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDQyxHQUFHLENBQUNULE9BQU8sSUFBSSxDQUFDTyxHQUFHLENBQUNHLGtCQUFrQixDQUFDRCxHQUFHLENBQUNUO1FBQzNFLElBQUks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QyxHQUFHbkMsS0FBSytELFFBQVEsRUFBRUQ7SUFDcEMsTUFBTUUsYUFBYSxDQUFDLEdBQUdoRSxLQUFLaUUsZ0JBQWdCLEVBQUVIO0lBQzlDLE1BQU1JLG9CQUFvQixJQUFNLENBQUNGLFdBQVdHLFNBQVMsSUFBSUgsV0FBV0ksT0FBTztJQUMzRSxNQUFNQyxVQUFVLENBQUNDO1FBQ2JKO1FBQ0EsTUFBTUk7SUFDVjtJQUNBLE1BQU1DLGNBQWMsQ0FBQ0M7UUFDakIsTUFBTUMsbUJBQW1CbEIsY0FBY2lCO1FBQ3ZDWCxJQUFJYSxJQUFJLENBQUM7WUFDTCxNQUFNQyxhQUFhZCxJQUFJZSxjQUFjO1lBQ3JDLE1BQU0sQ0FBQ0MsSUFBSUMsS0FBSyxHQUFHakIsSUFBSWtCLE1BQU0sQ0FBQ04sa0JBQWtCdEM7WUFDaEQsSUFBSSxDQUFDMkMsUUFBUSxDQUFDRCxJQUFJO2dCQUNkYixXQUFXZ0IsS0FBSztnQkFDaEJuQixJQUFJb0IsVUFBVSxDQUFDLENBQUNDO29CQUNaLE1BQU0sQ0FBQ0wsSUFBSUMsS0FBSyxHQUFHakIsSUFBSWtCLE1BQU0sQ0FBQ04saUJBQWlCYixLQUFLLENBQUNzQixTQUFTUCxhQUFheEM7b0JBQzNFLElBQUksQ0FBQzJDLFFBQVFELElBQUk7d0JBQ2JiLFdBQVdtQixNQUFNO29CQUNyQjtvQkFDQSxPQUFPTjtnQkFDWDtZQUNKO1FBQ0o7SUFDSjtJQUNBaEIsSUFBSXVCLFNBQVMsQ0FBQ2xCO0lBQ2RGLFdBQ0t0QyxFQUFFLENBQUMsUUFBUTZDLGFBQ1g3QyxFQUFFLENBQUMsU0FBUzJDLFNBQ1ozQyxFQUFFLENBQUMsT0FBT3dDO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkY29kZXNfYXBwLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L3V3cy5qcz8wYmQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXRjaEFkYXB0ZXIgPSBwYXRjaEFkYXB0ZXI7XG5leHBvcnRzLnJlc3RvcmVBZGFwdGVyID0gcmVzdG9yZUFkYXB0ZXI7XG5leHBvcnRzLnNlcnZlRmlsZSA9IHNlcnZlRmlsZTtcbmNvbnN0IHNvY2tldF9pb19hZGFwdGVyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLWFkYXB0ZXJcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pbzphZGFwdGVyLXV3c1wiKTtcbmNvbnN0IFNFUEFSQVRPUiA9IFwiXFx4MWZcIjsgLy8gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlbGltaXRlciNBU0NJSV9kZWxpbWl0ZWRfdGV4dFxuY29uc3QgeyBhZGRBbGwsIGRlbCwgYnJvYWRjYXN0IH0gPSBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlO1xuZnVuY3Rpb24gcGF0Y2hBZGFwdGVyKGFwcCAvKiA6IFRlbXBsYXRlZEFwcCAqLykge1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gKGlkLCByb29tcykge1xuICAgICAgICBjb25zdCBpc05ldyA9ICF0aGlzLnNpZHMuaGFzKGlkKTtcbiAgICAgICAgYWRkQWxsLmNhbGwodGhpcywgaWQsIHJvb21zKTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3Auc29ja2V0cy5nZXQoaWQpIHx8IHRoaXMubnNwLl9wcmVDb25uZWN0U29ja2V0cy5nZXQoaWQpO1xuICAgICAgICBpZiAoIXNvY2tldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2NrZXQuY29ubi50cmFuc3BvcnQubmFtZSA9PT0gXCJ3ZWJzb2NrZXRcIikge1xuICAgICAgICAgICAgc3Vic2NyaWJlKHRoaXMubnNwLm5hbWUsIHNvY2tldCwgaXNOZXcsIHJvb21zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgIHNvY2tldC5jb25uLm9uKFwidXBncmFkZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vbXMgPSB0aGlzLnNpZHMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBpZiAocm9vbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlKHRoaXMubnNwLm5hbWUsIHNvY2tldCwgaXNOZXcsIHJvb21zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoaWQsIHJvb20pIHtcbiAgICAgICAgZGVsLmNhbGwodGhpcywgaWQsIHJvb20pO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcC5zb2NrZXRzLmdldChpZCkgfHwgdGhpcy5uc3AuX3ByZUNvbm5lY3RTb2NrZXRzLmdldChpZCk7XG4gICAgICAgIGlmIChzb2NrZXQgJiYgc29ja2V0LmNvbm4udHJhbnNwb3J0Lm5hbWUgPT09IFwid2Vic29ja2V0XCIpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHNvY2tldC5jb25uLmlkO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgd2Vic29ja2V0ID0gc29ja2V0LmNvbm4udHJhbnNwb3J0LnNvY2tldDtcbiAgICAgICAgICAgIGNvbnN0IHRvcGljID0gYCR7dGhpcy5uc3AubmFtZX0ke1NFUEFSQVRPUn0ke3Jvb219YDtcbiAgICAgICAgICAgIGRlYnVnKFwidW5zdWJzY3JpYmUgY29ubmVjdGlvbiAlcyBmcm9tIHRvcGljICVzXCIsIHNlc3Npb25JZCwgdG9waWMpO1xuICAgICAgICAgICAgd2Vic29ja2V0LnVuc3Vic2NyaWJlKHRvcGljKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5icm9hZGNhc3QgPSBmdW5jdGlvbiAocGFja2V0LCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHVzZUZhc3RQdWJsaXNoID0gb3B0cy5yb29tcy5zaXplIDw9IDEgJiYgb3B0cy5leGNlcHQuc2l6ZSA9PT0gMDtcbiAgICAgICAgaWYgKCF1c2VGYXN0UHVibGlzaCkge1xuICAgICAgICAgICAgYnJvYWRjYXN0LmNhbGwodGhpcywgcGFja2V0LCBvcHRzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbGFncyA9IG9wdHMuZmxhZ3MgfHwge307XG4gICAgICAgIGNvbnN0IGJhc2VQYWNrZXRPcHRzID0ge1xuICAgICAgICAgICAgcHJlRW5jb2RlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZvbGF0aWxlOiBmbGFncy52b2xhdGlsZSxcbiAgICAgICAgICAgIGNvbXByZXNzOiBmbGFncy5jb21wcmVzcyxcbiAgICAgICAgfTtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gICAgICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQpO1xuICAgICAgICBjb25zdCB0b3BpYyA9IG9wdHMucm9vbXMuc2l6ZSA9PT0gMFxuICAgICAgICAgICAgPyB0aGlzLm5zcC5uYW1lXG4gICAgICAgICAgICA6IGAke3RoaXMubnNwLm5hbWV9JHtTRVBBUkFUT1J9JHtvcHRzLnJvb21zLmtleXMoKS5uZXh0KCkudmFsdWV9YDtcbiAgICAgICAgZGVidWcoXCJmYXN0IHB1Ymxpc2ggdG8gJXNcIiwgdG9waWMpO1xuICAgICAgICAvLyBmYXN0IHB1Ymxpc2ggZm9yIGNsaWVudHMgY29ubmVjdGVkIHdpdGggV2ViU29ja2V0XG4gICAgICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goKGVuY29kZWRQYWNrZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQmluYXJ5ID0gdHlwZW9mIGVuY29kZWRQYWNrZXQgIT09IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAvLyBcIjRcIiBiZWluZyB0aGUgbWVzc2FnZSB0eXBlIGluIHRoZSBFbmdpbmUuSU8gcHJvdG9jb2wsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vZW5naW5lLmlvLXByb3RvY29sXG4gICAgICAgICAgICBhcHAucHVibGlzaCh0b3BpYywgaXNCaW5hcnkgPyBlbmNvZGVkUGFja2V0IDogXCI0XCIgKyBlbmNvZGVkUGFja2V0LCBpc0JpbmFyeSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQuY29ubi50cmFuc3BvcnQubmFtZSAhPT0gXCJ3ZWJzb2NrZXRcIikge1xuICAgICAgICAgICAgICAgIC8vIGNsYXNzaWMgcHVibGlzaCBmb3IgY2xpZW50cyBjb25uZWN0ZWQgd2l0aCBIVFRQIGxvbmctcG9sbGluZ1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbGllbnQud3JpdGVUb0VuZ2luZShlbmNvZGVkUGFja2V0cywgYmFzZVBhY2tldE9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlKG5hbWVzcGFjZU5hbWUsIHNvY2tldCwgaXNOZXcsIHJvb21zKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHNlc3Npb25JZCA9IHNvY2tldC5jb25uLmlkO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSBzb2NrZXQuY29ubi50cmFuc3BvcnQuc29ja2V0O1xuICAgIGlmIChpc05ldykge1xuICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZSBjb25uZWN0aW9uICVzIHRvIHRvcGljICVzXCIsIHNlc3Npb25JZCwgbmFtZXNwYWNlTmFtZSk7XG4gICAgICAgIHdlYnNvY2tldC5zdWJzY3JpYmUobmFtZXNwYWNlTmFtZSk7XG4gICAgfVxuICAgIHJvb21zLmZvckVhY2goKHJvb20pID0+IHtcbiAgICAgICAgY29uc3QgdG9waWMgPSBgJHtuYW1lc3BhY2VOYW1lfSR7U0VQQVJBVE9SfSR7cm9vbX1gOyAvLyAnIycgY2FuIGJlIHVzZWQgYXMgd2lsZGNhcmRcbiAgICAgICAgZGVidWcoXCJzdWJzY3JpYmUgY29ubmVjdGlvbiAlcyB0byB0b3BpYyAlc1wiLCBzZXNzaW9uSWQsIHRvcGljKTtcbiAgICAgICAgd2Vic29ja2V0LnN1YnNjcmliZSh0b3BpYyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXN0b3JlQWRhcHRlcigpIHtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmFkZEFsbCA9IGFkZEFsbDtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmRlbCA9IGRlbDtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGJyb2FkY2FzdDtcbn1cbmNvbnN0IHRvQXJyYXlCdWZmZXIgPSAoYnVmZmVyKSA9PiB7XG4gICAgY29uc3QgeyBidWZmZXI6IGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0gPSBidWZmZXI7XG4gICAgcmV0dXJuIGFycmF5QnVmZmVyLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbn07XG4vLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rb2xvZHppZWpjemFrLXN6L3V3ZWJzb2NrZXQtc2VydmVcbmZ1bmN0aW9uIHNlcnZlRmlsZShyZXMgLyogOiBIdHRwUmVzcG9uc2UgKi8sIGZpbGVwYXRoKSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSAoMCwgZnNfMS5zdGF0U3luYykoZmlsZXBhdGgpO1xuICAgIGNvbnN0IHJlYWRTdHJlYW0gPSAoMCwgZnNfMS5jcmVhdGVSZWFkU3RyZWFtKShmaWxlcGF0aCk7XG4gICAgY29uc3QgZGVzdHJveVJlYWRTdHJlYW0gPSAoKSA9PiAhcmVhZFN0cmVhbS5kZXN0cm95ZWQgJiYgcmVhZFN0cmVhbS5kZXN0cm95KCk7XG4gICAgY29uc3Qgb25FcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBkZXN0cm95UmVhZFN0cmVhbSgpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9O1xuICAgIGNvbnN0IG9uRGF0YUNodW5rID0gKGNodW5rKSA9PiB7XG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyQ2h1bmsgPSB0b0FycmF5QnVmZmVyKGNodW5rKTtcbiAgICAgICAgcmVzLmNvcmsoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFzdE9mZnNldCA9IHJlcy5nZXRXcml0ZU9mZnNldCgpO1xuICAgICAgICAgICAgY29uc3QgW29rLCBkb25lXSA9IHJlcy50cnlFbmQoYXJyYXlCdWZmZXJDaHVuaywgc2l6ZSk7XG4gICAgICAgICAgICBpZiAoIWRvbmUgJiYgIW9rKSB7XG4gICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIHJlcy5vbldyaXRhYmxlKChvZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW29rLCBkb25lXSA9IHJlcy50cnlFbmQoYXJyYXlCdWZmZXJDaHVuay5zbGljZShvZmZzZXQgLSBsYXN0T2Zmc2V0KSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSAmJiBvaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5yZXN1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2s7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmVzLm9uQWJvcnRlZChkZXN0cm95UmVhZFN0cmVhbSk7XG4gICAgcmVhZFN0cmVhbVxuICAgICAgICAub24oXCJkYXRhXCIsIG9uRGF0YUNodW5rKVxuICAgICAgICAub24oXCJlcnJvclwiLCBvbkVycm9yKVxuICAgICAgICAub24oXCJlbmRcIiwgZGVzdHJveVJlYWRTdHJlYW0pO1xufVxuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhdGNoQWRhcHRlciIsInJlc3RvcmVBZGFwdGVyIiwic2VydmVGaWxlIiwic29ja2V0X2lvX2FkYXB0ZXJfMSIsInJlcXVpcmUiLCJmc18xIiwiZGVidWdfMSIsImRlYnVnIiwiZGVmYXVsdCIsIlNFUEFSQVRPUiIsImFkZEFsbCIsImRlbCIsImJyb2FkY2FzdCIsIkFkYXB0ZXIiLCJwcm90b3R5cGUiLCJhcHAiLCJpZCIsInJvb21zIiwiaXNOZXciLCJzaWRzIiwiaGFzIiwiY2FsbCIsInNvY2tldCIsIm5zcCIsInNvY2tldHMiLCJnZXQiLCJfcHJlQ29ubmVjdFNvY2tldHMiLCJjb25uIiwidHJhbnNwb3J0IiwibmFtZSIsInN1YnNjcmliZSIsIm9uIiwicm9vbSIsInNlc3Npb25JZCIsIndlYnNvY2tldCIsInRvcGljIiwidW5zdWJzY3JpYmUiLCJwYWNrZXQiLCJvcHRzIiwidXNlRmFzdFB1Ymxpc2giLCJzaXplIiwiZXhjZXB0IiwiZmxhZ3MiLCJiYXNlUGFja2V0T3B0cyIsInByZUVuY29kZWQiLCJ2b2xhdGlsZSIsImNvbXByZXNzIiwiZW5jb2RlZFBhY2tldHMiLCJlbmNvZGVyIiwiZW5jb2RlIiwia2V5cyIsIm5leHQiLCJmb3JFYWNoIiwiZW5jb2RlZFBhY2tldCIsImlzQmluYXJ5IiwicHVibGlzaCIsImFwcGx5IiwiY2xpZW50Iiwid3JpdGVUb0VuZ2luZSIsIm5hbWVzcGFjZU5hbWUiLCJ0b0FycmF5QnVmZmVyIiwiYnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsInNsaWNlIiwicmVzIiwiZmlsZXBhdGgiLCJzdGF0U3luYyIsInJlYWRTdHJlYW0iLCJjcmVhdGVSZWFkU3RyZWFtIiwiZGVzdHJveVJlYWRTdHJlYW0iLCJkZXN0cm95ZWQiLCJkZXN0cm95Iiwib25FcnJvciIsImVycm9yIiwib25EYXRhQ2h1bmsiLCJjaHVuayIsImFycmF5QnVmZmVyQ2h1bmsiLCJjb3JrIiwibGFzdE9mZnNldCIsImdldFdyaXRlT2Zmc2V0Iiwib2siLCJkb25lIiwidHJ5RW5kIiwicGF1c2UiLCJvbldyaXRhYmxlIiwib2Zmc2V0IiwicmVzdW1lIiwib25BYm9ydGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/dist/uws.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/wrapper.mjs":
/*!********************************************!*\
  !*** ./node_modules/socket.io/wrapper.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Namespace: () => (/* binding */ Namespace),\n/* harmony export */   Server: () => (/* binding */ Server),\n/* harmony export */   Socket: () => (/* binding */ Socket)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(rsc)/./node_modules/socket.io/dist/index.js\");\n\nconst { Server, Namespace, Socket } = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL3dyYXBwZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUM7QUFFMUIsTUFBTSxFQUFDQyxNQUFNLEVBQUVDLFNBQVMsRUFBRUMsTUFBTSxFQUFDLEdBQUdILDJDQUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkY29kZXNfYXBwLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby93cmFwcGVyLm1qcz8xZDkxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpbyBmcm9tIFwiLi9kaXN0L2luZGV4LmpzXCI7XG5cbmV4cG9ydCBjb25zdCB7U2VydmVyLCBOYW1lc3BhY2UsIFNvY2tldH0gPSBpbztcbiJdLCJuYW1lcyI6WyJpbyIsIlNlcnZlciIsIk5hbWVzcGFjZSIsIlNvY2tldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socket.io/wrapper.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/socket.io/package.json":
/*!*********************************************!*\
  !*** ./node_modules/socket.io/package.json ***!
  \*********************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"socket.io","version":"4.8.1","description":"node.js realtime framework server","keywords":["realtime","framework","websocket","tcp","events","socket","io"],"files":["dist/","client-dist/","wrapper.mjs","!**/*.tsbuildinfo"],"directories":{"doc":"docs/","example":"example/","lib":"lib/","test":"test/"},"type":"commonjs","main":"./dist/index.js","exports":{"types":"./dist/index.d.ts","import":"./wrapper.mjs","require":"./dist/index.js"},"types":"./dist/index.d.ts","license":"MIT","homepage":"https://github.com/socketio/socket.io/tree/main/packages/socket.io#readme","repository":{"type":"git","url":"git+https://github.com/socketio/socket.io.git"},"bugs":{"url":"https://github.com/socketio/socket.io/issues"},"scripts":{"compile":"rimraf ./dist && tsc","test":"npm run format:check && npm run compile && npm run test:types && npm run test:unit","test:types":"tsd","test:unit":"nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/index.ts","format:check":"prettier --check \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","format:fix":"prettier --write \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","prepack":"npm run compile"},"dependencies":{"accepts":"~1.3.4","base64id":"~2.0.0","cors":"~2.8.5","debug":"~4.3.2","engine.io":"~6.6.0","socket.io-adapter":"~2.5.2","socket.io-parser":"~4.2.4"},"contributors":[{"name":"Guillermo Rauch","email":"rauchg@gmail.com"},{"name":"Arnout Kazemier","email":"info@3rd-eden.com"},{"name":"Vladimir Dronnikov","email":"dronnikov@gmail.com"},{"name":"Einar Otto Stangvik","email":"einaros@gmail.com"}],"engines":{"node":">=10.2.0"},"tsd":{"directory":"test"}}');

/***/ })

};
;