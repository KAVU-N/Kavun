"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cookie";
exports.ids = ["vendor-chunks/cookie"];
exports.modules = {

/***/ "(rsc)/./node_modules/cookie/index.js":
/*!**************************************!*\
  !*** ./node_modules/cookie/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\r\n * cookie\r\n * Copyright(c) 2012-2014 Roman Shtylman\r\n * Copyright(c) 2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */ \n/**\r\n * Module exports.\r\n * @public\r\n */ exports.parse = parse;\nexports.serialize = serialize;\n/**\r\n * Module variables.\r\n * @private\r\n */ var __toString = Object.prototype.toString;\nvar __hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\r\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\r\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\r\n * which has been replaced by the token definition in RFC 7230 appendix B.\r\n *\r\n * cookie-name       = token\r\n * token             = 1*tchar\r\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\r\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\r\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\r\n */ var cookieNameRegExp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\n/**\r\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\r\n *\r\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\r\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\r\n *                     ; US-ASCII characters excluding CTLs,\r\n *                     ; whitespace DQUOTE, comma, semicolon,\r\n *                     ; and backslash\r\n */ var cookieValueRegExp = /^(\"?)[\\u0021\\u0023-\\u002B\\u002D-\\u003A\\u003C-\\u005B\\u005D-\\u007E]*\\1$/;\n/**\r\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\r\n *\r\n * domain-value      = <subdomain>\r\n *                     ; defined in [RFC1034], Section 3.5, as\r\n *                     ; enhanced by [RFC1123], Section 2.1\r\n * <subdomain>       = <label> | <subdomain> \".\" <label>\r\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\r\n *                     Labels must be 63 characters or less.\r\n *                     'let-dig' not 'letter' in the first char, per RFC1123\r\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\r\n * <let-dig-hyp>     = <let-dig> | \"-\"\r\n * <let-dig>         = <letter> | <digit>\r\n * <letter>          = any one of the 52 alphabetic characters A through Z in\r\n *                     upper case and a through z in lower case\r\n * <digit>           = any one of the ten digits 0 through 9\r\n *\r\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\r\n *\r\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\r\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\r\n * cause the user agent to ignore the attribute.)\r\n */ var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n/**\r\n * RegExp to match path-value in RFC 6265 sec 4.1.1\r\n *\r\n * path-value        = <any CHAR except CTLs or \";\">\r\n * CHAR              = %x01-7F\r\n *                     ; defined in RFC 5234 appendix B.1\r\n */ var pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\n/**\r\n * Parse a cookie header.\r\n *\r\n * Parse the given cookie header string into an object\r\n * The object has the various cookies as keys(names) => values\r\n *\r\n * @param {string} str\r\n * @param {object} [opt]\r\n * @return {object}\r\n * @public\r\n */ function parse(str, opt) {\n    if (typeof str !== \"string\") {\n        throw new TypeError(\"argument str must be a string\");\n    }\n    var obj = {};\n    var len = str.length;\n    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n    if (len < 2) return obj;\n    var dec = opt && opt.decode || decode;\n    var index = 0;\n    var eqIdx = 0;\n    var endIdx = 0;\n    do {\n        eqIdx = str.indexOf(\"=\", index);\n        if (eqIdx === -1) break; // No more cookie pairs.\n        endIdx = str.indexOf(\";\", index);\n        if (endIdx === -1) {\n            endIdx = len;\n        } else if (eqIdx > endIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n        var keyStartIdx = startIndex(str, index, eqIdx);\n        var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n        var key = str.slice(keyStartIdx, keyEndIdx);\n        // only assign once\n        if (!__hasOwnProperty.call(obj, key)) {\n            var valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n            var valEndIdx = endIndex(str, endIdx, valStartIdx);\n            if (str.charCodeAt(valStartIdx) === 0x22 /* \" */  && str.charCodeAt(valEndIdx - 1) === 0x22 /* \" */ ) {\n                valStartIdx++;\n                valEndIdx--;\n            }\n            var val = str.slice(valStartIdx, valEndIdx);\n            obj[key] = tryDecode(val, dec);\n        }\n        index = endIdx + 1;\n    }while (index < len);\n    return obj;\n}\nfunction startIndex(str, index, max) {\n    do {\n        var code = str.charCodeAt(index);\n        if (code !== 0x20 /*   */  && code !== 0x09 /* \\t */ ) return index;\n    }while (++index < max);\n    return max;\n}\nfunction endIndex(str, index, min) {\n    while(index > min){\n        var code = str.charCodeAt(--index);\n        if (code !== 0x20 /*   */  && code !== 0x09 /* \\t */ ) return index + 1;\n    }\n    return min;\n}\n/**\r\n * Serialize data into a cookie header.\r\n *\r\n * Serialize a name value pair into a cookie string suitable for\r\n * http headers. An optional options object specifies cookie parameters.\r\n *\r\n * serialize('foo', 'bar', { httpOnly: true })\r\n *   => \"foo=bar; httpOnly\"\r\n *\r\n * @param {string} name\r\n * @param {string} val\r\n * @param {object} [opt]\r\n * @return {string}\r\n * @public\r\n */ function serialize(name, val, opt) {\n    var enc = opt && opt.encode || encodeURIComponent;\n    if (typeof enc !== \"function\") {\n        throw new TypeError(\"option encode is invalid\");\n    }\n    if (!cookieNameRegExp.test(name)) {\n        throw new TypeError(\"argument name is invalid\");\n    }\n    var value = enc(val);\n    if (!cookieValueRegExp.test(value)) {\n        throw new TypeError(\"argument val is invalid\");\n    }\n    var str = name + \"=\" + value;\n    if (!opt) return str;\n    if (null != opt.maxAge) {\n        var maxAge = Math.floor(opt.maxAge);\n        if (!isFinite(maxAge)) {\n            throw new TypeError(\"option maxAge is invalid\");\n        }\n        str += \"; Max-Age=\" + maxAge;\n    }\n    if (opt.domain) {\n        if (!domainValueRegExp.test(opt.domain)) {\n            throw new TypeError(\"option domain is invalid\");\n        }\n        str += \"; Domain=\" + opt.domain;\n    }\n    if (opt.path) {\n        if (!pathValueRegExp.test(opt.path)) {\n            throw new TypeError(\"option path is invalid\");\n        }\n        str += \"; Path=\" + opt.path;\n    }\n    if (opt.expires) {\n        var expires = opt.expires;\n        if (!isDate(expires) || isNaN(expires.valueOf())) {\n            throw new TypeError(\"option expires is invalid\");\n        }\n        str += \"; Expires=\" + expires.toUTCString();\n    }\n    if (opt.httpOnly) {\n        str += \"; HttpOnly\";\n    }\n    if (opt.secure) {\n        str += \"; Secure\";\n    }\n    if (opt.partitioned) {\n        str += \"; Partitioned\";\n    }\n    if (opt.priority) {\n        var priority = typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n        switch(priority){\n            case \"low\":\n                str += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                str += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                str += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(\"option priority is invalid\");\n        }\n    }\n    if (opt.sameSite) {\n        var sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n        switch(sameSite){\n            case true:\n                str += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                str += \"; SameSite=Lax\";\n                break;\n            case \"strict\":\n                str += \"; SameSite=Strict\";\n                break;\n            case \"none\":\n                str += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(\"option sameSite is invalid\");\n        }\n    }\n    return str;\n}\n/**\r\n * URL-decode string value. Optimized to skip native call when no %.\r\n *\r\n * @param {string} str\r\n * @returns {string}\r\n */ function decode(str) {\n    return str.indexOf(\"%\") !== -1 ? decodeURIComponent(str) : str;\n}\n/**\r\n * Determine if value is a Date.\r\n *\r\n * @param {*} val\r\n * @private\r\n */ function isDate(val) {\n    return __toString.call(val) === \"[object Date]\";\n}\n/**\r\n * Try decoding a string using a decoding function.\r\n *\r\n * @param {string} str\r\n * @param {function} decode\r\n * @private\r\n */ function tryDecode(str, decode) {\n    try {\n        return decode(str);\n    } catch (e) {\n        return str;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY29va2llL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDLEdBRUQ7QUFFQTs7O0NBR0MsR0FFREEsYUFBYSxHQUFHQztBQUNoQkQsaUJBQWlCLEdBQUdFO0FBRXBCOzs7Q0FHQyxHQUVELElBQUlDLGFBQWFDLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUTtBQUMxQyxJQUFJQyxtQkFBbUJILE9BQU9DLFNBQVMsQ0FBQ0csY0FBYztBQUV0RDs7Ozs7Ozs7OztDQVVDLEdBRUQsSUFBSUMsbUJBQW1CO0FBRXZCOzs7Ozs7OztDQVFDLEdBRUQsSUFBSUMsb0JBQW9CO0FBRXhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBRUQsSUFBSUMsb0JBQW9CO0FBRXhCOzs7Ozs7Q0FNQyxHQUVELElBQUlDLGtCQUFrQjtBQUV0Qjs7Ozs7Ozs7OztDQVVDLEdBRUQsU0FBU1gsTUFBTVksR0FBRyxFQUFFQyxHQUFHO0lBQ3JCLElBQUksT0FBT0QsUUFBUSxVQUFVO1FBQzNCLE1BQU0sSUFBSUUsVUFBVTtJQUN0QjtJQUVBLElBQUlDLE1BQU0sQ0FBQztJQUNYLElBQUlDLE1BQU1KLElBQUlLLE1BQU07SUFDcEIsaUdBQWlHO0lBQ2pHLElBQUlELE1BQU0sR0FBRyxPQUFPRDtJQUVwQixJQUFJRyxNQUFNLE9BQVFMLElBQUlNLE1BQU0sSUFBS0E7SUFDakMsSUFBSUMsUUFBUTtJQUNaLElBQUlDLFFBQVE7SUFDWixJQUFJQyxTQUFTO0lBRWIsR0FBRztRQUNERCxRQUFRVCxJQUFJVyxPQUFPLENBQUMsS0FBS0g7UUFDekIsSUFBSUMsVUFBVSxDQUFDLEdBQUcsT0FBTyx3QkFBd0I7UUFFakRDLFNBQVNWLElBQUlXLE9BQU8sQ0FBQyxLQUFLSDtRQUUxQixJQUFJRSxXQUFXLENBQUMsR0FBRztZQUNqQkEsU0FBU047UUFDWCxPQUFPLElBQUlLLFFBQVFDLFFBQVE7WUFDekIsK0JBQStCO1lBQy9CRixRQUFRUixJQUFJWSxXQUFX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UVAsR0FBRztJQUNsQixPQUFPQSxJQUFJVyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQ3pCd0MsbUJBQW1CbkQsT0FDbkJBO0FBQ047QUFFQTs7Ozs7Q0FLQyxHQUVELFNBQVN5QyxPQUFRbEIsR0FBRztJQUNsQixPQUFPakMsV0FBVzZCLElBQUksQ0FBQ0ksU0FBUztBQUNsQztBQUVBOzs7Ozs7Q0FNQyxHQUVELFNBQVNDLFVBQVV4QixHQUFHLEVBQUVPLE1BQU07SUFDNUIsSUFBSTtRQUNGLE9BQU9BLE9BQU9QO0lBQ2hCLEVBQUUsT0FBT29ELEdBQUc7UUFDVixPQUFPcEQ7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkY29kZXNfYXBwLy4vbm9kZV9tb2R1bGVzL2Nvb2tpZS9pbmRleC5qcz81ZDMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gKiBjb29raWVcclxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBSb21hbiBTaHR5bG1hblxyXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxyXG4gKiBNSVQgTGljZW5zZWRcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogTW9kdWxlIGV4cG9ydHMuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcblxyXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XHJcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xyXG5cclxuLyoqXHJcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxudmFyIF9fdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXHJcbnZhciBfX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxyXG5cclxuLyoqXHJcbiAqIFJlZ0V4cCB0byBtYXRjaCBjb29raWUtbmFtZSBpbiBSRkMgNjI2NSBzZWMgNC4xLjFcclxuICogVGhpcyByZWZlcnMgb3V0IHRvIHRoZSBvYnNvbGV0ZWQgZGVmaW5pdGlvbiBvZiB0b2tlbiBpbiBSRkMgMjYxNiBzZWMgMi4yXHJcbiAqIHdoaWNoIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IHRoZSB0b2tlbiBkZWZpbml0aW9uIGluIFJGQyA3MjMwIGFwcGVuZGl4IEIuXHJcbiAqXHJcbiAqIGNvb2tpZS1uYW1lICAgICAgID0gdG9rZW5cclxuICogdG9rZW4gICAgICAgICAgICAgPSAxKnRjaGFyXHJcbiAqIHRjaGFyICAgICAgICAgICAgID0gXCIhXCIgLyBcIiNcIiAvIFwiJFwiIC8gXCIlXCIgLyBcIiZcIiAvIFwiJ1wiIC9cclxuICogICAgICAgICAgICAgICAgICAgICBcIipcIiAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiAvIFwiXlwiIC8gXCJfXCIgL1xyXG4gKiAgICAgICAgICAgICAgICAgICAgIFwiYFwiIC8gXCJ8XCIgLyBcIn5cIiAvIERJR0lUIC8gQUxQSEFcclxuICovXHJcblxyXG52YXIgY29va2llTmFtZVJlZ0V4cCA9IC9eWyEjJCUmJyorXFwtLl5fYHx+MC05QS1aYS16XSskLztcclxuXHJcbi8qKlxyXG4gKiBSZWdFeHAgdG8gbWF0Y2ggY29va2llLXZhbHVlIGluIFJGQyA2MjY1IHNlYyA0LjEuMVxyXG4gKlxyXG4gKiBjb29raWUtdmFsdWUgICAgICA9ICpjb29raWUtb2N0ZXQgLyAoIERRVU9URSAqY29va2llLW9jdGV0IERRVU9URSApXHJcbiAqIGNvb2tpZS1vY3RldCAgICAgID0gJXgyMSAvICV4MjMtMkIgLyAleDJELTNBIC8gJXgzQy01QiAvICV4NUQtN0VcclxuICogICAgICAgICAgICAgICAgICAgICA7IFVTLUFTQ0lJIGNoYXJhY3RlcnMgZXhjbHVkaW5nIENUTHMsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgOyB3aGl0ZXNwYWNlIERRVU9URSwgY29tbWEsIHNlbWljb2xvbixcclxuICogICAgICAgICAgICAgICAgICAgICA7IGFuZCBiYWNrc2xhc2hcclxuICovXHJcblxyXG52YXIgY29va2llVmFsdWVSZWdFeHAgPSAvXihcIj8pW1xcdTAwMjFcXHUwMDIzLVxcdTAwMkJcXHUwMDJELVxcdTAwM0FcXHUwMDNDLVxcdTAwNUJcXHUwMDVELVxcdTAwN0VdKlxcMSQvO1xyXG5cclxuLyoqXHJcbiAqIFJlZ0V4cCB0byBtYXRjaCBkb21haW4tdmFsdWUgaW4gUkZDIDYyNjUgc2VjIDQuMS4xXHJcbiAqXHJcbiAqIGRvbWFpbi12YWx1ZSAgICAgID0gPHN1YmRvbWFpbj5cclxuICogICAgICAgICAgICAgICAgICAgICA7IGRlZmluZWQgaW4gW1JGQzEwMzRdLCBTZWN0aW9uIDMuNSwgYXNcclxuICogICAgICAgICAgICAgICAgICAgICA7IGVuaGFuY2VkIGJ5IFtSRkMxMTIzXSwgU2VjdGlvbiAyLjFcclxuICogPHN1YmRvbWFpbj4gICAgICAgPSA8bGFiZWw+IHwgPHN1YmRvbWFpbj4gXCIuXCIgPGxhYmVsPlxyXG4gKiA8bGFiZWw+ICAgICAgICAgICA9IDxsZXQtZGlnPiBbIFsgPGxkaC1zdHI+IF0gPGxldC1kaWc+IF1cclxuICogICAgICAgICAgICAgICAgICAgICBMYWJlbHMgbXVzdCBiZSA2MyBjaGFyYWN0ZXJzIG9yIGxlc3MuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgJ2xldC1kaWcnIG5vdCAnbGV0dGVyJyBpbiB0aGUgZmlyc3QgY2hhciwgcGVyIFJGQzExMjNcclxuICogPGxkaC1zdHI+ICAgICAgICAgPSA8bGV0LWRpZy1oeXA+IHwgPGxldC1kaWctaHlwPiA8bGRoLXN0cj5cclxuICogPGxldC1kaWctaHlwPiAgICAgPSA8bGV0LWRpZz4gfCBcIi1cIlxyXG4gKiA8bGV0LWRpZz4gICAgICAgICA9IDxsZXR0ZXI+IHwgPGRpZ2l0PlxyXG4gKiA8bGV0dGVyPiAgICAgICAgICA9IGFueSBvbmUgb2YgdGhlIDUyIGFscGhhYmV0aWMgY2hhcmFjdGVycyBBIHRocm91Z2ggWiBpblxyXG4gKiAgICAgICAgICAgICAgICAgICAgIHVwcGVyIGNhc2UgYW5kIGEgdGhyb3VnaCB6IGluIGxvd2VyIGNhc2VcclxuICogPGRpZ2l0PiAgICAgICAgICAgPSBhbnkgb25lIG9mIHRoZSB0ZW4gZGlnaXRzIDAgdGhyb3VnaCA5XHJcbiAqXHJcbiAqIEtlZXAgc3VwcG9ydCBmb3IgbGVhZGluZyBkb3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9qc2h0dHAvY29va2llL2lzc3Vlcy8xNzNcclxuICpcclxuICogPiAoTm90ZSB0aGF0IGEgbGVhZGluZyAleDJFIChcIi5cIiksIGlmIHByZXNlbnQsIGlzIGlnbm9yZWQgZXZlbiB0aG91Z2ggdGhhdFxyXG4gKiBjaGFyYWN0ZXIgaXMgbm90IHBlcm1pdHRlZCwgYnV0IGEgdHJhaWxpbmcgJXgyRSAoXCIuXCIpLCBpZiBwcmVzZW50LCB3aWxsXHJcbiAqIGNhdXNlIHRoZSB1c2VyIGFnZW50IHRvIGlnbm9yZSB0aGUgYXR0cmlidXRlLilcclxuICovXHJcblxyXG52YXIgZG9tYWluVmFsdWVSZWdFeHAgPSAvXihbLl0/W2EtejAtOV0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPykoWy5dW2EtejAtOV0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPykqJC9pO1xyXG5cclxuLyoqXHJcbiAqIFJlZ0V4cCB0byBtYXRjaCBwYXRoLXZhbHVlIGluIFJGQyA2MjY1IHNlYyA0LjEuMVxyXG4gKlxyXG4gKiBwYXRoLXZhbHVlICAgICAgICA9IDxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBcIjtcIj5cclxuICogQ0hBUiAgICAgICAgICAgICAgPSAleDAxLTdGXHJcbiAqICAgICAgICAgICAgICAgICAgICAgOyBkZWZpbmVkIGluIFJGQyA1MjM0IGFwcGVuZGl4IEIuMVxyXG4gKi9cclxuXHJcbnZhciBwYXRoVmFsdWVSZWdFeHAgPSAvXltcXHUwMDIwLVxcdTAwM0FcXHUwMDNELVxcdTAwN0VdKiQvO1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlIGEgY29va2llIGhlYWRlci5cclxuICpcclxuICogUGFyc2UgdGhlIGdpdmVuIGNvb2tpZSBoZWFkZXIgc3RyaW5nIGludG8gYW4gb2JqZWN0XHJcbiAqIFRoZSBvYmplY3QgaGFzIHRoZSB2YXJpb3VzIGNvb2tpZXMgYXMga2V5cyhuYW1lcykgPT4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRdXHJcbiAqIEByZXR1cm4ge29iamVjdH1cclxuICogQHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHBhcnNlKHN0ciwgb3B0KSB7XHJcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHIgbXVzdCBiZSBhIHN0cmluZycpO1xyXG4gIH1cclxuXHJcbiAgdmFyIG9iaiA9IHt9O1xyXG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xyXG4gIC8vIFJGQyA2MjY1IHNlYyA0LjEuMSwgUkZDIDI2MTYgMi4yIGRlZmluZXMgYSBjb29raWUgbmFtZSBjb25zaXN0cyBvZiBvbmUgY2hhciBtaW5pbXVtLCBwbHVzICc9Jy5cclxuICBpZiAobGVuIDwgMikgcmV0dXJuIG9iajtcclxuXHJcbiAgdmFyIGRlYyA9IChvcHQgJiYgb3B0LmRlY29kZSkgfHwgZGVjb2RlO1xyXG4gIHZhciBpbmRleCA9IDA7XHJcbiAgdmFyIGVxSWR4ID0gMDtcclxuICB2YXIgZW5kSWR4ID0gMDtcclxuXHJcbiAgZG8ge1xyXG4gICAgZXFJZHggPSBzdHIuaW5kZXhPZignPScsIGluZGV4KTtcclxuICAgIGlmIChlcUlkeCA9PT0gLTEpIGJyZWFrOyAvLyBObyBtb3JlIGNvb2tpZSBwYWlycy5cclxuXHJcbiAgICBlbmRJZHggPSBzdHIuaW5kZXhPZignOycsIGluZGV4KTtcclxuXHJcbiAgICBpZiAoZW5kSWR4ID09PSAtMSkge1xyXG4gICAgICBlbmRJZHggPSBsZW47XHJcbiAgICB9IGVsc2UgaWYgKGVxSWR4ID4gZW5kSWR4KSB7XHJcbiAgICAgIC8vIGJhY2t0cmFjayBvbiBwcmlvciBzZW1pY29sb25cclxuICAgICAgaW5kZXggPSBzdHIubGFzdEluZGV4T2YoJzsnLCBlcUlkeCAtIDEpICsgMTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtleVN0YXJ0SWR4ID0gc3RhcnRJbmRleChzdHIsIGluZGV4LCBlcUlkeCk7XHJcbiAgICB2YXIga2V5RW5kSWR4ID0gZW5kSW5kZXgoc3RyLCBlcUlkeCwga2V5U3RhcnRJZHgpO1xyXG4gICAgdmFyIGtleSA9IHN0ci5zbGljZShrZXlTdGFydElkeCwga2V5RW5kSWR4KTtcclxuXHJcbiAgICAvLyBvbmx5IGFzc2lnbiBvbmNlXHJcbiAgICBpZiAoIV9faGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgdmFyIHZhbFN0YXJ0SWR4ID0gc3RhcnRJbmRleChzdHIsIGVxSWR4ICsgMSwgZW5kSWR4KTtcclxuICAgICAgdmFyIHZhbEVuZElkeCA9IGVuZEluZGV4KHN0ciwgZW5kSWR4LCB2YWxTdGFydElkeCk7XHJcblxyXG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQodmFsU3RhcnRJZHgpID09PSAweDIyIC8qIFwiICovICYmIHN0ci5jaGFyQ29kZUF0KHZhbEVuZElkeCAtIDEpID09PSAweDIyIC8qIFwiICovKSB7XHJcbiAgICAgICAgdmFsU3RhcnRJZHgrKztcclxuICAgICAgICB2YWxFbmRJZHgtLTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHZhbCA9IHN0ci5zbGljZSh2YWxTdGFydElkeCwgdmFsRW5kSWR4KTtcclxuICAgICAgb2JqW2tleV0gPSB0cnlEZWNvZGUodmFsLCBkZWMpO1xyXG4gICAgfVxyXG5cclxuICAgIGluZGV4ID0gZW5kSWR4ICsgMVxyXG4gIH0gd2hpbGUgKGluZGV4IDwgbGVuKTtcclxuXHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RhcnRJbmRleChzdHIsIGluZGV4LCBtYXgpIHtcclxuICBkbyB7XHJcbiAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcclxuICAgIGlmIChjb2RlICE9PSAweDIwIC8qICAgKi8gJiYgY29kZSAhPT0gMHgwOSAvKiBcXHQgKi8pIHJldHVybiBpbmRleDtcclxuICB9IHdoaWxlICgrK2luZGV4IDwgbWF4KTtcclxuICByZXR1cm4gbWF4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbmRJbmRleChzdHIsIGluZGV4LCBtaW4pIHtcclxuICB3aGlsZSAoaW5kZXggPiBtaW4pIHtcclxuICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoLS1pbmRleCk7XHJcbiAgICBpZiAoY29kZSAhPT0gMHgyMCAvKiAgICovICYmIGNvZGUgIT09IDB4MDkgLyogXFx0ICovKSByZXR1cm4gaW5kZXggKyAxO1xyXG4gIH1cclxuICByZXR1cm4gbWluO1xyXG59XHJcblxyXG4vKipcclxuICogU2VyaWFsaXplIGRhdGEgaW50byBhIGNvb2tpZSBoZWFkZXIuXHJcbiAqXHJcbiAqIFNlcmlhbGl6ZSBhIG5hbWUgdmFsdWUgcGFpciBpbnRvIGEgY29va2llIHN0cmluZyBzdWl0YWJsZSBmb3JcclxuICogaHR0cCBoZWFkZXJzLiBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY29va2llIHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIHNlcmlhbGl6ZSgnZm9vJywgJ2JhcicsIHsgaHR0cE9ubHk6IHRydWUgfSlcclxuICogICA9PiBcImZvbz1iYXI7IGh0dHBPbmx5XCJcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdF1cclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc2VyaWFsaXplKG5hbWUsIHZhbCwgb3B0KSB7XHJcbiAgdmFyIGVuYyA9IChvcHQgJiYgb3B0LmVuY29kZSkgfHwgZW5jb2RlVVJJQ29tcG9uZW50O1xyXG5cclxuICBpZiAodHlwZW9mIGVuYyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIGVuY29kZSBpcyBpbnZhbGlkJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoIWNvb2tpZU5hbWVSZWdFeHAudGVzdChuYW1lKSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbmFtZSBpcyBpbnZhbGlkJyk7XHJcbiAgfVxyXG5cclxuICB2YXIgdmFsdWUgPSBlbmModmFsKTtcclxuXHJcbiAgaWYgKCFjb29raWVWYWx1ZVJlZ0V4cC50ZXN0KHZhbHVlKSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgdmFsIGlzIGludmFsaWQnKTtcclxuICB9XHJcblxyXG4gIHZhciBzdHIgPSBuYW1lICsgJz0nICsgdmFsdWU7XHJcbiAgaWYgKCFvcHQpIHJldHVybiBzdHI7XHJcblxyXG4gIGlmIChudWxsICE9IG9wdC5tYXhBZ2UpIHtcclxuICAgIHZhciBtYXhBZ2UgPSBNYXRoLmZsb29yKG9wdC5tYXhBZ2UpO1xyXG5cclxuICAgIGlmICghaXNGaW5pdGUobWF4QWdlKSkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gbWF4QWdlIGlzIGludmFsaWQnKVxyXG4gICAgfVxyXG5cclxuICAgIHN0ciArPSAnOyBNYXgtQWdlPScgKyBtYXhBZ2U7XHJcbiAgfVxyXG5cclxuICBpZiAob3B0LmRvbWFpbikge1xyXG4gICAgaWYgKCFkb21haW5WYWx1ZVJlZ0V4cC50ZXN0KG9wdC5kb21haW4pKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBkb21haW4gaXMgaW52YWxpZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0ciArPSAnOyBEb21haW49JyArIG9wdC5kb21haW47XHJcbiAgfVxyXG5cclxuICBpZiAob3B0LnBhdGgpIHtcclxuICAgIGlmICghcGF0aFZhbHVlUmVnRXhwLnRlc3Qob3B0LnBhdGgpKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBwYXRoIGlzIGludmFsaWQnKTtcclxuICAgIH1cclxuXHJcbiAgICBzdHIgKz0gJzsgUGF0aD0nICsgb3B0LnBhdGg7XHJcbiAgfVxyXG5cclxuICBpZiAob3B0LmV4cGlyZXMpIHtcclxuICAgIHZhciBleHBpcmVzID0gb3B0LmV4cGlyZXNcclxuXHJcbiAgICBpZiAoIWlzRGF0ZShleHBpcmVzKSB8fCBpc05hTihleHBpcmVzLnZhbHVlT2YoKSkpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIGV4cGlyZXMgaXMgaW52YWxpZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0ciArPSAnOyBFeHBpcmVzPScgKyBleHBpcmVzLnRvVVRDU3RyaW5nKClcclxuICB9XHJcblxyXG4gIGlmIChvcHQuaHR0cE9ubHkpIHtcclxuICAgIHN0ciArPSAnOyBIdHRwT25seSc7XHJcbiAgfVxyXG5cclxuICBpZiAob3B0LnNlY3VyZSkge1xyXG4gICAgc3RyICs9ICc7IFNlY3VyZSc7XHJcbiAgfVxyXG5cclxuICBpZiAob3B0LnBhcnRpdGlvbmVkKSB7XHJcbiAgICBzdHIgKz0gJzsgUGFydGl0aW9uZWQnXHJcbiAgfVxyXG5cclxuICBpZiAob3B0LnByaW9yaXR5KSB7XHJcbiAgICB2YXIgcHJpb3JpdHkgPSB0eXBlb2Ygb3B0LnByaW9yaXR5ID09PSAnc3RyaW5nJ1xyXG4gICAgICA/IG9wdC5wcmlvcml0eS50b0xvd2VyQ2FzZSgpIDogb3B0LnByaW9yaXR5O1xyXG5cclxuICAgIHN3aXRjaCAocHJpb3JpdHkpIHtcclxuICAgICAgY2FzZSAnbG93JzpcclxuICAgICAgICBzdHIgKz0gJzsgUHJpb3JpdHk9TG93J1xyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgJ21lZGl1bSc6XHJcbiAgICAgICAgc3RyICs9ICc7IFByaW9yaXR5PU1lZGl1bSdcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlICdoaWdoJzpcclxuICAgICAgICBzdHIgKz0gJzsgUHJpb3JpdHk9SGlnaCdcclxuICAgICAgICBicmVha1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBwcmlvcml0eSBpcyBpbnZhbGlkJylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChvcHQuc2FtZVNpdGUpIHtcclxuICAgIHZhciBzYW1lU2l0ZSA9IHR5cGVvZiBvcHQuc2FtZVNpdGUgPT09ICdzdHJpbmcnXHJcbiAgICAgID8gb3B0LnNhbWVTaXRlLnRvTG93ZXJDYXNlKCkgOiBvcHQuc2FtZVNpdGU7XHJcblxyXG4gICAgc3dpdGNoIChzYW1lU2l0ZSkge1xyXG4gICAgICBjYXNlIHRydWU6XHJcbiAgICAgICAgc3RyICs9ICc7IFNhbWVTaXRlPVN0cmljdCc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2xheCc6XHJcbiAgICAgICAgc3RyICs9ICc7IFNhbWVTaXRlPUxheCc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3N0cmljdCc6XHJcbiAgICAgICAgc3RyICs9ICc7IFNhbWVTaXRlPVN0cmljdCc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ25vbmUnOlxyXG4gICAgICAgIHN0ciArPSAnOyBTYW1lU2l0ZT1Ob25lJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gc2FtZVNpdGUgaXMgaW52YWxpZCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVSTC1kZWNvZGUgc3RyaW5nIHZhbHVlLiBPcHRpbWl6ZWQgdG8gc2tpcCBuYXRpdmUgY2FsbCB3aGVuIG5vICUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcblxyXG5mdW5jdGlvbiBkZWNvZGUgKHN0cikge1xyXG4gIHJldHVybiBzdHIuaW5kZXhPZignJScpICE9PSAtMVxyXG4gICAgPyBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxyXG4gICAgOiBzdHJcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSBpZiB2YWx1ZSBpcyBhIERhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gaXNEYXRlICh2YWwpIHtcclxuICByZXR1cm4gX190b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyeSBkZWNvZGluZyBhIHN0cmluZyB1c2luZyBhIGRlY29kaW5nIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRlY29kZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHRyeURlY29kZShzdHIsIGRlY29kZSkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZGVjb2RlKHN0cik7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJwYXJzZSIsInNlcmlhbGl6ZSIsIl9fdG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsIl9faGFzT3duUHJvcGVydHkiLCJoYXNPd25Qcm9wZXJ0eSIsImNvb2tpZU5hbWVSZWdFeHAiLCJjb29raWVWYWx1ZVJlZ0V4cCIsImRvbWFpblZhbHVlUmVnRXhwIiwicGF0aFZhbHVlUmVnRXhwIiwic3RyIiwib3B0IiwiVHlwZUVycm9yIiwib2JqIiwibGVuIiwibGVuZ3RoIiwiZGVjIiwiZGVjb2RlIiwiaW5kZXgiLCJlcUlkeCIsImVuZElkeCIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImtleVN0YXJ0SWR4Iiwic3RhcnRJbmRleCIsImtleUVuZElkeCIsImVuZEluZGV4Iiwia2V5Iiwic2xpY2UiLCJjYWxsIiwidmFsU3RhcnRJZHgiLCJ2YWxFbmRJZHgiLCJjaGFyQ29kZUF0IiwidmFsIiwidHJ5RGVjb2RlIiwibWF4IiwiY29kZSIsIm1pbiIsIm5hbWUiLCJlbmMiLCJlbmNvZGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ0ZXN0IiwidmFsdWUiLCJtYXhBZ2UiLCJNYXRoIiwiZmxvb3IiLCJpc0Zpbml0ZSIsImRvbWFpbiIsInBhdGgiLCJleHBpcmVzIiwiaXNEYXRlIiwiaXNOYU4iLCJ2YWx1ZU9mIiwidG9VVENTdHJpbmciLCJodHRwT25seSIsInNlY3VyZSIsInBhcnRpdGlvbmVkIiwicHJpb3JpdHkiLCJ0b0xvd2VyQ2FzZSIsInNhbWVTaXRlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cookie/index.js\n");

/***/ })

};
;